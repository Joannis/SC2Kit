// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: s2clientprotocol/spatial.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct SC2APIProtocol_ObservationFeatureLayer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var renders: SC2APIProtocol_FeatureLayers {
    get {return _storage._renders ?? SC2APIProtocol_FeatureLayers()}
    set {_uniqueStorage()._renders = newValue}
  }
  /// Returns true if `renders` has been explicitly set.
  var hasRenders: Bool {return _storage._renders != nil}
  /// Clears the value of `renders`. Subsequent reads from it will return its default value.
  mutating func clearRenders() {_uniqueStorage()._renders = nil}

  var minimapRenders: SC2APIProtocol_FeatureLayersMinimap {
    get {return _storage._minimapRenders ?? SC2APIProtocol_FeatureLayersMinimap()}
    set {_uniqueStorage()._minimapRenders = newValue}
  }
  /// Returns true if `minimapRenders` has been explicitly set.
  var hasMinimapRenders: Bool {return _storage._minimapRenders != nil}
  /// Clears the value of `minimapRenders`. Subsequent reads from it will return its default value.
  mutating func clearMinimapRenders() {_uniqueStorage()._minimapRenders = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_FeatureLayers {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// uint8. Terrain height. World space units of [-200, 200] encoded into [0, 255].
  var heightMap: SC2APIProtocol_ImageData {
    get {return _storage._heightMap ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._heightMap = newValue}
  }
  /// Returns true if `heightMap` has been explicitly set.
  var hasHeightMap: Bool {return _storage._heightMap != nil}
  /// Clears the value of `heightMap`. Subsequent reads from it will return its default value.
  mutating func clearHeightMap() {_uniqueStorage()._heightMap = nil}

  /// uint8. 0=Hidden, 1=Fogged, 2=Visible, 3=FullHidden
  var visibilityMap: SC2APIProtocol_ImageData {
    get {return _storage._visibilityMap ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._visibilityMap = newValue}
  }
  /// Returns true if `visibilityMap` has been explicitly set.
  var hasVisibilityMap: Bool {return _storage._visibilityMap != nil}
  /// Clears the value of `visibilityMap`. Subsequent reads from it will return its default value.
  mutating func clearVisibilityMap() {_uniqueStorage()._visibilityMap = nil}

  /// 1-bit. Zerg creep.
  var creep: SC2APIProtocol_ImageData {
    get {return _storage._creep ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._creep = newValue}
  }
  /// Returns true if `creep` has been explicitly set.
  var hasCreep: Bool {return _storage._creep != nil}
  /// Clears the value of `creep`. Subsequent reads from it will return its default value.
  mutating func clearCreep() {_uniqueStorage()._creep = nil}

  /// 1-bit. Protoss power.
  var power: SC2APIProtocol_ImageData {
    get {return _storage._power ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._power = newValue}
  }
  /// Returns true if `power` has been explicitly set.
  var hasPower: Bool {return _storage._power != nil}
  /// Clears the value of `power`. Subsequent reads from it will return its default value.
  mutating func clearPower() {_uniqueStorage()._power = nil}

  /// uint8. Participants: [1, 15] Neutral: 16
  var playerID: SC2APIProtocol_ImageData {
    get {return _storage._playerID ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._playerID = newValue}
  }
  /// Returns true if `playerID` has been explicitly set.
  var hasPlayerID: Bool {return _storage._playerID != nil}
  /// Clears the value of `playerID`. Subsequent reads from it will return its default value.
  mutating func clearPlayerID() {_uniqueStorage()._playerID = nil}

  /// int32. Unique identifier for type of unit.
  var unitType: SC2APIProtocol_ImageData {
    get {return _storage._unitType ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._unitType = newValue}
  }
  /// Returns true if `unitType` has been explicitly set.
  var hasUnitType: Bool {return _storage._unitType != nil}
  /// Clears the value of `unitType`. Subsequent reads from it will return its default value.
  mutating func clearUnitType() {_uniqueStorage()._unitType = nil}

  /// 1-bit. Selected units.
  var selected: SC2APIProtocol_ImageData {
    get {return _storage._selected ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._selected = newValue}
  }
  /// Returns true if `selected` has been explicitly set.
  var hasSelected: Bool {return _storage._selected != nil}
  /// Clears the value of `selected`. Subsequent reads from it will return its default value.
  mutating func clearSelected() {_uniqueStorage()._selected = nil}

  /// int32.
  var unitHitPoints: SC2APIProtocol_ImageData {
    get {return _storage._unitHitPoints ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._unitHitPoints = newValue}
  }
  /// Returns true if `unitHitPoints` has been explicitly set.
  var hasUnitHitPoints: Bool {return _storage._unitHitPoints != nil}
  /// Clears the value of `unitHitPoints`. Subsequent reads from it will return its default value.
  mutating func clearUnitHitPoints() {_uniqueStorage()._unitHitPoints = nil}

  /// uint8. Ratio of current health to max health. [0%, 100%] encoded into [0, 255].
  var unitHitPointsRatio: SC2APIProtocol_ImageData {
    get {return _storage._unitHitPointsRatio ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._unitHitPointsRatio = newValue}
  }
  /// Returns true if `unitHitPointsRatio` has been explicitly set.
  var hasUnitHitPointsRatio: Bool {return _storage._unitHitPointsRatio != nil}
  /// Clears the value of `unitHitPointsRatio`. Subsequent reads from it will return its default value.
  mutating func clearUnitHitPointsRatio() {_uniqueStorage()._unitHitPointsRatio = nil}

  /// int32.
  var unitEnergy: SC2APIProtocol_ImageData {
    get {return _storage._unitEnergy ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._unitEnergy = newValue}
  }
  /// Returns true if `unitEnergy` has been explicitly set.
  var hasUnitEnergy: Bool {return _storage._unitEnergy != nil}
  /// Clears the value of `unitEnergy`. Subsequent reads from it will return its default value.
  mutating func clearUnitEnergy() {_uniqueStorage()._unitEnergy = nil}

  /// uint8. Ratio of current energy to max energy. [0%, 100%] encoded into [0, 255].
  var unitEnergyRatio: SC2APIProtocol_ImageData {
    get {return _storage._unitEnergyRatio ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._unitEnergyRatio = newValue}
  }
  /// Returns true if `unitEnergyRatio` has been explicitly set.
  var hasUnitEnergyRatio: Bool {return _storage._unitEnergyRatio != nil}
  /// Clears the value of `unitEnergyRatio`. Subsequent reads from it will return its default value.
  mutating func clearUnitEnergyRatio() {_uniqueStorage()._unitEnergyRatio = nil}

  /// int32.
  var unitShields: SC2APIProtocol_ImageData {
    get {return _storage._unitShields ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._unitShields = newValue}
  }
  /// Returns true if `unitShields` has been explicitly set.
  var hasUnitShields: Bool {return _storage._unitShields != nil}
  /// Clears the value of `unitShields`. Subsequent reads from it will return its default value.
  mutating func clearUnitShields() {_uniqueStorage()._unitShields = nil}

  /// uint8. Ratio of current shields to max shields. [0%, 100%] encoded into [0, 255].
  var unitShieldsRatio: SC2APIProtocol_ImageData {
    get {return _storage._unitShieldsRatio ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._unitShieldsRatio = newValue}
  }
  /// Returns true if `unitShieldsRatio` has been explicitly set.
  var hasUnitShieldsRatio: Bool {return _storage._unitShieldsRatio != nil}
  /// Clears the value of `unitShieldsRatio`. Subsequent reads from it will return its default value.
  mutating func clearUnitShieldsRatio() {_uniqueStorage()._unitShieldsRatio = nil}

  /// uint8. See "Alliance" enum in raw.proto. Range: [1, 4] 
  var playerRelative: SC2APIProtocol_ImageData {
    get {return _storage._playerRelative ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._playerRelative = newValue}
  }
  /// Returns true if `playerRelative` has been explicitly set.
  var hasPlayerRelative: Bool {return _storage._playerRelative != nil}
  /// Clears the value of `playerRelative`. Subsequent reads from it will return its default value.
  mutating func clearPlayerRelative() {_uniqueStorage()._playerRelative = nil}

  /// uint8. Density of units overlapping a pixel, anti-aliased. [0.0, 16.0f] encoded into [0, 255].
  var unitDensityAa: SC2APIProtocol_ImageData {
    get {return _storage._unitDensityAa ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._unitDensityAa = newValue}
  }
  /// Returns true if `unitDensityAa` has been explicitly set.
  var hasUnitDensityAa: Bool {return _storage._unitDensityAa != nil}
  /// Clears the value of `unitDensityAa`. Subsequent reads from it will return its default value.
  mutating func clearUnitDensityAa() {_uniqueStorage()._unitDensityAa = nil}

  /// uint8. Count of units overlapping a pixel.
  var unitDensity: SC2APIProtocol_ImageData {
    get {return _storage._unitDensity ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._unitDensity = newValue}
  }
  /// Returns true if `unitDensity` has been explicitly set.
  var hasUnitDensity: Bool {return _storage._unitDensity != nil}
  /// Clears the value of `unitDensity`. Subsequent reads from it will return its default value.
  mutating func clearUnitDensity() {_uniqueStorage()._unitDensity = nil}

  /// uint8. Visuals of persistent abilities. (eg. Psistorm)
  var effects: SC2APIProtocol_ImageData {
    get {return _storage._effects ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._effects = newValue}
  }
  /// Returns true if `effects` has been explicitly set.
  var hasEffects: Bool {return _storage._effects != nil}
  /// Clears the value of `effects`. Subsequent reads from it will return its default value.
  mutating func clearEffects() {_uniqueStorage()._effects = nil}

  /// 1-bit. Whether the unit here is a hallucination.
  var hallucinations: SC2APIProtocol_ImageData {
    get {return _storage._hallucinations ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._hallucinations = newValue}
  }
  /// Returns true if `hallucinations` has been explicitly set.
  var hasHallucinations: Bool {return _storage._hallucinations != nil}
  /// Clears the value of `hallucinations`. Subsequent reads from it will return its default value.
  mutating func clearHallucinations() {_uniqueStorage()._hallucinations = nil}

  /// 1-bit. Whether the unit here is cloaked. Hidden units will show up too, but with less details in other layers.
  var cloaked: SC2APIProtocol_ImageData {
    get {return _storage._cloaked ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._cloaked = newValue}
  }
  /// Returns true if `cloaked` has been explicitly set.
  var hasCloaked: Bool {return _storage._cloaked != nil}
  /// Clears the value of `cloaked`. Subsequent reads from it will return its default value.
  mutating func clearCloaked() {_uniqueStorage()._cloaked = nil}

  /// 1-bit. Whether the unit here is a blip.
  var blip: SC2APIProtocol_ImageData {
    get {return _storage._blip ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._blip = newValue}
  }
  /// Returns true if `blip` has been explicitly set.
  var hasBlip: Bool {return _storage._blip != nil}
  /// Clears the value of `blip`. Subsequent reads from it will return its default value.
  mutating func clearBlip() {_uniqueStorage()._blip = nil}

  /// int32. One of the buffs applied to this unit. Extras are ignored.
  var buffs: SC2APIProtocol_ImageData {
    get {return _storage._buffs ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._buffs = newValue}
  }
  /// Returns true if `buffs` has been explicitly set.
  var hasBuffs: Bool {return _storage._buffs != nil}
  /// Clears the value of `buffs`. Subsequent reads from it will return its default value.
  mutating func clearBuffs() {_uniqueStorage()._buffs = nil}

  /// uint8. Ratio of buff remaining. [0%, 100%] encoded into [0, 255].
  var buffDuration: SC2APIProtocol_ImageData {
    get {return _storage._buffDuration ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._buffDuration = newValue}
  }
  /// Returns true if `buffDuration` has been explicitly set.
  var hasBuffDuration: Bool {return _storage._buffDuration != nil}
  /// Clears the value of `buffDuration`. Subsequent reads from it will return its default value.
  mutating func clearBuffDuration() {_uniqueStorage()._buffDuration = nil}

  /// 1-bit. Whether the unit here is active.
  var active: SC2APIProtocol_ImageData {
    get {return _storage._active ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._active = newValue}
  }
  /// Returns true if `active` has been explicitly set.
  var hasActive: Bool {return _storage._active != nil}
  /// Clears the value of `active`. Subsequent reads from it will return its default value.
  mutating func clearActive() {_uniqueStorage()._active = nil}

  /// uint8. How far along the building is building something. [0%, 100%] encoded into [0, 255].
  var buildProgress: SC2APIProtocol_ImageData {
    get {return _storage._buildProgress ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._buildProgress = newValue}
  }
  /// Returns true if `buildProgress` has been explicitly set.
  var hasBuildProgress: Bool {return _storage._buildProgress != nil}
  /// Clears the value of `buildProgress`. Subsequent reads from it will return its default value.
  mutating func clearBuildProgress() {_uniqueStorage()._buildProgress = nil}

  /// 1-bit. Whether a building can be built here.
  var buildable: SC2APIProtocol_ImageData {
    get {return _storage._buildable ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._buildable = newValue}
  }
  /// Returns true if `buildable` has been explicitly set.
  var hasBuildable: Bool {return _storage._buildable != nil}
  /// Clears the value of `buildable`. Subsequent reads from it will return its default value.
  mutating func clearBuildable() {_uniqueStorage()._buildable = nil}

  /// 1-bit. Whether a unit can walk here.
  var pathable: SC2APIProtocol_ImageData {
    get {return _storage._pathable ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._pathable = newValue}
  }
  /// Returns true if `pathable` has been explicitly set.
  var hasPathable: Bool {return _storage._pathable != nil}
  /// Clears the value of `pathable`. Subsequent reads from it will return its default value.
  mutating func clearPathable() {_uniqueStorage()._pathable = nil}

  /// 1-bit. Whether the unit here is a placeholder building to be constructed.
  var placeholder: SC2APIProtocol_ImageData {
    get {return _storage._placeholder ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._placeholder = newValue}
  }
  /// Returns true if `placeholder` has been explicitly set.
  var hasPlaceholder: Bool {return _storage._placeholder != nil}
  /// Clears the value of `placeholder`. Subsequent reads from it will return its default value.
  mutating func clearPlaceholder() {_uniqueStorage()._placeholder = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_FeatureLayersMinimap {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// uint8. Terrain height. World space units of [-200, 200] encoded into [0, 255].
  var heightMap: SC2APIProtocol_ImageData {
    get {return _storage._heightMap ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._heightMap = newValue}
  }
  /// Returns true if `heightMap` has been explicitly set.
  var hasHeightMap: Bool {return _storage._heightMap != nil}
  /// Clears the value of `heightMap`. Subsequent reads from it will return its default value.
  mutating func clearHeightMap() {_uniqueStorage()._heightMap = nil}

  /// uint8. 0=Hidden, 1=Fogged, 2=Visible, 3=FullHidden
  var visibilityMap: SC2APIProtocol_ImageData {
    get {return _storage._visibilityMap ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._visibilityMap = newValue}
  }
  /// Returns true if `visibilityMap` has been explicitly set.
  var hasVisibilityMap: Bool {return _storage._visibilityMap != nil}
  /// Clears the value of `visibilityMap`. Subsequent reads from it will return its default value.
  mutating func clearVisibilityMap() {_uniqueStorage()._visibilityMap = nil}

  /// 1-bit. Zerg creep.
  var creep: SC2APIProtocol_ImageData {
    get {return _storage._creep ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._creep = newValue}
  }
  /// Returns true if `creep` has been explicitly set.
  var hasCreep: Bool {return _storage._creep != nil}
  /// Clears the value of `creep`. Subsequent reads from it will return its default value.
  mutating func clearCreep() {_uniqueStorage()._creep = nil}

  /// 1-bit. Area covered by the camera.
  var camera: SC2APIProtocol_ImageData {
    get {return _storage._camera ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._camera = newValue}
  }
  /// Returns true if `camera` has been explicitly set.
  var hasCamera: Bool {return _storage._camera != nil}
  /// Clears the value of `camera`. Subsequent reads from it will return its default value.
  mutating func clearCamera() {_uniqueStorage()._camera = nil}

  /// uint8. Participants: [1, 15] Neutral: 16
  var playerID: SC2APIProtocol_ImageData {
    get {return _storage._playerID ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._playerID = newValue}
  }
  /// Returns true if `playerID` has been explicitly set.
  var hasPlayerID: Bool {return _storage._playerID != nil}
  /// Clears the value of `playerID`. Subsequent reads from it will return its default value.
  mutating func clearPlayerID() {_uniqueStorage()._playerID = nil}

  /// uint8. See "Alliance" enum in raw.proto. Range: [1, 4] 
  var playerRelative: SC2APIProtocol_ImageData {
    get {return _storage._playerRelative ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._playerRelative = newValue}
  }
  /// Returns true if `playerRelative` has been explicitly set.
  var hasPlayerRelative: Bool {return _storage._playerRelative != nil}
  /// Clears the value of `playerRelative`. Subsequent reads from it will return its default value.
  mutating func clearPlayerRelative() {_uniqueStorage()._playerRelative = nil}

  /// 1-bit. Selected units.
  var selected: SC2APIProtocol_ImageData {
    get {return _storage._selected ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._selected = newValue}
  }
  /// Returns true if `selected` has been explicitly set.
  var hasSelected: Bool {return _storage._selected != nil}
  /// Clears the value of `selected`. Subsequent reads from it will return its default value.
  mutating func clearSelected() {_uniqueStorage()._selected = nil}

  /// 1-bit. Shows 'UnitAttacked' alert location.
  var alerts: SC2APIProtocol_ImageData {
    get {return _storage._alerts ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._alerts = newValue}
  }
  /// Returns true if `alerts` has been explicitly set.
  var hasAlerts: Bool {return _storage._alerts != nil}
  /// Clears the value of `alerts`. Subsequent reads from it will return its default value.
  mutating func clearAlerts() {_uniqueStorage()._alerts = nil}

  /// 1-bit. Whether a building can be built here.
  var buildable: SC2APIProtocol_ImageData {
    get {return _storage._buildable ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._buildable = newValue}
  }
  /// Returns true if `buildable` has been explicitly set.
  var hasBuildable: Bool {return _storage._buildable != nil}
  /// Clears the value of `buildable`. Subsequent reads from it will return its default value.
  mutating func clearBuildable() {_uniqueStorage()._buildable = nil}

  /// 1-bit. Whether a unit can walk here.
  var pathable: SC2APIProtocol_ImageData {
    get {return _storage._pathable ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._pathable = newValue}
  }
  /// Returns true if `pathable` has been explicitly set.
  var hasPathable: Bool {return _storage._pathable != nil}
  /// Clears the value of `pathable`. Subsequent reads from it will return its default value.
  mutating func clearPathable() {_uniqueStorage()._pathable = nil}

  /// Cheat layers, enable with SpatialCameraSetup.allow_cheating_layers.
  var unitType: SC2APIProtocol_ImageData {
    get {return _storage._unitType ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._unitType = newValue}
  }
  /// Returns true if `unitType` has been explicitly set.
  var hasUnitType: Bool {return _storage._unitType != nil}
  /// Clears the value of `unitType`. Subsequent reads from it will return its default value.
  mutating func clearUnitType() {_uniqueStorage()._unitType = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_ObservationRender {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var map: SC2APIProtocol_ImageData {
    get {return _storage._map ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._map = newValue}
  }
  /// Returns true if `map` has been explicitly set.
  var hasMap: Bool {return _storage._map != nil}
  /// Clears the value of `map`. Subsequent reads from it will return its default value.
  mutating func clearMap() {_uniqueStorage()._map = nil}

  var minimap: SC2APIProtocol_ImageData {
    get {return _storage._minimap ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._minimap = newValue}
  }
  /// Returns true if `minimap` has been explicitly set.
  var hasMinimap: Bool {return _storage._minimap != nil}
  /// Clears the value of `minimap`. Subsequent reads from it will return its default value.
  mutating func clearMinimap() {_uniqueStorage()._minimap = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_ActionSpatial {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var action: OneOf_Action? {
    get {return _storage._action}
    set {_uniqueStorage()._action = newValue}
  }

  var unitCommand: SC2APIProtocol_ActionSpatialUnitCommand {
    get {
      if case .unitCommand(let v)? = _storage._action {return v}
      return SC2APIProtocol_ActionSpatialUnitCommand()
    }
    set {_uniqueStorage()._action = .unitCommand(newValue)}
  }

  var cameraMove: SC2APIProtocol_ActionSpatialCameraMove {
    get {
      if case .cameraMove(let v)? = _storage._action {return v}
      return SC2APIProtocol_ActionSpatialCameraMove()
    }
    set {_uniqueStorage()._action = .cameraMove(newValue)}
  }

  var unitSelectionPoint: SC2APIProtocol_ActionSpatialUnitSelectionPoint {
    get {
      if case .unitSelectionPoint(let v)? = _storage._action {return v}
      return SC2APIProtocol_ActionSpatialUnitSelectionPoint()
    }
    set {_uniqueStorage()._action = .unitSelectionPoint(newValue)}
  }

  var unitSelectionRect: SC2APIProtocol_ActionSpatialUnitSelectionRect {
    get {
      if case .unitSelectionRect(let v)? = _storage._action {return v}
      return SC2APIProtocol_ActionSpatialUnitSelectionRect()
    }
    set {_uniqueStorage()._action = .unitSelectionRect(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Action: Equatable {
    case unitCommand(SC2APIProtocol_ActionSpatialUnitCommand)
    case cameraMove(SC2APIProtocol_ActionSpatialCameraMove)
    case unitSelectionPoint(SC2APIProtocol_ActionSpatialUnitSelectionPoint)
    case unitSelectionRect(SC2APIProtocol_ActionSpatialUnitSelectionRect)

  #if !swift(>=4.1)
    static func ==(lhs: SC2APIProtocol_ActionSpatial.OneOf_Action, rhs: SC2APIProtocol_ActionSpatial.OneOf_Action) -> Bool {
      switch (lhs, rhs) {
      case (.unitCommand(let l), .unitCommand(let r)): return l == r
      case (.cameraMove(let l), .cameraMove(let r)): return l == r
      case (.unitSelectionPoint(let l), .unitSelectionPoint(let r)): return l == r
      case (.unitSelectionRect(let l), .unitSelectionRect(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_ActionSpatialUnitCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var abilityID: Int32 {
    get {return _storage._abilityID ?? 0}
    set {_uniqueStorage()._abilityID = newValue}
  }
  /// Returns true if `abilityID` has been explicitly set.
  var hasAbilityID: Bool {return _storage._abilityID != nil}
  /// Clears the value of `abilityID`. Subsequent reads from it will return its default value.
  mutating func clearAbilityID() {_uniqueStorage()._abilityID = nil}

  var target: OneOf_Target? {
    get {return _storage._target}
    set {_uniqueStorage()._target = newValue}
  }

  var targetScreenCoord: SC2APIProtocol_PointI {
    get {
      if case .targetScreenCoord(let v)? = _storage._target {return v}
      return SC2APIProtocol_PointI()
    }
    set {_uniqueStorage()._target = .targetScreenCoord(newValue)}
  }

  var targetMinimapCoord: SC2APIProtocol_PointI {
    get {
      if case .targetMinimapCoord(let v)? = _storage._target {return v}
      return SC2APIProtocol_PointI()
    }
    set {_uniqueStorage()._target = .targetMinimapCoord(newValue)}
  }

  /// Equivalent to shift+command.
  var queueCommand: Bool {
    get {return _storage._queueCommand ?? false}
    set {_uniqueStorage()._queueCommand = newValue}
  }
  /// Returns true if `queueCommand` has been explicitly set.
  var hasQueueCommand: Bool {return _storage._queueCommand != nil}
  /// Clears the value of `queueCommand`. Subsequent reads from it will return its default value.
  mutating func clearQueueCommand() {_uniqueStorage()._queueCommand = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Target: Equatable {
    case targetScreenCoord(SC2APIProtocol_PointI)
    case targetMinimapCoord(SC2APIProtocol_PointI)

  #if !swift(>=4.1)
    static func ==(lhs: SC2APIProtocol_ActionSpatialUnitCommand.OneOf_Target, rhs: SC2APIProtocol_ActionSpatialUnitCommand.OneOf_Target) -> Bool {
      switch (lhs, rhs) {
      case (.targetScreenCoord(let l), .targetScreenCoord(let r)): return l == r
      case (.targetMinimapCoord(let l), .targetMinimapCoord(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_ActionSpatialCameraMove {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Simulates a click on the minimap to move the camera.
  var centerMinimap: SC2APIProtocol_PointI {
    get {return _storage._centerMinimap ?? SC2APIProtocol_PointI()}
    set {_uniqueStorage()._centerMinimap = newValue}
  }
  /// Returns true if `centerMinimap` has been explicitly set.
  var hasCenterMinimap: Bool {return _storage._centerMinimap != nil}
  /// Clears the value of `centerMinimap`. Subsequent reads from it will return its default value.
  mutating func clearCenterMinimap() {_uniqueStorage()._centerMinimap = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_ActionSpatialUnitSelectionPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var selectionScreenCoord: SC2APIProtocol_PointI {
    get {return _storage._selectionScreenCoord ?? SC2APIProtocol_PointI()}
    set {_uniqueStorage()._selectionScreenCoord = newValue}
  }
  /// Returns true if `selectionScreenCoord` has been explicitly set.
  var hasSelectionScreenCoord: Bool {return _storage._selectionScreenCoord != nil}
  /// Clears the value of `selectionScreenCoord`. Subsequent reads from it will return its default value.
  mutating func clearSelectionScreenCoord() {_uniqueStorage()._selectionScreenCoord = nil}

  var type: SC2APIProtocol_ActionSpatialUnitSelectionPoint.TypeEnum {
    get {return _storage._type ?? .select}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Equivalent to normal click. Changes selection to unit.
    case select // = 1

    /// Equivalent to shift+click. Toggle selection of unit.
    case toggle // = 2

    /// Equivalent to control+click. Selects all units of a given type.
    case allType // = 3

    /// Equivalent to shift+control+click. Selects all units of a given type.
    case addAllType // = 4

    init() {
      self = .select
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .select
      case 2: self = .toggle
      case 3: self = .allType
      case 4: self = .addAllType
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .select: return 1
      case .toggle: return 2
      case .allType: return 3
      case .addAllType: return 4
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension SC2APIProtocol_ActionSpatialUnitSelectionPoint.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct SC2APIProtocol_ActionSpatialUnitSelectionRect {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Eventually this should not be an array, but a single field (multiple would be cheating).
  var selectionScreenCoord: [SC2APIProtocol_RectangleI] = []

  /// Equivalent to shift+drag. Adds units to selection.
  var selectionAdd: Bool {
    get {return _selectionAdd ?? false}
    set {_selectionAdd = newValue}
  }
  /// Returns true if `selectionAdd` has been explicitly set.
  var hasSelectionAdd: Bool {return self._selectionAdd != nil}
  /// Clears the value of `selectionAdd`. Subsequent reads from it will return its default value.
  mutating func clearSelectionAdd() {self._selectionAdd = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _selectionAdd: Bool? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "SC2APIProtocol"

extension SC2APIProtocol_ObservationFeatureLayer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ObservationFeatureLayer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "renders"),
    2: .standard(proto: "minimap_renders"),
  ]

  fileprivate class _StorageClass {
    var _renders: SC2APIProtocol_FeatureLayers? = nil
    var _minimapRenders: SC2APIProtocol_FeatureLayersMinimap? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _renders = source._renders
      _minimapRenders = source._minimapRenders
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._renders)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._minimapRenders)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._renders {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._minimapRenders {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ObservationFeatureLayer, rhs: SC2APIProtocol_ObservationFeatureLayer) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._renders != rhs_storage._renders {return false}
        if _storage._minimapRenders != rhs_storage._minimapRenders {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_FeatureLayers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeatureLayers"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "height_map"),
    2: .standard(proto: "visibility_map"),
    3: .same(proto: "creep"),
    4: .same(proto: "power"),
    5: .standard(proto: "player_id"),
    6: .standard(proto: "unit_type"),
    7: .same(proto: "selected"),
    8: .standard(proto: "unit_hit_points"),
    17: .standard(proto: "unit_hit_points_ratio"),
    9: .standard(proto: "unit_energy"),
    18: .standard(proto: "unit_energy_ratio"),
    10: .standard(proto: "unit_shields"),
    19: .standard(proto: "unit_shields_ratio"),
    11: .standard(proto: "player_relative"),
    14: .standard(proto: "unit_density_aa"),
    15: .standard(proto: "unit_density"),
    20: .same(proto: "effects"),
    21: .same(proto: "hallucinations"),
    22: .same(proto: "cloaked"),
    23: .same(proto: "blip"),
    24: .same(proto: "buffs"),
    26: .standard(proto: "buff_duration"),
    25: .same(proto: "active"),
    27: .standard(proto: "build_progress"),
    28: .same(proto: "buildable"),
    29: .same(proto: "pathable"),
    30: .same(proto: "placeholder"),
  ]

  fileprivate class _StorageClass {
    var _heightMap: SC2APIProtocol_ImageData? = nil
    var _visibilityMap: SC2APIProtocol_ImageData? = nil
    var _creep: SC2APIProtocol_ImageData? = nil
    var _power: SC2APIProtocol_ImageData? = nil
    var _playerID: SC2APIProtocol_ImageData? = nil
    var _unitType: SC2APIProtocol_ImageData? = nil
    var _selected: SC2APIProtocol_ImageData? = nil
    var _unitHitPoints: SC2APIProtocol_ImageData? = nil
    var _unitHitPointsRatio: SC2APIProtocol_ImageData? = nil
    var _unitEnergy: SC2APIProtocol_ImageData? = nil
    var _unitEnergyRatio: SC2APIProtocol_ImageData? = nil
    var _unitShields: SC2APIProtocol_ImageData? = nil
    var _unitShieldsRatio: SC2APIProtocol_ImageData? = nil
    var _playerRelative: SC2APIProtocol_ImageData? = nil
    var _unitDensityAa: SC2APIProtocol_ImageData? = nil
    var _unitDensity: SC2APIProtocol_ImageData? = nil
    var _effects: SC2APIProtocol_ImageData? = nil
    var _hallucinations: SC2APIProtocol_ImageData? = nil
    var _cloaked: SC2APIProtocol_ImageData? = nil
    var _blip: SC2APIProtocol_ImageData? = nil
    var _buffs: SC2APIProtocol_ImageData? = nil
    var _buffDuration: SC2APIProtocol_ImageData? = nil
    var _active: SC2APIProtocol_ImageData? = nil
    var _buildProgress: SC2APIProtocol_ImageData? = nil
    var _buildable: SC2APIProtocol_ImageData? = nil
    var _pathable: SC2APIProtocol_ImageData? = nil
    var _placeholder: SC2APIProtocol_ImageData? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _heightMap = source._heightMap
      _visibilityMap = source._visibilityMap
      _creep = source._creep
      _power = source._power
      _playerID = source._playerID
      _unitType = source._unitType
      _selected = source._selected
      _unitHitPoints = source._unitHitPoints
      _unitHitPointsRatio = source._unitHitPointsRatio
      _unitEnergy = source._unitEnergy
      _unitEnergyRatio = source._unitEnergyRatio
      _unitShields = source._unitShields
      _unitShieldsRatio = source._unitShieldsRatio
      _playerRelative = source._playerRelative
      _unitDensityAa = source._unitDensityAa
      _unitDensity = source._unitDensity
      _effects = source._effects
      _hallucinations = source._hallucinations
      _cloaked = source._cloaked
      _blip = source._blip
      _buffs = source._buffs
      _buffDuration = source._buffDuration
      _active = source._active
      _buildProgress = source._buildProgress
      _buildable = source._buildable
      _pathable = source._pathable
      _placeholder = source._placeholder
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._heightMap)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._visibilityMap)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._creep)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._power)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._playerID)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._unitType)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._selected)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._unitHitPoints)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._unitEnergy)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._unitShields)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._playerRelative)
        case 14: try decoder.decodeSingularMessageField(value: &_storage._unitDensityAa)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._unitDensity)
        case 17: try decoder.decodeSingularMessageField(value: &_storage._unitHitPointsRatio)
        case 18: try decoder.decodeSingularMessageField(value: &_storage._unitEnergyRatio)
        case 19: try decoder.decodeSingularMessageField(value: &_storage._unitShieldsRatio)
        case 20: try decoder.decodeSingularMessageField(value: &_storage._effects)
        case 21: try decoder.decodeSingularMessageField(value: &_storage._hallucinations)
        case 22: try decoder.decodeSingularMessageField(value: &_storage._cloaked)
        case 23: try decoder.decodeSingularMessageField(value: &_storage._blip)
        case 24: try decoder.decodeSingularMessageField(value: &_storage._buffs)
        case 25: try decoder.decodeSingularMessageField(value: &_storage._active)
        case 26: try decoder.decodeSingularMessageField(value: &_storage._buffDuration)
        case 27: try decoder.decodeSingularMessageField(value: &_storage._buildProgress)
        case 28: try decoder.decodeSingularMessageField(value: &_storage._buildable)
        case 29: try decoder.decodeSingularMessageField(value: &_storage._pathable)
        case 30: try decoder.decodeSingularMessageField(value: &_storage._placeholder)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._heightMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._visibilityMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._creep {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._power {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._playerID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._unitType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._selected {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._unitHitPoints {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._unitEnergy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._unitShields {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._playerRelative {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._unitDensityAa {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if let v = _storage._unitDensity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._unitHitPointsRatio {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if let v = _storage._unitEnergyRatio {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
      if let v = _storage._unitShieldsRatio {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }
      if let v = _storage._effects {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
      if let v = _storage._hallucinations {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }
      if let v = _storage._cloaked {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }
      if let v = _storage._blip {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }
      if let v = _storage._buffs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }
      if let v = _storage._active {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      }
      if let v = _storage._buffDuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      }
      if let v = _storage._buildProgress {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      }
      if let v = _storage._buildable {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      }
      if let v = _storage._pathable {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      }
      if let v = _storage._placeholder {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_FeatureLayers, rhs: SC2APIProtocol_FeatureLayers) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._heightMap != rhs_storage._heightMap {return false}
        if _storage._visibilityMap != rhs_storage._visibilityMap {return false}
        if _storage._creep != rhs_storage._creep {return false}
        if _storage._power != rhs_storage._power {return false}
        if _storage._playerID != rhs_storage._playerID {return false}
        if _storage._unitType != rhs_storage._unitType {return false}
        if _storage._selected != rhs_storage._selected {return false}
        if _storage._unitHitPoints != rhs_storage._unitHitPoints {return false}
        if _storage._unitHitPointsRatio != rhs_storage._unitHitPointsRatio {return false}
        if _storage._unitEnergy != rhs_storage._unitEnergy {return false}
        if _storage._unitEnergyRatio != rhs_storage._unitEnergyRatio {return false}
        if _storage._unitShields != rhs_storage._unitShields {return false}
        if _storage._unitShieldsRatio != rhs_storage._unitShieldsRatio {return false}
        if _storage._playerRelative != rhs_storage._playerRelative {return false}
        if _storage._unitDensityAa != rhs_storage._unitDensityAa {return false}
        if _storage._unitDensity != rhs_storage._unitDensity {return false}
        if _storage._effects != rhs_storage._effects {return false}
        if _storage._hallucinations != rhs_storage._hallucinations {return false}
        if _storage._cloaked != rhs_storage._cloaked {return false}
        if _storage._blip != rhs_storage._blip {return false}
        if _storage._buffs != rhs_storage._buffs {return false}
        if _storage._buffDuration != rhs_storage._buffDuration {return false}
        if _storage._active != rhs_storage._active {return false}
        if _storage._buildProgress != rhs_storage._buildProgress {return false}
        if _storage._buildable != rhs_storage._buildable {return false}
        if _storage._pathable != rhs_storage._pathable {return false}
        if _storage._placeholder != rhs_storage._placeholder {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_FeatureLayersMinimap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeatureLayersMinimap"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "height_map"),
    2: .standard(proto: "visibility_map"),
    3: .same(proto: "creep"),
    4: .same(proto: "camera"),
    5: .standard(proto: "player_id"),
    6: .standard(proto: "player_relative"),
    7: .same(proto: "selected"),
    9: .same(proto: "alerts"),
    10: .same(proto: "buildable"),
    11: .same(proto: "pathable"),
    8: .standard(proto: "unit_type"),
  ]

  fileprivate class _StorageClass {
    var _heightMap: SC2APIProtocol_ImageData? = nil
    var _visibilityMap: SC2APIProtocol_ImageData? = nil
    var _creep: SC2APIProtocol_ImageData? = nil
    var _camera: SC2APIProtocol_ImageData? = nil
    var _playerID: SC2APIProtocol_ImageData? = nil
    var _playerRelative: SC2APIProtocol_ImageData? = nil
    var _selected: SC2APIProtocol_ImageData? = nil
    var _alerts: SC2APIProtocol_ImageData? = nil
    var _buildable: SC2APIProtocol_ImageData? = nil
    var _pathable: SC2APIProtocol_ImageData? = nil
    var _unitType: SC2APIProtocol_ImageData? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _heightMap = source._heightMap
      _visibilityMap = source._visibilityMap
      _creep = source._creep
      _camera = source._camera
      _playerID = source._playerID
      _playerRelative = source._playerRelative
      _selected = source._selected
      _alerts = source._alerts
      _buildable = source._buildable
      _pathable = source._pathable
      _unitType = source._unitType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._heightMap)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._visibilityMap)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._creep)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._camera)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._playerID)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._playerRelative)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._selected)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._unitType)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._alerts)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._buildable)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._pathable)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._heightMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._visibilityMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._creep {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._camera {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._playerID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._playerRelative {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._selected {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._unitType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._alerts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._buildable {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._pathable {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_FeatureLayersMinimap, rhs: SC2APIProtocol_FeatureLayersMinimap) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._heightMap != rhs_storage._heightMap {return false}
        if _storage._visibilityMap != rhs_storage._visibilityMap {return false}
        if _storage._creep != rhs_storage._creep {return false}
        if _storage._camera != rhs_storage._camera {return false}
        if _storage._playerID != rhs_storage._playerID {return false}
        if _storage._playerRelative != rhs_storage._playerRelative {return false}
        if _storage._selected != rhs_storage._selected {return false}
        if _storage._alerts != rhs_storage._alerts {return false}
        if _storage._buildable != rhs_storage._buildable {return false}
        if _storage._pathable != rhs_storage._pathable {return false}
        if _storage._unitType != rhs_storage._unitType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ObservationRender: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ObservationRender"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "map"),
    2: .same(proto: "minimap"),
  ]

  fileprivate class _StorageClass {
    var _map: SC2APIProtocol_ImageData? = nil
    var _minimap: SC2APIProtocol_ImageData? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _map = source._map
      _minimap = source._minimap
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._map)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._minimap)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._map {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._minimap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ObservationRender, rhs: SC2APIProtocol_ObservationRender) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._map != rhs_storage._map {return false}
        if _storage._minimap != rhs_storage._minimap {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ActionSpatial: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionSpatial"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "unit_command"),
    2: .standard(proto: "camera_move"),
    3: .standard(proto: "unit_selection_point"),
    4: .standard(proto: "unit_selection_rect"),
  ]

  fileprivate class _StorageClass {
    var _action: SC2APIProtocol_ActionSpatial.OneOf_Action?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _action = source._action
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: SC2APIProtocol_ActionSpatialUnitCommand?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .unitCommand(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .unitCommand(v)}
        case 2:
          var v: SC2APIProtocol_ActionSpatialCameraMove?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .cameraMove(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .cameraMove(v)}
        case 3:
          var v: SC2APIProtocol_ActionSpatialUnitSelectionPoint?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .unitSelectionPoint(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .unitSelectionPoint(v)}
        case 4:
          var v: SC2APIProtocol_ActionSpatialUnitSelectionRect?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .unitSelectionRect(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .unitSelectionRect(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._action {
      case .unitCommand(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .cameraMove(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .unitSelectionPoint(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .unitSelectionRect(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ActionSpatial, rhs: SC2APIProtocol_ActionSpatial) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._action != rhs_storage._action {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ActionSpatialUnitCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionSpatialUnitCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ability_id"),
    2: .standard(proto: "target_screen_coord"),
    3: .standard(proto: "target_minimap_coord"),
    4: .standard(proto: "queue_command"),
  ]

  fileprivate class _StorageClass {
    var _abilityID: Int32? = nil
    var _target: SC2APIProtocol_ActionSpatialUnitCommand.OneOf_Target?
    var _queueCommand: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _abilityID = source._abilityID
      _target = source._target
      _queueCommand = source._queueCommand
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt32Field(value: &_storage._abilityID)
        case 2:
          var v: SC2APIProtocol_PointI?
          if let current = _storage._target {
            try decoder.handleConflictingOneOf()
            if case .targetScreenCoord(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._target = .targetScreenCoord(v)}
        case 3:
          var v: SC2APIProtocol_PointI?
          if let current = _storage._target {
            try decoder.handleConflictingOneOf()
            if case .targetMinimapCoord(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._target = .targetMinimapCoord(v)}
        case 4: try decoder.decodeSingularBoolField(value: &_storage._queueCommand)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._abilityID {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
      }
      switch _storage._target {
      case .targetScreenCoord(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .targetMinimapCoord(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
      if let v = _storage._queueCommand {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ActionSpatialUnitCommand, rhs: SC2APIProtocol_ActionSpatialUnitCommand) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._abilityID != rhs_storage._abilityID {return false}
        if _storage._target != rhs_storage._target {return false}
        if _storage._queueCommand != rhs_storage._queueCommand {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ActionSpatialCameraMove: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionSpatialCameraMove"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "center_minimap"),
  ]

  fileprivate class _StorageClass {
    var _centerMinimap: SC2APIProtocol_PointI? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _centerMinimap = source._centerMinimap
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._centerMinimap)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._centerMinimap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ActionSpatialCameraMove, rhs: SC2APIProtocol_ActionSpatialCameraMove) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._centerMinimap != rhs_storage._centerMinimap {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ActionSpatialUnitSelectionPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionSpatialUnitSelectionPoint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "selection_screen_coord"),
    2: .same(proto: "type"),
  ]

  fileprivate class _StorageClass {
    var _selectionScreenCoord: SC2APIProtocol_PointI? = nil
    var _type: SC2APIProtocol_ActionSpatialUnitSelectionPoint.TypeEnum? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _selectionScreenCoord = source._selectionScreenCoord
      _type = source._type
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._selectionScreenCoord)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._type)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._selectionScreenCoord {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ActionSpatialUnitSelectionPoint, rhs: SC2APIProtocol_ActionSpatialUnitSelectionPoint) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._selectionScreenCoord != rhs_storage._selectionScreenCoord {return false}
        if _storage._type != rhs_storage._type {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ActionSpatialUnitSelectionPoint.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Select"),
    2: .same(proto: "Toggle"),
    3: .same(proto: "AllType"),
    4: .same(proto: "AddAllType"),
  ]
}

extension SC2APIProtocol_ActionSpatialUnitSelectionRect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionSpatialUnitSelectionRect"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "selection_screen_coord"),
    2: .standard(proto: "selection_add"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.selectionScreenCoord)
      case 2: try decoder.decodeSingularBoolField(value: &self._selectionAdd)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.selectionScreenCoord.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.selectionScreenCoord, fieldNumber: 1)
    }
    if let v = self._selectionAdd {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ActionSpatialUnitSelectionRect, rhs: SC2APIProtocol_ActionSpatialUnitSelectionRect) -> Bool {
    if lhs.selectionScreenCoord != rhs.selectionScreenCoord {return false}
    if lhs._selectionAdd != rhs._selectionAdd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
