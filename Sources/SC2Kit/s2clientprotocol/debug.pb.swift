// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: s2clientprotocol/debug.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum SC2APIProtocol_DebugGameState: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case showMap // = 1
  case controlEnemy // = 2
  case food // = 3
  case free // = 4
  case allResources // = 5
  case god // = 6
  case minerals // = 7
  case gas // = 8
  case cooldown // = 9
  case techTree // = 10
  case upgrade // = 11
  case fastBuild // = 12

  init() {
    self = .showMap
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .showMap
    case 2: self = .controlEnemy
    case 3: self = .food
    case 4: self = .free
    case 5: self = .allResources
    case 6: self = .god
    case 7: self = .minerals
    case 8: self = .gas
    case 9: self = .cooldown
    case 10: self = .techTree
    case 11: self = .upgrade
    case 12: self = .fastBuild
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .showMap: return 1
    case .controlEnemy: return 2
    case .food: return 3
    case .free: return 4
    case .allResources: return 5
    case .god: return 6
    case .minerals: return 7
    case .gas: return 8
    case .cooldown: return 9
    case .techTree: return 10
    case .upgrade: return 11
    case .fastBuild: return 12
    }
  }

}

#if swift(>=4.2)

extension SC2APIProtocol_DebugGameState: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Issue various useful commands to the game engine.
struct SC2APIProtocol_DebugCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var command: OneOf_Command? {
    get {return _storage._command}
    set {_uniqueStorage()._command = newValue}
  }

  var draw: SC2APIProtocol_DebugDraw {
    get {
      if case .draw(let v)? = _storage._command {return v}
      return SC2APIProtocol_DebugDraw()
    }
    set {_uniqueStorage()._command = .draw(newValue)}
  }

  var gameState: SC2APIProtocol_DebugGameState {
    get {
      if case .gameState(let v)? = _storage._command {return v}
      return .showMap
    }
    set {_uniqueStorage()._command = .gameState(newValue)}
  }

  var createUnit: SC2APIProtocol_DebugCreateUnit {
    get {
      if case .createUnit(let v)? = _storage._command {return v}
      return SC2APIProtocol_DebugCreateUnit()
    }
    set {_uniqueStorage()._command = .createUnit(newValue)}
  }

  var killUnit: SC2APIProtocol_DebugKillUnit {
    get {
      if case .killUnit(let v)? = _storage._command {return v}
      return SC2APIProtocol_DebugKillUnit()
    }
    set {_uniqueStorage()._command = .killUnit(newValue)}
  }

  var testProcess: SC2APIProtocol_DebugTestProcess {
    get {
      if case .testProcess(let v)? = _storage._command {return v}
      return SC2APIProtocol_DebugTestProcess()
    }
    set {_uniqueStorage()._command = .testProcess(newValue)}
  }

  /// Useful only for single-player "curriculum" maps.
  var score: SC2APIProtocol_DebugSetScore {
    get {
      if case .score(let v)? = _storage._command {return v}
      return SC2APIProtocol_DebugSetScore()
    }
    set {_uniqueStorage()._command = .score(newValue)}
  }

  var endGame: SC2APIProtocol_DebugEndGame {
    get {
      if case .endGame(let v)? = _storage._command {return v}
      return SC2APIProtocol_DebugEndGame()
    }
    set {_uniqueStorage()._command = .endGame(newValue)}
  }

  var unitValue: SC2APIProtocol_DebugSetUnitValue {
    get {
      if case .unitValue(let v)? = _storage._command {return v}
      return SC2APIProtocol_DebugSetUnitValue()
    }
    set {_uniqueStorage()._command = .unitValue(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Command: Equatable {
    case draw(SC2APIProtocol_DebugDraw)
    case gameState(SC2APIProtocol_DebugGameState)
    case createUnit(SC2APIProtocol_DebugCreateUnit)
    case killUnit(SC2APIProtocol_DebugKillUnit)
    case testProcess(SC2APIProtocol_DebugTestProcess)
    /// Useful only for single-player "curriculum" maps.
    case score(SC2APIProtocol_DebugSetScore)
    case endGame(SC2APIProtocol_DebugEndGame)
    case unitValue(SC2APIProtocol_DebugSetUnitValue)

  #if !swift(>=4.1)
    static func ==(lhs: SC2APIProtocol_DebugCommand.OneOf_Command, rhs: SC2APIProtocol_DebugCommand.OneOf_Command) -> Bool {
      switch (lhs, rhs) {
      case (.draw(let l), .draw(let r)): return l == r
      case (.gameState(let l), .gameState(let r)): return l == r
      case (.createUnit(let l), .createUnit(let r)): return l == r
      case (.killUnit(let l), .killUnit(let r)): return l == r
      case (.testProcess(let l), .testProcess(let r)): return l == r
      case (.score(let l), .score(let r)): return l == r
      case (.endGame(let l), .endGame(let r)): return l == r
      case (.unitValue(let l), .unitValue(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_DebugDraw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var text: [SC2APIProtocol_DebugText] = []

  var lines: [SC2APIProtocol_DebugLine] = []

  var boxes: [SC2APIProtocol_DebugBox] = []

  var spheres: [SC2APIProtocol_DebugSphere] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SC2APIProtocol_Line {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var p0: SC2APIProtocol_Point {
    get {return _storage._p0 ?? SC2APIProtocol_Point()}
    set {_uniqueStorage()._p0 = newValue}
  }
  /// Returns true if `p0` has been explicitly set.
  var hasP0: Bool {return _storage._p0 != nil}
  /// Clears the value of `p0`. Subsequent reads from it will return its default value.
  mutating func clearP0() {_uniqueStorage()._p0 = nil}

  var p1: SC2APIProtocol_Point {
    get {return _storage._p1 ?? SC2APIProtocol_Point()}
    set {_uniqueStorage()._p1 = newValue}
  }
  /// Returns true if `p1` has been explicitly set.
  var hasP1: Bool {return _storage._p1 != nil}
  /// Clears the value of `p1`. Subsequent reads from it will return its default value.
  mutating func clearP1() {_uniqueStorage()._p1 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_Color {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var r: UInt32 {
    get {return _r ?? 0}
    set {_r = newValue}
  }
  /// Returns true if `r` has been explicitly set.
  var hasR: Bool {return self._r != nil}
  /// Clears the value of `r`. Subsequent reads from it will return its default value.
  mutating func clearR() {self._r = nil}

  var g: UInt32 {
    get {return _g ?? 0}
    set {_g = newValue}
  }
  /// Returns true if `g` has been explicitly set.
  var hasG: Bool {return self._g != nil}
  /// Clears the value of `g`. Subsequent reads from it will return its default value.
  mutating func clearG() {self._g = nil}

  var b: UInt32 {
    get {return _b ?? 0}
    set {_b = newValue}
  }
  /// Returns true if `b` has been explicitly set.
  var hasB: Bool {return self._b != nil}
  /// Clears the value of `b`. Subsequent reads from it will return its default value.
  mutating func clearB() {self._b = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _r: UInt32? = nil
  fileprivate var _g: UInt32? = nil
  fileprivate var _b: UInt32? = nil
}

/// Display debug text on screen.
struct SC2APIProtocol_DebugText {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var color: SC2APIProtocol_Color {
    get {return _storage._color ?? SC2APIProtocol_Color()}
    set {_uniqueStorage()._color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return _storage._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {_uniqueStorage()._color = nil}

  /// Text to display.
  var text: String {
    get {return _storage._text ?? String()}
    set {_uniqueStorage()._text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  var hasText: Bool {return _storage._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  mutating func clearText() {_uniqueStorage()._text = nil}

  /// Virtualized position in 2D (the screen is 0..1, 0..1 for any resolution).
  var virtualPos: SC2APIProtocol_Point {
    get {return _storage._virtualPos ?? SC2APIProtocol_Point()}
    set {_uniqueStorage()._virtualPos = newValue}
  }
  /// Returns true if `virtualPos` has been explicitly set.
  var hasVirtualPos: Bool {return _storage._virtualPos != nil}
  /// Clears the value of `virtualPos`. Subsequent reads from it will return its default value.
  mutating func clearVirtualPos() {_uniqueStorage()._virtualPos = nil}

  /// Position in the world.
  var worldPos: SC2APIProtocol_Point {
    get {return _storage._worldPos ?? SC2APIProtocol_Point()}
    set {_uniqueStorage()._worldPos = newValue}
  }
  /// Returns true if `worldPos` has been explicitly set.
  var hasWorldPos: Bool {return _storage._worldPos != nil}
  /// Clears the value of `worldPos`. Subsequent reads from it will return its default value.
  mutating func clearWorldPos() {_uniqueStorage()._worldPos = nil}

  /// Pixel height of the text. Defaults to 8px.
  var size: UInt32 {
    get {return _storage._size ?? 0}
    set {_uniqueStorage()._size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {return _storage._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {_uniqueStorage()._size = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Display debug lines on screen.
struct SC2APIProtocol_DebugLine {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var color: SC2APIProtocol_Color {
    get {return _storage._color ?? SC2APIProtocol_Color()}
    set {_uniqueStorage()._color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return _storage._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {_uniqueStorage()._color = nil}

  /// World space line.
  var line: SC2APIProtocol_Line {
    get {return _storage._line ?? SC2APIProtocol_Line()}
    set {_uniqueStorage()._line = newValue}
  }
  /// Returns true if `line` has been explicitly set.
  var hasLine: Bool {return _storage._line != nil}
  /// Clears the value of `line`. Subsequent reads from it will return its default value.
  mutating func clearLine() {_uniqueStorage()._line = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Display debug boxes on screen.
struct SC2APIProtocol_DebugBox {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var color: SC2APIProtocol_Color {
    get {return _storage._color ?? SC2APIProtocol_Color()}
    set {_uniqueStorage()._color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return _storage._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {_uniqueStorage()._color = nil}

  var min: SC2APIProtocol_Point {
    get {return _storage._min ?? SC2APIProtocol_Point()}
    set {_uniqueStorage()._min = newValue}
  }
  /// Returns true if `min` has been explicitly set.
  var hasMin: Bool {return _storage._min != nil}
  /// Clears the value of `min`. Subsequent reads from it will return its default value.
  mutating func clearMin() {_uniqueStorage()._min = nil}

  var max: SC2APIProtocol_Point {
    get {return _storage._max ?? SC2APIProtocol_Point()}
    set {_uniqueStorage()._max = newValue}
  }
  /// Returns true if `max` has been explicitly set.
  var hasMax: Bool {return _storage._max != nil}
  /// Clears the value of `max`. Subsequent reads from it will return its default value.
  mutating func clearMax() {_uniqueStorage()._max = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Display debug spheres on screen.
struct SC2APIProtocol_DebugSphere {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var color: SC2APIProtocol_Color {
    get {return _storage._color ?? SC2APIProtocol_Color()}
    set {_uniqueStorage()._color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return _storage._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {_uniqueStorage()._color = nil}

  var p: SC2APIProtocol_Point {
    get {return _storage._p ?? SC2APIProtocol_Point()}
    set {_uniqueStorage()._p = newValue}
  }
  /// Returns true if `p` has been explicitly set.
  var hasP: Bool {return _storage._p != nil}
  /// Clears the value of `p`. Subsequent reads from it will return its default value.
  mutating func clearP() {_uniqueStorage()._p = nil}

  var r: Float {
    get {return _storage._r ?? 0}
    set {_uniqueStorage()._r = newValue}
  }
  /// Returns true if `r` has been explicitly set.
  var hasR: Bool {return _storage._r != nil}
  /// Clears the value of `r`. Subsequent reads from it will return its default value.
  mutating func clearR() {_uniqueStorage()._r = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_DebugCreateUnit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unitType: UInt32 {
    get {return _storage._unitType ?? 0}
    set {_uniqueStorage()._unitType = newValue}
  }
  /// Returns true if `unitType` has been explicitly set.
  var hasUnitType: Bool {return _storage._unitType != nil}
  /// Clears the value of `unitType`. Subsequent reads from it will return its default value.
  mutating func clearUnitType() {_uniqueStorage()._unitType = nil}

  var owner: Int32 {
    get {return _storage._owner ?? 0}
    set {_uniqueStorage()._owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  var hasOwner: Bool {return _storage._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  mutating func clearOwner() {_uniqueStorage()._owner = nil}

  var pos: SC2APIProtocol_Point2D {
    get {return _storage._pos ?? SC2APIProtocol_Point2D()}
    set {_uniqueStorage()._pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return _storage._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {_uniqueStorage()._pos = nil}

  var quantity: UInt32 {
    get {return _storage._quantity ?? 0}
    set {_uniqueStorage()._quantity = newValue}
  }
  /// Returns true if `quantity` has been explicitly set.
  var hasQuantity: Bool {return _storage._quantity != nil}
  /// Clears the value of `quantity`. Subsequent reads from it will return its default value.
  mutating func clearQuantity() {_uniqueStorage()._quantity = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_DebugKillUnit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tag: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SC2APIProtocol_DebugTestProcess {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var test: SC2APIProtocol_DebugTestProcess.Test {
    get {return _test ?? .hang}
    set {_test = newValue}
  }
  /// Returns true if `test` has been explicitly set.
  var hasTest: Bool {return self._test != nil}
  /// Clears the value of `test`. Subsequent reads from it will return its default value.
  mutating func clearTest() {self._test = nil}

  var delayMs: Int32 {
    get {return _delayMs ?? 0}
    set {_delayMs = newValue}
  }
  /// Returns true if `delayMs` has been explicitly set.
  var hasDelayMs: Bool {return self._delayMs != nil}
  /// Clears the value of `delayMs`. Subsequent reads from it will return its default value.
  mutating func clearDelayMs() {self._delayMs = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Test: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case hang // = 1
    case crash // = 2
    case exit // = 3

    init() {
      self = .hang
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .hang
      case 2: self = .crash
      case 3: self = .exit
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .hang: return 1
      case .crash: return 2
      case .exit: return 3
      }
    }

  }

  init() {}

  fileprivate var _test: SC2APIProtocol_DebugTestProcess.Test? = nil
  fileprivate var _delayMs: Int32? = nil
}

#if swift(>=4.2)

extension SC2APIProtocol_DebugTestProcess.Test: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct SC2APIProtocol_DebugSetScore {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var score: Float {
    get {return _score ?? 0}
    set {_score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  var hasScore: Bool {return self._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  mutating func clearScore() {self._score = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _score: Float? = nil
}

struct SC2APIProtocol_DebugEndGame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var endResult: SC2APIProtocol_DebugEndGame.EndResult {
    get {return _endResult ?? .surrender}
    set {_endResult = newValue}
  }
  /// Returns true if `endResult` has been explicitly set.
  var hasEndResult: Bool {return self._endResult != nil}
  /// Clears the value of `endResult`. Subsequent reads from it will return its default value.
  mutating func clearEndResult() {self._endResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum EndResult: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Default if nothing is set. The current player admits defeat.
    case surrender // = 1
    case declareVictory // = 2

    init() {
      self = .surrender
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .surrender
      case 2: self = .declareVictory
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .surrender: return 1
      case .declareVictory: return 2
      }
    }

  }

  init() {}

  fileprivate var _endResult: SC2APIProtocol_DebugEndGame.EndResult? = nil
}

#if swift(>=4.2)

extension SC2APIProtocol_DebugEndGame.EndResult: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct SC2APIProtocol_DebugSetUnitValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unitValue: SC2APIProtocol_DebugSetUnitValue.UnitValue {
    get {return _unitValue ?? .energy}
    set {_unitValue = newValue}
  }
  /// Returns true if `unitValue` has been explicitly set.
  var hasUnitValue: Bool {return self._unitValue != nil}
  /// Clears the value of `unitValue`. Subsequent reads from it will return its default value.
  mutating func clearUnitValue() {self._unitValue = nil}

  var value: Float {
    get {return _value ?? 0}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unitTag: UInt64 {
    get {return _unitTag ?? 0}
    set {_unitTag = newValue}
  }
  /// Returns true if `unitTag` has been explicitly set.
  var hasUnitTag: Bool {return self._unitTag != nil}
  /// Clears the value of `unitTag`. Subsequent reads from it will return its default value.
  mutating func clearUnitTag() {self._unitTag = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum UnitValue: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case energy // = 1
    case life // = 2
    case shields // = 3

    init() {
      self = .energy
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .energy
      case 2: self = .life
      case 3: self = .shields
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .energy: return 1
      case .life: return 2
      case .shields: return 3
      }
    }

  }

  init() {}

  fileprivate var _unitValue: SC2APIProtocol_DebugSetUnitValue.UnitValue? = nil
  fileprivate var _value: Float? = nil
  fileprivate var _unitTag: UInt64? = nil
}

#if swift(>=4.2)

extension SC2APIProtocol_DebugSetUnitValue.UnitValue: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "SC2APIProtocol"

extension SC2APIProtocol_DebugGameState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "show_map"),
    2: .same(proto: "control_enemy"),
    3: .same(proto: "food"),
    4: .same(proto: "free"),
    5: .same(proto: "all_resources"),
    6: .same(proto: "god"),
    7: .same(proto: "minerals"),
    8: .same(proto: "gas"),
    9: .same(proto: "cooldown"),
    10: .same(proto: "tech_tree"),
    11: .same(proto: "upgrade"),
    12: .same(proto: "fast_build"),
  ]
}

extension SC2APIProtocol_DebugCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DebugCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "draw"),
    2: .standard(proto: "game_state"),
    3: .standard(proto: "create_unit"),
    4: .standard(proto: "kill_unit"),
    5: .standard(proto: "test_process"),
    6: .same(proto: "score"),
    7: .standard(proto: "end_game"),
    8: .standard(proto: "unit_value"),
  ]

  fileprivate class _StorageClass {
    var _command: SC2APIProtocol_DebugCommand.OneOf_Command?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _command = source._command
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: SC2APIProtocol_DebugDraw?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .draw(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .draw(v)}
        case 2:
          if _storage._command != nil {try decoder.handleConflictingOneOf()}
          var v: SC2APIProtocol_DebugGameState?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {_storage._command = .gameState(v)}
        case 3:
          var v: SC2APIProtocol_DebugCreateUnit?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .createUnit(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .createUnit(v)}
        case 4:
          var v: SC2APIProtocol_DebugKillUnit?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .killUnit(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .killUnit(v)}
        case 5:
          var v: SC2APIProtocol_DebugTestProcess?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .testProcess(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .testProcess(v)}
        case 6:
          var v: SC2APIProtocol_DebugSetScore?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .score(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .score(v)}
        case 7:
          var v: SC2APIProtocol_DebugEndGame?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .endGame(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .endGame(v)}
        case 8:
          var v: SC2APIProtocol_DebugSetUnitValue?
          if let current = _storage._command {
            try decoder.handleConflictingOneOf()
            if case .unitValue(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._command = .unitValue(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._command {
      case .draw(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .gameState(let v)?:
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      case .createUnit(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .killUnit(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .testProcess(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .score(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .endGame(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .unitValue(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_DebugCommand, rhs: SC2APIProtocol_DebugCommand) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._command != rhs_storage._command {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_DebugDraw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DebugDraw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "lines"),
    3: .same(proto: "boxes"),
    4: .same(proto: "spheres"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.text)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.lines)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.boxes)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.spheres)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.text, fieldNumber: 1)
    }
    if !self.lines.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lines, fieldNumber: 2)
    }
    if !self.boxes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.boxes, fieldNumber: 3)
    }
    if !self.spheres.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.spheres, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_DebugDraw, rhs: SC2APIProtocol_DebugDraw) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.lines != rhs.lines {return false}
    if lhs.boxes != rhs.boxes {return false}
    if lhs.spheres != rhs.spheres {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_Line: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Line"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "p0"),
    2: .same(proto: "p1"),
  ]

  fileprivate class _StorageClass {
    var _p0: SC2APIProtocol_Point? = nil
    var _p1: SC2APIProtocol_Point? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _p0 = source._p0
      _p1 = source._p1
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._p0)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._p1)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._p0 {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._p1 {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_Line, rhs: SC2APIProtocol_Line) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._p0 != rhs_storage._p0 {return false}
        if _storage._p1 != rhs_storage._p1 {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_Color: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Color"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "r"),
    2: .same(proto: "g"),
    3: .same(proto: "b"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self._r)
      case 2: try decoder.decodeSingularUInt32Field(value: &self._g)
      case 3: try decoder.decodeSingularUInt32Field(value: &self._b)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._r {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._g {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._b {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_Color, rhs: SC2APIProtocol_Color) -> Bool {
    if lhs._r != rhs._r {return false}
    if lhs._g != rhs._g {return false}
    if lhs._b != rhs._b {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_DebugText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DebugText"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "color"),
    2: .same(proto: "text"),
    3: .standard(proto: "virtual_pos"),
    4: .standard(proto: "world_pos"),
    5: .same(proto: "size"),
  ]

  fileprivate class _StorageClass {
    var _color: SC2APIProtocol_Color? = nil
    var _text: String? = nil
    var _virtualPos: SC2APIProtocol_Point? = nil
    var _worldPos: SC2APIProtocol_Point? = nil
    var _size: UInt32? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _color = source._color
      _text = source._text
      _virtualPos = source._virtualPos
      _worldPos = source._worldPos
      _size = source._size
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._color)
        case 2: try decoder.decodeSingularStringField(value: &_storage._text)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._virtualPos)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._worldPos)
        case 5: try decoder.decodeSingularUInt32Field(value: &_storage._size)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._color {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._text {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._virtualPos {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._worldPos {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._size {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_DebugText, rhs: SC2APIProtocol_DebugText) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._color != rhs_storage._color {return false}
        if _storage._text != rhs_storage._text {return false}
        if _storage._virtualPos != rhs_storage._virtualPos {return false}
        if _storage._worldPos != rhs_storage._worldPos {return false}
        if _storage._size != rhs_storage._size {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_DebugLine: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DebugLine"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "color"),
    2: .same(proto: "line"),
  ]

  fileprivate class _StorageClass {
    var _color: SC2APIProtocol_Color? = nil
    var _line: SC2APIProtocol_Line? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _color = source._color
      _line = source._line
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._color)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._line)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._color {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._line {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_DebugLine, rhs: SC2APIProtocol_DebugLine) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._color != rhs_storage._color {return false}
        if _storage._line != rhs_storage._line {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_DebugBox: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DebugBox"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "color"),
    2: .same(proto: "min"),
    3: .same(proto: "max"),
  ]

  fileprivate class _StorageClass {
    var _color: SC2APIProtocol_Color? = nil
    var _min: SC2APIProtocol_Point? = nil
    var _max: SC2APIProtocol_Point? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _color = source._color
      _min = source._min
      _max = source._max
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._color)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._min)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._max)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._color {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._min {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._max {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_DebugBox, rhs: SC2APIProtocol_DebugBox) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._color != rhs_storage._color {return false}
        if _storage._min != rhs_storage._min {return false}
        if _storage._max != rhs_storage._max {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_DebugSphere: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DebugSphere"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "color"),
    2: .same(proto: "p"),
    3: .same(proto: "r"),
  ]

  fileprivate class _StorageClass {
    var _color: SC2APIProtocol_Color? = nil
    var _p: SC2APIProtocol_Point? = nil
    var _r: Float? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _color = source._color
      _p = source._p
      _r = source._r
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._color)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._p)
        case 3: try decoder.decodeSingularFloatField(value: &_storage._r)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._color {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._p {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._r {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_DebugSphere, rhs: SC2APIProtocol_DebugSphere) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._color != rhs_storage._color {return false}
        if _storage._p != rhs_storage._p {return false}
        if _storage._r != rhs_storage._r {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_DebugCreateUnit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DebugCreateUnit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "unit_type"),
    2: .same(proto: "owner"),
    3: .same(proto: "pos"),
    4: .same(proto: "quantity"),
  ]

  fileprivate class _StorageClass {
    var _unitType: UInt32? = nil
    var _owner: Int32? = nil
    var _pos: SC2APIProtocol_Point2D? = nil
    var _quantity: UInt32? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _unitType = source._unitType
      _owner = source._owner
      _pos = source._pos
      _quantity = source._quantity
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._unitType)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._owner)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._pos)
        case 4: try decoder.decodeSingularUInt32Field(value: &_storage._quantity)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._unitType {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
      }
      if let v = _storage._owner {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
      }
      if let v = _storage._pos {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._quantity {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_DebugCreateUnit, rhs: SC2APIProtocol_DebugCreateUnit) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._unitType != rhs_storage._unitType {return false}
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._pos != rhs_storage._pos {return false}
        if _storage._quantity != rhs_storage._quantity {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_DebugKillUnit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DebugKillUnit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tag"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedUInt64Field(value: &self.tag)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tag.isEmpty {
      try visitor.visitRepeatedUInt64Field(value: self.tag, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_DebugKillUnit, rhs: SC2APIProtocol_DebugKillUnit) -> Bool {
    if lhs.tag != rhs.tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_DebugTestProcess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DebugTestProcess"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "test"),
    2: .standard(proto: "delay_ms"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._test)
      case 2: try decoder.decodeSingularInt32Field(value: &self._delayMs)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._test {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._delayMs {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_DebugTestProcess, rhs: SC2APIProtocol_DebugTestProcess) -> Bool {
    if lhs._test != rhs._test {return false}
    if lhs._delayMs != rhs._delayMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_DebugTestProcess.Test: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hang"),
    2: .same(proto: "crash"),
    3: .same(proto: "exit"),
  ]
}

extension SC2APIProtocol_DebugSetScore: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DebugSetScore"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self._score)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._score {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_DebugSetScore, rhs: SC2APIProtocol_DebugSetScore) -> Bool {
    if lhs._score != rhs._score {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_DebugEndGame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DebugEndGame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "end_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._endResult)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._endResult {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_DebugEndGame, rhs: SC2APIProtocol_DebugEndGame) -> Bool {
    if lhs._endResult != rhs._endResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_DebugEndGame.EndResult: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Surrender"),
    2: .same(proto: "DeclareVictory"),
  ]
}

extension SC2APIProtocol_DebugSetUnitValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DebugSetUnitValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "unit_value"),
    2: .same(proto: "value"),
    3: .standard(proto: "unit_tag"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._unitValue)
      case 2: try decoder.decodeSingularFloatField(value: &self._value)
      case 3: try decoder.decodeSingularUInt64Field(value: &self._unitTag)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._unitValue {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._value {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    }
    if let v = self._unitTag {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_DebugSetUnitValue, rhs: SC2APIProtocol_DebugSetUnitValue) -> Bool {
    if lhs._unitValue != rhs._unitValue {return false}
    if lhs._value != rhs._value {return false}
    if lhs._unitTag != rhs._unitTag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_DebugSetUnitValue.UnitValue: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Energy"),
    2: .same(proto: "Life"),
    3: .same(proto: "Shields"),
  ]
}
