// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: s2clientprotocol/data.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum SC2APIProtocol_Attribute: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case light // = 1
  case armored // = 2
  case biological // = 3
  case mechanical // = 4
  case robotic // = 5
  case psionic // = 6
  case massive // = 7
  case structure // = 8
  case hover // = 9
  case heroic // = 10
  case summoned // = 11

  init() {
    self = .light
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .light
    case 2: self = .armored
    case 3: self = .biological
    case 4: self = .mechanical
    case 5: self = .robotic
    case 6: self = .psionic
    case 7: self = .massive
    case 8: self = .structure
    case 9: self = .hover
    case 10: self = .heroic
    case 11: self = .summoned
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .light: return 1
    case .armored: return 2
    case .biological: return 3
    case .mechanical: return 4
    case .robotic: return 5
    case .psionic: return 6
    case .massive: return 7
    case .structure: return 8
    case .hover: return 9
    case .heroic: return 10
    case .summoned: return 11
    }
  }

}

#if swift(>=4.2)

extension SC2APIProtocol_Attribute: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// May not relevant: queueable (everything is queueable).
/// May not be important: AbilSetId - marine stim, marauder stim.
/// Stuff omitted: transient.
/// Stuff that may be important: cost, range, Alignment, targetfilters.
struct SC2APIProtocol_AbilityData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Stable ID.
  var abilityID: UInt32 {
    get {return _abilityID ?? 0}
    set {_abilityID = newValue}
  }
  /// Returns true if `abilityID` has been explicitly set.
  var hasAbilityID: Bool {return self._abilityID != nil}
  /// Clears the value of `abilityID`. Subsequent reads from it will return its default value.
  mutating func clearAbilityID() {self._abilityID = nil}

  /// Catalog name of the ability.
  var linkName: String {
    get {return _linkName ?? String()}
    set {_linkName = newValue}
  }
  /// Returns true if `linkName` has been explicitly set.
  var hasLinkName: Bool {return self._linkName != nil}
  /// Clears the value of `linkName`. Subsequent reads from it will return its default value.
  mutating func clearLinkName() {self._linkName = nil}

  /// Catalog index of the ability.
  var linkIndex: UInt32 {
    get {return _linkIndex ?? 0}
    set {_linkIndex = newValue}
  }
  /// Returns true if `linkIndex` has been explicitly set.
  var hasLinkIndex: Bool {return self._linkIndex != nil}
  /// Clears the value of `linkIndex`. Subsequent reads from it will return its default value.
  mutating func clearLinkIndex() {self._linkIndex = nil}

  /// Name used for the command card. May not always be set.
  var buttonName: String {
    get {return _buttonName ?? String()}
    set {_buttonName = newValue}
  }
  /// Returns true if `buttonName` has been explicitly set.
  var hasButtonName: Bool {return self._buttonName != nil}
  /// Clears the value of `buttonName`. Subsequent reads from it will return its default value.
  mutating func clearButtonName() {self._buttonName = nil}

  /// A human friendly name when the button name or link name isn't descriptive.
  var friendlyName: String {
    get {return _friendlyName ?? String()}
    set {_friendlyName = newValue}
  }
  /// Returns true if `friendlyName` has been explicitly set.
  var hasFriendlyName: Bool {return self._friendlyName != nil}
  /// Clears the value of `friendlyName`. Subsequent reads from it will return its default value.
  mutating func clearFriendlyName() {self._friendlyName = nil}

  /// Hotkey. May not always be set.
  var hotkey: String {
    get {return _hotkey ?? String()}
    set {_hotkey = newValue}
  }
  /// Returns true if `hotkey` has been explicitly set.
  var hasHotkey: Bool {return self._hotkey != nil}
  /// Clears the value of `hotkey`. Subsequent reads from it will return its default value.
  mutating func clearHotkey() {self._hotkey = nil}

  /// This ability id may be represented by the given more generic id.
  var remapsToAbilityID: UInt32 {
    get {return _remapsToAbilityID ?? 0}
    set {_remapsToAbilityID = newValue}
  }
  /// Returns true if `remapsToAbilityID` has been explicitly set.
  var hasRemapsToAbilityID: Bool {return self._remapsToAbilityID != nil}
  /// Clears the value of `remapsToAbilityID`. Subsequent reads from it will return its default value.
  mutating func clearRemapsToAbilityID() {self._remapsToAbilityID = nil}

  /// If true, the ability may be used by this set of mods/map.
  var available: Bool {
    get {return _available ?? false}
    set {_available = newValue}
  }
  /// Returns true if `available` has been explicitly set.
  var hasAvailable: Bool {return self._available != nil}
  /// Clears the value of `available`. Subsequent reads from it will return its default value.
  mutating func clearAvailable() {self._available = nil}

  /// Determines if a point is optional or required.
  var target: SC2APIProtocol_AbilityData.Target {
    get {return _target ?? .none}
    set {_target = newValue}
  }
  /// Returns true if `target` has been explicitly set.
  var hasTarget: Bool {return self._target != nil}
  /// Clears the value of `target`. Subsequent reads from it will return its default value.
  mutating func clearTarget() {self._target = nil}

  /// Can be cast in the minimap.
  var allowMinimap: Bool {
    get {return _allowMinimap ?? false}
    set {_allowMinimap = newValue}
  }
  /// Returns true if `allowMinimap` has been explicitly set.
  var hasAllowMinimap: Bool {return self._allowMinimap != nil}
  /// Clears the value of `allowMinimap`. Subsequent reads from it will return its default value.
  mutating func clearAllowMinimap() {self._allowMinimap = nil}

  /// Autocast can be set.
  var allowAutocast: Bool {
    get {return _allowAutocast ?? false}
    set {_allowAutocast = newValue}
  }
  /// Returns true if `allowAutocast` has been explicitly set.
  var hasAllowAutocast: Bool {return self._allowAutocast != nil}
  /// Clears the value of `allowAutocast`. Subsequent reads from it will return its default value.
  mutating func clearAllowAutocast() {self._allowAutocast = nil}

  /// Requires placement to construct a building.
  var isBuilding: Bool {
    get {return _isBuilding ?? false}
    set {_isBuilding = newValue}
  }
  /// Returns true if `isBuilding` has been explicitly set.
  var hasIsBuilding: Bool {return self._isBuilding != nil}
  /// Clears the value of `isBuilding`. Subsequent reads from it will return its default value.
  mutating func clearIsBuilding() {self._isBuilding = nil}

  /// Estimation of the footprint size. Need a better footprint.
  var footprintRadius: Float {
    get {return _footprintRadius ?? 0}
    set {_footprintRadius = newValue}
  }
  /// Returns true if `footprintRadius` has been explicitly set.
  var hasFootprintRadius: Bool {return self._footprintRadius != nil}
  /// Clears the value of `footprintRadius`. Subsequent reads from it will return its default value.
  mutating func clearFootprintRadius() {self._footprintRadius = nil}

  /// Placement next to an existing structure, e.g., an add-on like a Tech Lab.
  var isInstantPlacement: Bool {
    get {return _isInstantPlacement ?? false}
    set {_isInstantPlacement = newValue}
  }
  /// Returns true if `isInstantPlacement` has been explicitly set.
  var hasIsInstantPlacement: Bool {return self._isInstantPlacement != nil}
  /// Clears the value of `isInstantPlacement`. Subsequent reads from it will return its default value.
  mutating func clearIsInstantPlacement() {self._isInstantPlacement = nil}

  /// Range unit can cast ability without needing to approach target.
  var castRange: Float {
    get {return _castRange ?? 0}
    set {_castRange = newValue}
  }
  /// Returns true if `castRange` has been explicitly set.
  var hasCastRange: Bool {return self._castRange != nil}
  /// Clears the value of `castRange`. Subsequent reads from it will return its default value.
  mutating func clearCastRange() {self._castRange = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Target: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Does not require a target.
    case none // = 1

    /// Requires a target position.
    case point // = 2

    /// Requires a unit to target. Given by position using feature layers.
    case unit // = 3

    /// Requires either a target point or target unit.
    case pointOrUnit // = 4

    /// Requires either a target point or no target. (eg. building add-ons)
    case pointOrNone // = 5

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .none
      case 2: self = .point
      case 3: self = .unit
      case 4: self = .pointOrUnit
      case 5: self = .pointOrNone
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 1
      case .point: return 2
      case .unit: return 3
      case .pointOrUnit: return 4
      case .pointOrNone: return 5
      }
    }

  }

  init() {}

  fileprivate var _abilityID: UInt32? = nil
  fileprivate var _linkName: String? = nil
  fileprivate var _linkIndex: UInt32? = nil
  fileprivate var _buttonName: String? = nil
  fileprivate var _friendlyName: String? = nil
  fileprivate var _hotkey: String? = nil
  fileprivate var _remapsToAbilityID: UInt32? = nil
  fileprivate var _available: Bool? = nil
  fileprivate var _target: SC2APIProtocol_AbilityData.Target? = nil
  fileprivate var _allowMinimap: Bool? = nil
  fileprivate var _allowAutocast: Bool? = nil
  fileprivate var _isBuilding: Bool? = nil
  fileprivate var _footprintRadius: Float? = nil
  fileprivate var _isInstantPlacement: Bool? = nil
  fileprivate var _castRange: Float? = nil
}

#if swift(>=4.2)

extension SC2APIProtocol_AbilityData.Target: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct SC2APIProtocol_DamageBonus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var attribute: SC2APIProtocol_Attribute {
    get {return _attribute ?? .light}
    set {_attribute = newValue}
  }
  /// Returns true if `attribute` has been explicitly set.
  var hasAttribute: Bool {return self._attribute != nil}
  /// Clears the value of `attribute`. Subsequent reads from it will return its default value.
  mutating func clearAttribute() {self._attribute = nil}

  var bonus: Float {
    get {return _bonus ?? 0}
    set {_bonus = newValue}
  }
  /// Returns true if `bonus` has been explicitly set.
  var hasBonus: Bool {return self._bonus != nil}
  /// Clears the value of `bonus`. Subsequent reads from it will return its default value.
  mutating func clearBonus() {self._bonus = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _attribute: SC2APIProtocol_Attribute? = nil
  fileprivate var _bonus: Float? = nil
}

struct SC2APIProtocol_Weapon {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: SC2APIProtocol_Weapon.TargetType {
    get {return _type ?? .ground}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var damage: Float {
    get {return _damage ?? 0}
    set {_damage = newValue}
  }
  /// Returns true if `damage` has been explicitly set.
  var hasDamage: Bool {return self._damage != nil}
  /// Clears the value of `damage`. Subsequent reads from it will return its default value.
  mutating func clearDamage() {self._damage = nil}

  var damageBonus: [SC2APIProtocol_DamageBonus] = []

  /// Number of hits per attack. (eg. Colossus has 2 beams)
  var attacks: UInt32 {
    get {return _attacks ?? 0}
    set {_attacks = newValue}
  }
  /// Returns true if `attacks` has been explicitly set.
  var hasAttacks: Bool {return self._attacks != nil}
  /// Clears the value of `attacks`. Subsequent reads from it will return its default value.
  mutating func clearAttacks() {self._attacks = nil}

  var range: Float {
    get {return _range ?? 0}
    set {_range = newValue}
  }
  /// Returns true if `range` has been explicitly set.
  var hasRange: Bool {return self._range != nil}
  /// Clears the value of `range`. Subsequent reads from it will return its default value.
  mutating func clearRange() {self._range = nil}

  /// Time between attacks.
  var speed: Float {
    get {return _speed ?? 0}
    set {_speed = newValue}
  }
  /// Returns true if `speed` has been explicitly set.
  var hasSpeed: Bool {return self._speed != nil}
  /// Clears the value of `speed`. Subsequent reads from it will return its default value.
  mutating func clearSpeed() {self._speed = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TargetType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ground // = 1
    case air // = 2
    case any // = 3

    init() {
      self = .ground
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .ground
      case 2: self = .air
      case 3: self = .any
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ground: return 1
      case .air: return 2
      case .any: return 3
      }
    }

  }

  init() {}

  fileprivate var _type: SC2APIProtocol_Weapon.TargetType? = nil
  fileprivate var _damage: Float? = nil
  fileprivate var _attacks: UInt32? = nil
  fileprivate var _range: Float? = nil
  fileprivate var _speed: Float? = nil
}

#if swift(>=4.2)

extension SC2APIProtocol_Weapon.TargetType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct SC2APIProtocol_UnitTypeData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Stable ID.
  var unitID: UInt32 {
    get {return _storage._unitID ?? 0}
    set {_uniqueStorage()._unitID = newValue}
  }
  /// Returns true if `unitID` has been explicitly set.
  var hasUnitID: Bool {return _storage._unitID != nil}
  /// Clears the value of `unitID`. Subsequent reads from it will return its default value.
  mutating func clearUnitID() {_uniqueStorage()._unitID = nil}

  /// Catalog name of the unit.
  var name: String {
    get {return _storage._name ?? String()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {_uniqueStorage()._name = nil}

  /// If true, the ability may be used by this set of mods/map.
  var available: Bool {
    get {return _storage._available ?? false}
    set {_uniqueStorage()._available = newValue}
  }
  /// Returns true if `available` has been explicitly set.
  var hasAvailable: Bool {return _storage._available != nil}
  /// Clears the value of `available`. Subsequent reads from it will return its default value.
  mutating func clearAvailable() {_uniqueStorage()._available = nil}

  /// Number of cargo slots it occupies in transports.
  var cargoSize: UInt32 {
    get {return _storage._cargoSize ?? 0}
    set {_uniqueStorage()._cargoSize = newValue}
  }
  /// Returns true if `cargoSize` has been explicitly set.
  var hasCargoSize: Bool {return _storage._cargoSize != nil}
  /// Clears the value of `cargoSize`. Subsequent reads from it will return its default value.
  mutating func clearCargoSize() {_uniqueStorage()._cargoSize = nil}

  var mineralCost: UInt32 {
    get {return _storage._mineralCost ?? 0}
    set {_uniqueStorage()._mineralCost = newValue}
  }
  /// Returns true if `mineralCost` has been explicitly set.
  var hasMineralCost: Bool {return _storage._mineralCost != nil}
  /// Clears the value of `mineralCost`. Subsequent reads from it will return its default value.
  mutating func clearMineralCost() {_uniqueStorage()._mineralCost = nil}

  var vespeneCost: UInt32 {
    get {return _storage._vespeneCost ?? 0}
    set {_uniqueStorage()._vespeneCost = newValue}
  }
  /// Returns true if `vespeneCost` has been explicitly set.
  var hasVespeneCost: Bool {return _storage._vespeneCost != nil}
  /// Clears the value of `vespeneCost`. Subsequent reads from it will return its default value.
  mutating func clearVespeneCost() {_uniqueStorage()._vespeneCost = nil}

  var foodRequired: Float {
    get {return _storage._foodRequired ?? 0}
    set {_uniqueStorage()._foodRequired = newValue}
  }
  /// Returns true if `foodRequired` has been explicitly set.
  var hasFoodRequired: Bool {return _storage._foodRequired != nil}
  /// Clears the value of `foodRequired`. Subsequent reads from it will return its default value.
  mutating func clearFoodRequired() {_uniqueStorage()._foodRequired = nil}

  var foodProvided: Float {
    get {return _storage._foodProvided ?? 0}
    set {_uniqueStorage()._foodProvided = newValue}
  }
  /// Returns true if `foodProvided` has been explicitly set.
  var hasFoodProvided: Bool {return _storage._foodProvided != nil}
  /// Clears the value of `foodProvided`. Subsequent reads from it will return its default value.
  mutating func clearFoodProvided() {_uniqueStorage()._foodProvided = nil}

  /// The ability that builds this unit.
  var abilityID: UInt32 {
    get {return _storage._abilityID ?? 0}
    set {_uniqueStorage()._abilityID = newValue}
  }
  /// Returns true if `abilityID` has been explicitly set.
  var hasAbilityID: Bool {return _storage._abilityID != nil}
  /// Clears the value of `abilityID`. Subsequent reads from it will return its default value.
  mutating func clearAbilityID() {_uniqueStorage()._abilityID = nil}

  var race: SC2APIProtocol_Race {
    get {return _storage._race ?? .noRace}
    set {_uniqueStorage()._race = newValue}
  }
  /// Returns true if `race` has been explicitly set.
  var hasRace: Bool {return _storage._race != nil}
  /// Clears the value of `race`. Subsequent reads from it will return its default value.
  mutating func clearRace() {_uniqueStorage()._race = nil}

  var buildTime: Float {
    get {return _storage._buildTime ?? 0}
    set {_uniqueStorage()._buildTime = newValue}
  }
  /// Returns true if `buildTime` has been explicitly set.
  var hasBuildTime: Bool {return _storage._buildTime != nil}
  /// Clears the value of `buildTime`. Subsequent reads from it will return its default value.
  mutating func clearBuildTime() {_uniqueStorage()._buildTime = nil}

  var hasVespene_p: Bool {
    get {return _storage._hasVespene_p ?? false}
    set {_uniqueStorage()._hasVespene_p = newValue}
  }
  /// Returns true if `hasVespene_p` has been explicitly set.
  var hasHasVespene_p: Bool {return _storage._hasVespene_p != nil}
  /// Clears the value of `hasVespene_p`. Subsequent reads from it will return its default value.
  mutating func clearHasVespene_p() {_uniqueStorage()._hasVespene_p = nil}

  var hasMinerals_p: Bool {
    get {return _storage._hasMinerals_p ?? false}
    set {_uniqueStorage()._hasMinerals_p = newValue}
  }
  /// Returns true if `hasMinerals_p` has been explicitly set.
  var hasHasMinerals_p: Bool {return _storage._hasMinerals_p != nil}
  /// Clears the value of `hasMinerals_p`. Subsequent reads from it will return its default value.
  mutating func clearHasMinerals_p() {_uniqueStorage()._hasMinerals_p = nil}

  /// Range unit reveals vision.
  var sightRange: Float {
    get {return _storage._sightRange ?? 0}
    set {_uniqueStorage()._sightRange = newValue}
  }
  /// Returns true if `sightRange` has been explicitly set.
  var hasSightRange: Bool {return _storage._sightRange != nil}
  /// Clears the value of `sightRange`. Subsequent reads from it will return its default value.
  mutating func clearSightRange() {_uniqueStorage()._sightRange = nil}

  /// Other units that satisfy the same tech requirement.
  var techAlias: [UInt32] {
    get {return _storage._techAlias}
    set {_uniqueStorage()._techAlias = newValue}
  }

  /// The morphed variant of this unit.
  var unitAlias: UInt32 {
    get {return _storage._unitAlias ?? 0}
    set {_uniqueStorage()._unitAlias = newValue}
  }
  /// Returns true if `unitAlias` has been explicitly set.
  var hasUnitAlias: Bool {return _storage._unitAlias != nil}
  /// Clears the value of `unitAlias`. Subsequent reads from it will return its default value.
  mutating func clearUnitAlias() {_uniqueStorage()._unitAlias = nil}

  /// Structure required to build this unit. (Or any with the same tech_alias)
  var techRequirement: UInt32 {
    get {return _storage._techRequirement ?? 0}
    set {_uniqueStorage()._techRequirement = newValue}
  }
  /// Returns true if `techRequirement` has been explicitly set.
  var hasTechRequirement: Bool {return _storage._techRequirement != nil}
  /// Clears the value of `techRequirement`. Subsequent reads from it will return its default value.
  mutating func clearTechRequirement() {_uniqueStorage()._techRequirement = nil}

  /// Whether tech_requirement is an add-on.
  var requireAttached: Bool {
    get {return _storage._requireAttached ?? false}
    set {_uniqueStorage()._requireAttached = newValue}
  }
  /// Returns true if `requireAttached` has been explicitly set.
  var hasRequireAttached: Bool {return _storage._requireAttached != nil}
  /// Clears the value of `requireAttached`. Subsequent reads from it will return its default value.
  mutating func clearRequireAttached() {_uniqueStorage()._requireAttached = nil}

  /// Values include changes from upgrades
  var attributes: [SC2APIProtocol_Attribute] {
    get {return _storage._attributes}
    set {_uniqueStorage()._attributes = newValue}
  }

  var movementSpeed: Float {
    get {return _storage._movementSpeed ?? 0}
    set {_uniqueStorage()._movementSpeed = newValue}
  }
  /// Returns true if `movementSpeed` has been explicitly set.
  var hasMovementSpeed: Bool {return _storage._movementSpeed != nil}
  /// Clears the value of `movementSpeed`. Subsequent reads from it will return its default value.
  mutating func clearMovementSpeed() {_uniqueStorage()._movementSpeed = nil}

  var armor: Float {
    get {return _storage._armor ?? 0}
    set {_uniqueStorage()._armor = newValue}
  }
  /// Returns true if `armor` has been explicitly set.
  var hasArmor: Bool {return _storage._armor != nil}
  /// Clears the value of `armor`. Subsequent reads from it will return its default value.
  mutating func clearArmor() {_uniqueStorage()._armor = nil}

  var weapons: [SC2APIProtocol_Weapon] {
    get {return _storage._weapons}
    set {_uniqueStorage()._weapons = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_UpgradeData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Stable ID.
  var upgradeID: UInt32 {
    get {return _upgradeID ?? 0}
    set {_upgradeID = newValue}
  }
  /// Returns true if `upgradeID` has been explicitly set.
  var hasUpgradeID: Bool {return self._upgradeID != nil}
  /// Clears the value of `upgradeID`. Subsequent reads from it will return its default value.
  mutating func clearUpgradeID() {self._upgradeID = nil}

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var mineralCost: UInt32 {
    get {return _mineralCost ?? 0}
    set {_mineralCost = newValue}
  }
  /// Returns true if `mineralCost` has been explicitly set.
  var hasMineralCost: Bool {return self._mineralCost != nil}
  /// Clears the value of `mineralCost`. Subsequent reads from it will return its default value.
  mutating func clearMineralCost() {self._mineralCost = nil}

  var vespeneCost: UInt32 {
    get {return _vespeneCost ?? 0}
    set {_vespeneCost = newValue}
  }
  /// Returns true if `vespeneCost` has been explicitly set.
  var hasVespeneCost: Bool {return self._vespeneCost != nil}
  /// Clears the value of `vespeneCost`. Subsequent reads from it will return its default value.
  mutating func clearVespeneCost() {self._vespeneCost = nil}

  var researchTime: Float {
    get {return _researchTime ?? 0}
    set {_researchTime = newValue}
  }
  /// Returns true if `researchTime` has been explicitly set.
  var hasResearchTime: Bool {return self._researchTime != nil}
  /// Clears the value of `researchTime`. Subsequent reads from it will return its default value.
  mutating func clearResearchTime() {self._researchTime = nil}

  var abilityID: UInt32 {
    get {return _abilityID ?? 0}
    set {_abilityID = newValue}
  }
  /// Returns true if `abilityID` has been explicitly set.
  var hasAbilityID: Bool {return self._abilityID != nil}
  /// Clears the value of `abilityID`. Subsequent reads from it will return its default value.
  mutating func clearAbilityID() {self._abilityID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _upgradeID: UInt32? = nil
  fileprivate var _name: String? = nil
  fileprivate var _mineralCost: UInt32? = nil
  fileprivate var _vespeneCost: UInt32? = nil
  fileprivate var _researchTime: Float? = nil
  fileprivate var _abilityID: UInt32? = nil
}

struct SC2APIProtocol_BuffData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Stable ID.
  var buffID: UInt32 {
    get {return _buffID ?? 0}
    set {_buffID = newValue}
  }
  /// Returns true if `buffID` has been explicitly set.
  var hasBuffID: Bool {return self._buffID != nil}
  /// Clears the value of `buffID`. Subsequent reads from it will return its default value.
  mutating func clearBuffID() {self._buffID = nil}

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _buffID: UInt32? = nil
  fileprivate var _name: String? = nil
}

struct SC2APIProtocol_EffectData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Stable ID.
  var effectID: UInt32 {
    get {return _effectID ?? 0}
    set {_effectID = newValue}
  }
  /// Returns true if `effectID` has been explicitly set.
  var hasEffectID: Bool {return self._effectID != nil}
  /// Clears the value of `effectID`. Subsequent reads from it will return its default value.
  mutating func clearEffectID() {self._effectID = nil}

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var friendlyName: String {
    get {return _friendlyName ?? String()}
    set {_friendlyName = newValue}
  }
  /// Returns true if `friendlyName` has been explicitly set.
  var hasFriendlyName: Bool {return self._friendlyName != nil}
  /// Clears the value of `friendlyName`. Subsequent reads from it will return its default value.
  mutating func clearFriendlyName() {self._friendlyName = nil}

  var radius: Float {
    get {return _radius ?? 0}
    set {_radius = newValue}
  }
  /// Returns true if `radius` has been explicitly set.
  var hasRadius: Bool {return self._radius != nil}
  /// Clears the value of `radius`. Subsequent reads from it will return its default value.
  mutating func clearRadius() {self._radius = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _effectID: UInt32? = nil
  fileprivate var _name: String? = nil
  fileprivate var _friendlyName: String? = nil
  fileprivate var _radius: Float? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "SC2APIProtocol"

extension SC2APIProtocol_Attribute: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Light"),
    2: .same(proto: "Armored"),
    3: .same(proto: "Biological"),
    4: .same(proto: "Mechanical"),
    5: .same(proto: "Robotic"),
    6: .same(proto: "Psionic"),
    7: .same(proto: "Massive"),
    8: .same(proto: "Structure"),
    9: .same(proto: "Hover"),
    10: .same(proto: "Heroic"),
    11: .same(proto: "Summoned"),
  ]
}

extension SC2APIProtocol_AbilityData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AbilityData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ability_id"),
    2: .standard(proto: "link_name"),
    3: .standard(proto: "link_index"),
    4: .standard(proto: "button_name"),
    5: .standard(proto: "friendly_name"),
    6: .same(proto: "hotkey"),
    7: .standard(proto: "remaps_to_ability_id"),
    8: .same(proto: "available"),
    9: .same(proto: "target"),
    10: .standard(proto: "allow_minimap"),
    11: .standard(proto: "allow_autocast"),
    12: .standard(proto: "is_building"),
    13: .standard(proto: "footprint_radius"),
    14: .standard(proto: "is_instant_placement"),
    15: .standard(proto: "cast_range"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self._abilityID)
      case 2: try decoder.decodeSingularStringField(value: &self._linkName)
      case 3: try decoder.decodeSingularUInt32Field(value: &self._linkIndex)
      case 4: try decoder.decodeSingularStringField(value: &self._buttonName)
      case 5: try decoder.decodeSingularStringField(value: &self._friendlyName)
      case 6: try decoder.decodeSingularStringField(value: &self._hotkey)
      case 7: try decoder.decodeSingularUInt32Field(value: &self._remapsToAbilityID)
      case 8: try decoder.decodeSingularBoolField(value: &self._available)
      case 9: try decoder.decodeSingularEnumField(value: &self._target)
      case 10: try decoder.decodeSingularBoolField(value: &self._allowMinimap)
      case 11: try decoder.decodeSingularBoolField(value: &self._allowAutocast)
      case 12: try decoder.decodeSingularBoolField(value: &self._isBuilding)
      case 13: try decoder.decodeSingularFloatField(value: &self._footprintRadius)
      case 14: try decoder.decodeSingularBoolField(value: &self._isInstantPlacement)
      case 15: try decoder.decodeSingularFloatField(value: &self._castRange)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._abilityID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._linkName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._linkIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._buttonName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._friendlyName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if let v = self._hotkey {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    if let v = self._remapsToAbilityID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._available {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    }
    if let v = self._target {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 9)
    }
    if let v = self._allowMinimap {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
    }
    if let v = self._allowAutocast {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
    }
    if let v = self._isBuilding {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
    }
    if let v = self._footprintRadius {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 13)
    }
    if let v = self._isInstantPlacement {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
    }
    if let v = self._castRange {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_AbilityData, rhs: SC2APIProtocol_AbilityData) -> Bool {
    if lhs._abilityID != rhs._abilityID {return false}
    if lhs._linkName != rhs._linkName {return false}
    if lhs._linkIndex != rhs._linkIndex {return false}
    if lhs._buttonName != rhs._buttonName {return false}
    if lhs._friendlyName != rhs._friendlyName {return false}
    if lhs._hotkey != rhs._hotkey {return false}
    if lhs._remapsToAbilityID != rhs._remapsToAbilityID {return false}
    if lhs._available != rhs._available {return false}
    if lhs._target != rhs._target {return false}
    if lhs._allowMinimap != rhs._allowMinimap {return false}
    if lhs._allowAutocast != rhs._allowAutocast {return false}
    if lhs._isBuilding != rhs._isBuilding {return false}
    if lhs._footprintRadius != rhs._footprintRadius {return false}
    if lhs._isInstantPlacement != rhs._isInstantPlacement {return false}
    if lhs._castRange != rhs._castRange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_AbilityData.Target: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "None"),
    2: .same(proto: "Point"),
    3: .same(proto: "Unit"),
    4: .same(proto: "PointOrUnit"),
    5: .same(proto: "PointOrNone"),
  ]
}

extension SC2APIProtocol_DamageBonus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DamageBonus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "attribute"),
    2: .same(proto: "bonus"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._attribute)
      case 2: try decoder.decodeSingularFloatField(value: &self._bonus)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._attribute {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._bonus {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_DamageBonus, rhs: SC2APIProtocol_DamageBonus) -> Bool {
    if lhs._attribute != rhs._attribute {return false}
    if lhs._bonus != rhs._bonus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_Weapon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Weapon"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "damage"),
    3: .standard(proto: "damage_bonus"),
    4: .same(proto: "attacks"),
    5: .same(proto: "range"),
    6: .same(proto: "speed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._type)
      case 2: try decoder.decodeSingularFloatField(value: &self._damage)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.damageBonus)
      case 4: try decoder.decodeSingularUInt32Field(value: &self._attacks)
      case 5: try decoder.decodeSingularFloatField(value: &self._range)
      case 6: try decoder.decodeSingularFloatField(value: &self._speed)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._damage {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    }
    if !self.damageBonus.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.damageBonus, fieldNumber: 3)
    }
    if let v = self._attacks {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._range {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    }
    if let v = self._speed {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_Weapon, rhs: SC2APIProtocol_Weapon) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._damage != rhs._damage {return false}
    if lhs.damageBonus != rhs.damageBonus {return false}
    if lhs._attacks != rhs._attacks {return false}
    if lhs._range != rhs._range {return false}
    if lhs._speed != rhs._speed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_Weapon.TargetType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Ground"),
    2: .same(proto: "Air"),
    3: .same(proto: "Any"),
  ]
}

extension SC2APIProtocol_UnitTypeData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnitTypeData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "unit_id"),
    2: .same(proto: "name"),
    3: .same(proto: "available"),
    4: .standard(proto: "cargo_size"),
    12: .standard(proto: "mineral_cost"),
    13: .standard(proto: "vespene_cost"),
    14: .standard(proto: "food_required"),
    18: .standard(proto: "food_provided"),
    15: .standard(proto: "ability_id"),
    16: .same(proto: "race"),
    17: .standard(proto: "build_time"),
    19: .standard(proto: "has_vespene"),
    20: .standard(proto: "has_minerals"),
    25: .standard(proto: "sight_range"),
    21: .standard(proto: "tech_alias"),
    22: .standard(proto: "unit_alias"),
    23: .standard(proto: "tech_requirement"),
    24: .standard(proto: "require_attached"),
    8: .same(proto: "attributes"),
    9: .standard(proto: "movement_speed"),
    10: .same(proto: "armor"),
    11: .same(proto: "weapons"),
  ]

  fileprivate class _StorageClass {
    var _unitID: UInt32? = nil
    var _name: String? = nil
    var _available: Bool? = nil
    var _cargoSize: UInt32? = nil
    var _mineralCost: UInt32? = nil
    var _vespeneCost: UInt32? = nil
    var _foodRequired: Float? = nil
    var _foodProvided: Float? = nil
    var _abilityID: UInt32? = nil
    var _race: SC2APIProtocol_Race? = nil
    var _buildTime: Float? = nil
    var _hasVespene_p: Bool? = nil
    var _hasMinerals_p: Bool? = nil
    var _sightRange: Float? = nil
    var _techAlias: [UInt32] = []
    var _unitAlias: UInt32? = nil
    var _techRequirement: UInt32? = nil
    var _requireAttached: Bool? = nil
    var _attributes: [SC2APIProtocol_Attribute] = []
    var _movementSpeed: Float? = nil
    var _armor: Float? = nil
    var _weapons: [SC2APIProtocol_Weapon] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _unitID = source._unitID
      _name = source._name
      _available = source._available
      _cargoSize = source._cargoSize
      _mineralCost = source._mineralCost
      _vespeneCost = source._vespeneCost
      _foodRequired = source._foodRequired
      _foodProvided = source._foodProvided
      _abilityID = source._abilityID
      _race = source._race
      _buildTime = source._buildTime
      _hasVespene_p = source._hasVespene_p
      _hasMinerals_p = source._hasMinerals_p
      _sightRange = source._sightRange
      _techAlias = source._techAlias
      _unitAlias = source._unitAlias
      _techRequirement = source._techRequirement
      _requireAttached = source._requireAttached
      _attributes = source._attributes
      _movementSpeed = source._movementSpeed
      _armor = source._armor
      _weapons = source._weapons
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._unitID)
        case 2: try decoder.decodeSingularStringField(value: &_storage._name)
        case 3: try decoder.decodeSingularBoolField(value: &_storage._available)
        case 4: try decoder.decodeSingularUInt32Field(value: &_storage._cargoSize)
        case 8: try decoder.decodeRepeatedEnumField(value: &_storage._attributes)
        case 9: try decoder.decodeSingularFloatField(value: &_storage._movementSpeed)
        case 10: try decoder.decodeSingularFloatField(value: &_storage._armor)
        case 11: try decoder.decodeRepeatedMessageField(value: &_storage._weapons)
        case 12: try decoder.decodeSingularUInt32Field(value: &_storage._mineralCost)
        case 13: try decoder.decodeSingularUInt32Field(value: &_storage._vespeneCost)
        case 14: try decoder.decodeSingularFloatField(value: &_storage._foodRequired)
        case 15: try decoder.decodeSingularUInt32Field(value: &_storage._abilityID)
        case 16: try decoder.decodeSingularEnumField(value: &_storage._race)
        case 17: try decoder.decodeSingularFloatField(value: &_storage._buildTime)
        case 18: try decoder.decodeSingularFloatField(value: &_storage._foodProvided)
        case 19: try decoder.decodeSingularBoolField(value: &_storage._hasVespene_p)
        case 20: try decoder.decodeSingularBoolField(value: &_storage._hasMinerals_p)
        case 21: try decoder.decodeRepeatedUInt32Field(value: &_storage._techAlias)
        case 22: try decoder.decodeSingularUInt32Field(value: &_storage._unitAlias)
        case 23: try decoder.decodeSingularUInt32Field(value: &_storage._techRequirement)
        case 24: try decoder.decodeSingularBoolField(value: &_storage._requireAttached)
        case 25: try decoder.decodeSingularFloatField(value: &_storage._sightRange)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._unitID {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
      }
      if let v = _storage._name {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._available {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      }
      if let v = _storage._cargoSize {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      }
      if !_storage._attributes.isEmpty {
        try visitor.visitRepeatedEnumField(value: _storage._attributes, fieldNumber: 8)
      }
      if let v = _storage._movementSpeed {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 9)
      }
      if let v = _storage._armor {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 10)
      }
      if !_storage._weapons.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._weapons, fieldNumber: 11)
      }
      if let v = _storage._mineralCost {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 12)
      }
      if let v = _storage._vespeneCost {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 13)
      }
      if let v = _storage._foodRequired {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 14)
      }
      if let v = _storage._abilityID {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 15)
      }
      if let v = _storage._race {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 16)
      }
      if let v = _storage._buildTime {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 17)
      }
      if let v = _storage._foodProvided {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 18)
      }
      if let v = _storage._hasVespene_p {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 19)
      }
      if let v = _storage._hasMinerals_p {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 20)
      }
      if !_storage._techAlias.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._techAlias, fieldNumber: 21)
      }
      if let v = _storage._unitAlias {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 22)
      }
      if let v = _storage._techRequirement {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 23)
      }
      if let v = _storage._requireAttached {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 24)
      }
      if let v = _storage._sightRange {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 25)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_UnitTypeData, rhs: SC2APIProtocol_UnitTypeData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._unitID != rhs_storage._unitID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._available != rhs_storage._available {return false}
        if _storage._cargoSize != rhs_storage._cargoSize {return false}
        if _storage._mineralCost != rhs_storage._mineralCost {return false}
        if _storage._vespeneCost != rhs_storage._vespeneCost {return false}
        if _storage._foodRequired != rhs_storage._foodRequired {return false}
        if _storage._foodProvided != rhs_storage._foodProvided {return false}
        if _storage._abilityID != rhs_storage._abilityID {return false}
        if _storage._race != rhs_storage._race {return false}
        if _storage._buildTime != rhs_storage._buildTime {return false}
        if _storage._hasVespene_p != rhs_storage._hasVespene_p {return false}
        if _storage._hasMinerals_p != rhs_storage._hasMinerals_p {return false}
        if _storage._sightRange != rhs_storage._sightRange {return false}
        if _storage._techAlias != rhs_storage._techAlias {return false}
        if _storage._unitAlias != rhs_storage._unitAlias {return false}
        if _storage._techRequirement != rhs_storage._techRequirement {return false}
        if _storage._requireAttached != rhs_storage._requireAttached {return false}
        if _storage._attributes != rhs_storage._attributes {return false}
        if _storage._movementSpeed != rhs_storage._movementSpeed {return false}
        if _storage._armor != rhs_storage._armor {return false}
        if _storage._weapons != rhs_storage._weapons {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_UpgradeData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpgradeData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "upgrade_id"),
    2: .same(proto: "name"),
    3: .standard(proto: "mineral_cost"),
    4: .standard(proto: "vespene_cost"),
    5: .standard(proto: "research_time"),
    6: .standard(proto: "ability_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self._upgradeID)
      case 2: try decoder.decodeSingularStringField(value: &self._name)
      case 3: try decoder.decodeSingularUInt32Field(value: &self._mineralCost)
      case 4: try decoder.decodeSingularUInt32Field(value: &self._vespeneCost)
      case 5: try decoder.decodeSingularFloatField(value: &self._researchTime)
      case 6: try decoder.decodeSingularUInt32Field(value: &self._abilityID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._upgradeID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._mineralCost {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._vespeneCost {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._researchTime {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    }
    if let v = self._abilityID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_UpgradeData, rhs: SC2APIProtocol_UpgradeData) -> Bool {
    if lhs._upgradeID != rhs._upgradeID {return false}
    if lhs._name != rhs._name {return false}
    if lhs._mineralCost != rhs._mineralCost {return false}
    if lhs._vespeneCost != rhs._vespeneCost {return false}
    if lhs._researchTime != rhs._researchTime {return false}
    if lhs._abilityID != rhs._abilityID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_BuffData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BuffData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "buff_id"),
    2: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self._buffID)
      case 2: try decoder.decodeSingularStringField(value: &self._name)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._buffID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_BuffData, rhs: SC2APIProtocol_BuffData) -> Bool {
    if lhs._buffID != rhs._buffID {return false}
    if lhs._name != rhs._name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_EffectData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EffectData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "effect_id"),
    2: .same(proto: "name"),
    3: .standard(proto: "friendly_name"),
    4: .same(proto: "radius"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self._effectID)
      case 2: try decoder.decodeSingularStringField(value: &self._name)
      case 3: try decoder.decodeSingularStringField(value: &self._friendlyName)
      case 4: try decoder.decodeSingularFloatField(value: &self._radius)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._effectID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._friendlyName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._radius {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_EffectData, rhs: SC2APIProtocol_EffectData) -> Bool {
    if lhs._effectID != rhs._effectID {return false}
    if lhs._name != rhs._name {return false}
    if lhs._friendlyName != rhs._friendlyName {return false}
    if lhs._radius != rhs._radius {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
