// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: s2clientprotocol/sc2api.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum SC2APIProtocol_Status: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Game has been launch and is not yet doing anything.
  case launched // = 1

  /// Create game has been called, and the host is awaiting players.
  case initGame // = 2

  /// In a single or multiplayer game.
  case inGame // = 3

  /// In a replay.
  case inReplay // = 4

  /// Game has ended, can still request game info, but ready for a new game.
  case ended // = 5

  /// Application is shutting down.
  case quit // = 6

  /// Should not happen, but indicates an error if it occurs.
  case unknown // = 99

  init() {
    self = .launched
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .launched
    case 2: self = .initGame
    case 3: self = .inGame
    case 4: self = .inReplay
    case 5: self = .ended
    case 6: self = .quit
    case 99: self = .unknown
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .launched: return 1
    case .initGame: return 2
    case .inGame: return 3
    case .inReplay: return 4
    case .ended: return 5
    case .quit: return 6
    case .unknown: return 99
    }
  }

}

#if swift(>=4.2)

extension SC2APIProtocol_Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum SC2APIProtocol_Difficulty: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case veryEasy // = 1
  case easy // = 2
  case medium // = 3
  case mediumHard // = 4
  case hard // = 5
  case harder // = 6
  case veryHard // = 7
  case cheatVision // = 8
  case cheatMoney // = 9
  case cheatInsane // = 10

  init() {
    self = .veryEasy
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .veryEasy
    case 2: self = .easy
    case 3: self = .medium
    case 4: self = .mediumHard
    case 5: self = .hard
    case 6: self = .harder
    case 7: self = .veryHard
    case 8: self = .cheatVision
    case 9: self = .cheatMoney
    case 10: self = .cheatInsane
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .veryEasy: return 1
    case .easy: return 2
    case .medium: return 3
    case .mediumHard: return 4
    case .hard: return 5
    case .harder: return 6
    case .veryHard: return 7
    case .cheatVision: return 8
    case .cheatMoney: return 9
    case .cheatInsane: return 10
    }
  }

}

#if swift(>=4.2)

extension SC2APIProtocol_Difficulty: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum SC2APIProtocol_PlayerType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case participant // = 1
  case computer // = 2
  case observer // = 3

  init() {
    self = .participant
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .participant
    case 2: self = .computer
    case 3: self = .observer
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .participant: return 1
    case .computer: return 2
    case .observer: return 3
    }
  }

}

#if swift(>=4.2)

extension SC2APIProtocol_PlayerType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum SC2APIProtocol_AIBuild: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case randomBuild // = 1
  case rush // = 2
  case timing // = 3
  case power // = 4
  case macro // = 5
  case air // = 6

  init() {
    self = .randomBuild
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .randomBuild
    case 2: self = .rush
    case 3: self = .timing
    case 4: self = .power
    case 5: self = .macro
    case 6: self = .air
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .randomBuild: return 1
    case .rush: return 2
    case .timing: return 3
    case .power: return 4
    case .macro: return 5
    case .air: return 6
    }
  }

}

#if swift(>=4.2)

extension SC2APIProtocol_AIBuild: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum SC2APIProtocol_Alert: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case error // = 3
  case addOnComplete // = 4
  case buildingComplete // = 5
  case buildingUnderAttack // = 6
  case larvaHatched // = 7
  case mergeComplete // = 8
  case mineralsExhausted // = 9
  case morphComplete // = 10
  case mothershipComplete // = 11
  case muleexpired // = 12
  case nuclearLaunchDetected // = 1
  case nukeComplete // = 13
  case nydusWormDetected // = 2
  case researchComplete // = 14
  case trainError // = 15
  case trainUnitComplete // = 16
  case trainWorkerComplete // = 17
  case transformationComplete // = 18
  case unitUnderAttack // = 19
  case upgradeComplete // = 20
  case vespeneExhausted // = 21
  case warpInComplete // = 22

  init() {
    self = .error
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .nuclearLaunchDetected
    case 2: self = .nydusWormDetected
    case 3: self = .error
    case 4: self = .addOnComplete
    case 5: self = .buildingComplete
    case 6: self = .buildingUnderAttack
    case 7: self = .larvaHatched
    case 8: self = .mergeComplete
    case 9: self = .mineralsExhausted
    case 10: self = .morphComplete
    case 11: self = .mothershipComplete
    case 12: self = .muleexpired
    case 13: self = .nukeComplete
    case 14: self = .researchComplete
    case 15: self = .trainError
    case 16: self = .trainUnitComplete
    case 17: self = .trainWorkerComplete
    case 18: self = .transformationComplete
    case 19: self = .unitUnderAttack
    case 20: self = .upgradeComplete
    case 21: self = .vespeneExhausted
    case 22: self = .warpInComplete
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .nuclearLaunchDetected: return 1
    case .nydusWormDetected: return 2
    case .error: return 3
    case .addOnComplete: return 4
    case .buildingComplete: return 5
    case .buildingUnderAttack: return 6
    case .larvaHatched: return 7
    case .mergeComplete: return 8
    case .mineralsExhausted: return 9
    case .morphComplete: return 10
    case .mothershipComplete: return 11
    case .muleexpired: return 12
    case .nukeComplete: return 13
    case .researchComplete: return 14
    case .trainError: return 15
    case .trainUnitComplete: return 16
    case .trainWorkerComplete: return 17
    case .transformationComplete: return 18
    case .unitUnderAttack: return 19
    case .upgradeComplete: return 20
    case .vespeneExhausted: return 21
    case .warpInComplete: return 22
    }
  }

}

#if swift(>=4.2)

extension SC2APIProtocol_Alert: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum SC2APIProtocol_Result: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case victory // = 1
  case defeat // = 2
  case tie // = 3
  case undecided // = 4

  init() {
    self = .victory
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .victory
    case 2: self = .defeat
    case 3: self = .tie
    case 4: self = .undecided
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .victory: return 1
    case .defeat: return 2
    case .tie: return 3
    case .undecided: return 4
    }
  }

}

#if swift(>=4.2)

extension SC2APIProtocol_Result: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct SC2APIProtocol_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var request: OneOf_Request? {
    get {return _storage._request}
    set {_uniqueStorage()._request = newValue}
  }

  /// Game Setup
  var createGame: SC2APIProtocol_RequestCreateGame {
    get {
      if case .createGame(let v)? = _storage._request {return v}
      return SC2APIProtocol_RequestCreateGame()
    }
    set {_uniqueStorage()._request = .createGame(newValue)}
  }

  /// Send to host and all clients for game to begin.
  var joinGame: SC2APIProtocol_RequestJoinGame {
    get {
      if case .joinGame(let v)? = _storage._request {return v}
      return SC2APIProtocol_RequestJoinGame()
    }
    set {_uniqueStorage()._request = .joinGame(newValue)}
  }

  /// Single player only. Reinitializes the game with the same player setup.
  var restartGame: SC2APIProtocol_RequestRestartGame {
    get {
      if case .restartGame(let v)? = _storage._request {return v}
      return SC2APIProtocol_RequestRestartGame()
    }
    set {_uniqueStorage()._request = .restartGame(newValue)}
  }

  /// Start playing a replay.
  var startReplay: SC2APIProtocol_RequestStartReplay {
    get {
      if case .startReplay(let v)? = _storage._request {return v}
      return SC2APIProtocol_RequestStartReplay()
    }
    set {_uniqueStorage()._request = .startReplay(newValue)}
  }

  /// Multiplayer only. Disconnects from a multiplayer game, equivalent to surrender.
  var leaveGame: SC2APIProtocol_RequestLeaveGame {
    get {
      if case .leaveGame(let v)? = _storage._request {return v}
      return SC2APIProtocol_RequestLeaveGame()
    }
    set {_uniqueStorage()._request = .leaveGame(newValue)}
  }

  /// Saves game to an in-memory bookmark.
  var quickSave: SC2APIProtocol_RequestQuickSave {
    get {
      if case .quickSave(let v)? = _storage._request {return v}
      return SC2APIProtocol_RequestQuickSave()
    }
    set {_uniqueStorage()._request = .quickSave(newValue)}
  }

  /// Loads from an in-memory bookmark.
  var quickLoad: SC2APIProtocol_RequestQuickLoad {
    get {
      if case .quickLoad(let v)? = _storage._request {return v}
      return SC2APIProtocol_RequestQuickLoad()
    }
    set {_uniqueStorage()._request = .quickLoad(newValue)}
  }

  /// Terminates the application.
  var quit: SC2APIProtocol_RequestQuit {
    get {
      if case .quit(let v)? = _storage._request {return v}
      return SC2APIProtocol_RequestQuit()
    }
    set {_uniqueStorage()._request = .quit(newValue)}
  }

  /// During Game
  var gameInfo: SC2APIProtocol_RequestGameInfo {
    get {
      if case .gameInfo(let v)? = _storage._request {return v}
      return SC2APIProtocol_RequestGameInfo()
    }
    set {_uniqueStorage()._request = .gameInfo(newValue)}
  }

  /// Snapshot of the current game state.
  var observation: SC2APIProtocol_RequestObservation {
    get {
      if case .observation(let v)? = _storage._request {return v}
      return SC2APIProtocol_RequestObservation()
    }
    set {_uniqueStorage()._request = .observation(newValue)}
  }

  /// Executes an action for a participant.
  var action: SC2APIProtocol_RequestAction {
    get {
      if case .action(let v)? = _storage._request {return v}
      return SC2APIProtocol_RequestAction()
    }
    set {_uniqueStorage()._request = .action(newValue)}
  }

  /// Executes an action for an observer.
  var obsAction: SC2APIProtocol_RequestObserverAction {
    get {
      if case .obsAction(let v)? = _storage._request {return v}
      return SC2APIProtocol_RequestObserverAction()
    }
    set {_uniqueStorage()._request = .obsAction(newValue)}
  }

  /// Advances the game simulation.
  var step: SC2APIProtocol_RequestStep {
    get {
      if case .step(let v)? = _storage._request {return v}
      return SC2APIProtocol_RequestStep()
    }
    set {_uniqueStorage()._request = .step(newValue)}
  }

  /// Data about different gameplay elements. May be different for different games.
  var data: SC2APIProtocol_RequestData {
    get {
      if case .data(let v)? = _storage._request {return v}
      return SC2APIProtocol_RequestData()
    }
    set {_uniqueStorage()._request = .data(newValue)}
  }

  /// Additional methods for inspecting game state.
  var query: SC2APIProtocol_RequestQuery {
    get {
      if case .query(let v)? = _storage._request {return v}
      return SC2APIProtocol_RequestQuery()
    }
    set {_uniqueStorage()._request = .query(newValue)}
  }

  /// Generates a replay.
  var saveReplay: SC2APIProtocol_RequestSaveReplay {
    get {
      if case .saveReplay(let v)? = _storage._request {return v}
      return SC2APIProtocol_RequestSaveReplay()
    }
    set {_uniqueStorage()._request = .saveReplay(newValue)}
  }

  /// Execute a particular trigger through a string interface
  var mapCommand: SC2APIProtocol_RequestMapCommand {
    get {
      if case .mapCommand(let v)? = _storage._request {return v}
      return SC2APIProtocol_RequestMapCommand()
    }
    set {_uniqueStorage()._request = .mapCommand(newValue)}
  }

  /// Other.
  var replayInfo: SC2APIProtocol_RequestReplayInfo {
    get {
      if case .replayInfo(let v)? = _storage._request {return v}
      return SC2APIProtocol_RequestReplayInfo()
    }
    set {_uniqueStorage()._request = .replayInfo(newValue)}
  }

  /// Returns directory of maps that can be played on.
  var availableMaps: SC2APIProtocol_RequestAvailableMaps {
    get {
      if case .availableMaps(let v)? = _storage._request {return v}
      return SC2APIProtocol_RequestAvailableMaps()
    }
    set {_uniqueStorage()._request = .availableMaps(newValue)}
  }

  /// Saves binary map data to the local temp directory.
  var saveMap: SC2APIProtocol_RequestSaveMap {
    get {
      if case .saveMap(let v)? = _storage._request {return v}
      return SC2APIProtocol_RequestSaveMap()
    }
    set {_uniqueStorage()._request = .saveMap(newValue)}
  }

  /// Debugging
  var ping: SC2APIProtocol_RequestPing {
    get {
      if case .ping(let v)? = _storage._request {return v}
      return SC2APIProtocol_RequestPing()
    }
    set {_uniqueStorage()._request = .ping(newValue)}
  }

  /// Display debug information and execute debug actions.
  var debug: SC2APIProtocol_RequestDebug {
    get {
      if case .debug(let v)? = _storage._request {return v}
      return SC2APIProtocol_RequestDebug()
    }
    set {_uniqueStorage()._request = .debug(newValue)}
  }

  var id: UInt32 {
    get {return _storage._id ?? 0}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {_uniqueStorage()._id = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable {
    /// Game Setup
    case createGame(SC2APIProtocol_RequestCreateGame)
    /// Send to host and all clients for game to begin.
    case joinGame(SC2APIProtocol_RequestJoinGame)
    /// Single player only. Reinitializes the game with the same player setup.
    case restartGame(SC2APIProtocol_RequestRestartGame)
    /// Start playing a replay.
    case startReplay(SC2APIProtocol_RequestStartReplay)
    /// Multiplayer only. Disconnects from a multiplayer game, equivalent to surrender.
    case leaveGame(SC2APIProtocol_RequestLeaveGame)
    /// Saves game to an in-memory bookmark.
    case quickSave(SC2APIProtocol_RequestQuickSave)
    /// Loads from an in-memory bookmark.
    case quickLoad(SC2APIProtocol_RequestQuickLoad)
    /// Terminates the application.
    case quit(SC2APIProtocol_RequestQuit)
    /// During Game
    case gameInfo(SC2APIProtocol_RequestGameInfo)
    /// Snapshot of the current game state.
    case observation(SC2APIProtocol_RequestObservation)
    /// Executes an action for a participant.
    case action(SC2APIProtocol_RequestAction)
    /// Executes an action for an observer.
    case obsAction(SC2APIProtocol_RequestObserverAction)
    /// Advances the game simulation.
    case step(SC2APIProtocol_RequestStep)
    /// Data about different gameplay elements. May be different for different games.
    case data(SC2APIProtocol_RequestData)
    /// Additional methods for inspecting game state.
    case query(SC2APIProtocol_RequestQuery)
    /// Generates a replay.
    case saveReplay(SC2APIProtocol_RequestSaveReplay)
    /// Execute a particular trigger through a string interface
    case mapCommand(SC2APIProtocol_RequestMapCommand)
    /// Other.
    case replayInfo(SC2APIProtocol_RequestReplayInfo)
    /// Returns directory of maps that can be played on.
    case availableMaps(SC2APIProtocol_RequestAvailableMaps)
    /// Saves binary map data to the local temp directory.
    case saveMap(SC2APIProtocol_RequestSaveMap)
    /// Debugging
    case ping(SC2APIProtocol_RequestPing)
    /// Display debug information and execute debug actions.
    case debug(SC2APIProtocol_RequestDebug)

  #if !swift(>=4.1)
    static func ==(lhs: SC2APIProtocol_Request.OneOf_Request, rhs: SC2APIProtocol_Request.OneOf_Request) -> Bool {
      switch (lhs, rhs) {
      case (.createGame(let l), .createGame(let r)): return l == r
      case (.joinGame(let l), .joinGame(let r)): return l == r
      case (.restartGame(let l), .restartGame(let r)): return l == r
      case (.startReplay(let l), .startReplay(let r)): return l == r
      case (.leaveGame(let l), .leaveGame(let r)): return l == r
      case (.quickSave(let l), .quickSave(let r)): return l == r
      case (.quickLoad(let l), .quickLoad(let r)): return l == r
      case (.quit(let l), .quit(let r)): return l == r
      case (.gameInfo(let l), .gameInfo(let r)): return l == r
      case (.observation(let l), .observation(let r)): return l == r
      case (.action(let l), .action(let r)): return l == r
      case (.obsAction(let l), .obsAction(let r)): return l == r
      case (.step(let l), .step(let r)): return l == r
      case (.data(let l), .data(let r)): return l == r
      case (.query(let l), .query(let r)): return l == r
      case (.saveReplay(let l), .saveReplay(let r)): return l == r
      case (.mapCommand(let l), .mapCommand(let r)): return l == r
      case (.replayInfo(let l), .replayInfo(let r)): return l == r
      case (.availableMaps(let l), .availableMaps(let r)): return l == r
      case (.saveMap(let l), .saveMap(let r)): return l == r
      case (.ping(let l), .ping(let r)): return l == r
      case (.debug(let l), .debug(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: OneOf_Response? {
    get {return _storage._response}
    set {_uniqueStorage()._response = newValue}
  }

  var createGame: SC2APIProtocol_ResponseCreateGame {
    get {
      if case .createGame(let v)? = _storage._response {return v}
      return SC2APIProtocol_ResponseCreateGame()
    }
    set {_uniqueStorage()._response = .createGame(newValue)}
  }

  var joinGame: SC2APIProtocol_ResponseJoinGame {
    get {
      if case .joinGame(let v)? = _storage._response {return v}
      return SC2APIProtocol_ResponseJoinGame()
    }
    set {_uniqueStorage()._response = .joinGame(newValue)}
  }

  var restartGame: SC2APIProtocol_ResponseRestartGame {
    get {
      if case .restartGame(let v)? = _storage._response {return v}
      return SC2APIProtocol_ResponseRestartGame()
    }
    set {_uniqueStorage()._response = .restartGame(newValue)}
  }

  var startReplay: SC2APIProtocol_ResponseStartReplay {
    get {
      if case .startReplay(let v)? = _storage._response {return v}
      return SC2APIProtocol_ResponseStartReplay()
    }
    set {_uniqueStorage()._response = .startReplay(newValue)}
  }

  var leaveGame: SC2APIProtocol_ResponseLeaveGame {
    get {
      if case .leaveGame(let v)? = _storage._response {return v}
      return SC2APIProtocol_ResponseLeaveGame()
    }
    set {_uniqueStorage()._response = .leaveGame(newValue)}
  }

  var quickSave: SC2APIProtocol_ResponseQuickSave {
    get {
      if case .quickSave(let v)? = _storage._response {return v}
      return SC2APIProtocol_ResponseQuickSave()
    }
    set {_uniqueStorage()._response = .quickSave(newValue)}
  }

  var quickLoad: SC2APIProtocol_ResponseQuickLoad {
    get {
      if case .quickLoad(let v)? = _storage._response {return v}
      return SC2APIProtocol_ResponseQuickLoad()
    }
    set {_uniqueStorage()._response = .quickLoad(newValue)}
  }

  var quit: SC2APIProtocol_ResponseQuit {
    get {
      if case .quit(let v)? = _storage._response {return v}
      return SC2APIProtocol_ResponseQuit()
    }
    set {_uniqueStorage()._response = .quit(newValue)}
  }

  var gameInfo: SC2APIProtocol_ResponseGameInfo {
    get {
      if case .gameInfo(let v)? = _storage._response {return v}
      return SC2APIProtocol_ResponseGameInfo()
    }
    set {_uniqueStorage()._response = .gameInfo(newValue)}
  }

  var observation: SC2APIProtocol_ResponseObservation {
    get {
      if case .observation(let v)? = _storage._response {return v}
      return SC2APIProtocol_ResponseObservation()
    }
    set {_uniqueStorage()._response = .observation(newValue)}
  }

  var action: SC2APIProtocol_ResponseAction {
    get {
      if case .action(let v)? = _storage._response {return v}
      return SC2APIProtocol_ResponseAction()
    }
    set {_uniqueStorage()._response = .action(newValue)}
  }

  var obsAction: SC2APIProtocol_ResponseObserverAction {
    get {
      if case .obsAction(let v)? = _storage._response {return v}
      return SC2APIProtocol_ResponseObserverAction()
    }
    set {_uniqueStorage()._response = .obsAction(newValue)}
  }

  var step: SC2APIProtocol_ResponseStep {
    get {
      if case .step(let v)? = _storage._response {return v}
      return SC2APIProtocol_ResponseStep()
    }
    set {_uniqueStorage()._response = .step(newValue)}
  }

  var data: SC2APIProtocol_ResponseData {
    get {
      if case .data(let v)? = _storage._response {return v}
      return SC2APIProtocol_ResponseData()
    }
    set {_uniqueStorage()._response = .data(newValue)}
  }

  var query: SC2APIProtocol_ResponseQuery {
    get {
      if case .query(let v)? = _storage._response {return v}
      return SC2APIProtocol_ResponseQuery()
    }
    set {_uniqueStorage()._response = .query(newValue)}
  }

  var saveReplay: SC2APIProtocol_ResponseSaveReplay {
    get {
      if case .saveReplay(let v)? = _storage._response {return v}
      return SC2APIProtocol_ResponseSaveReplay()
    }
    set {_uniqueStorage()._response = .saveReplay(newValue)}
  }

  var replayInfo: SC2APIProtocol_ResponseReplayInfo {
    get {
      if case .replayInfo(let v)? = _storage._response {return v}
      return SC2APIProtocol_ResponseReplayInfo()
    }
    set {_uniqueStorage()._response = .replayInfo(newValue)}
  }

  var availableMaps: SC2APIProtocol_ResponseAvailableMaps {
    get {
      if case .availableMaps(let v)? = _storage._response {return v}
      return SC2APIProtocol_ResponseAvailableMaps()
    }
    set {_uniqueStorage()._response = .availableMaps(newValue)}
  }

  var saveMap: SC2APIProtocol_ResponseSaveMap {
    get {
      if case .saveMap(let v)? = _storage._response {return v}
      return SC2APIProtocol_ResponseSaveMap()
    }
    set {_uniqueStorage()._response = .saveMap(newValue)}
  }

  var mapCommand: SC2APIProtocol_ResponseMapCommand {
    get {
      if case .mapCommand(let v)? = _storage._response {return v}
      return SC2APIProtocol_ResponseMapCommand()
    }
    set {_uniqueStorage()._response = .mapCommand(newValue)}
  }

  /// Debugging
  var ping: SC2APIProtocol_ResponsePing {
    get {
      if case .ping(let v)? = _storage._response {return v}
      return SC2APIProtocol_ResponsePing()
    }
    set {_uniqueStorage()._response = .ping(newValue)}
  }

  var debug: SC2APIProtocol_ResponseDebug {
    get {
      if case .debug(let v)? = _storage._response {return v}
      return SC2APIProtocol_ResponseDebug()
    }
    set {_uniqueStorage()._response = .debug(newValue)}
  }

  var id: UInt32 {
    get {return _storage._id ?? 0}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {_uniqueStorage()._id = nil}

  /// If command is missing, this will contain the error. Otherwise this will contain any warnings.
  var error: [String] {
    get {return _storage._error}
    set {_uniqueStorage()._error = newValue}
  }

  /// Should be sent back with all responses.
  var status: SC2APIProtocol_Status {
    get {return _storage._status ?? .launched}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable {
    case createGame(SC2APIProtocol_ResponseCreateGame)
    case joinGame(SC2APIProtocol_ResponseJoinGame)
    case restartGame(SC2APIProtocol_ResponseRestartGame)
    case startReplay(SC2APIProtocol_ResponseStartReplay)
    case leaveGame(SC2APIProtocol_ResponseLeaveGame)
    case quickSave(SC2APIProtocol_ResponseQuickSave)
    case quickLoad(SC2APIProtocol_ResponseQuickLoad)
    case quit(SC2APIProtocol_ResponseQuit)
    case gameInfo(SC2APIProtocol_ResponseGameInfo)
    case observation(SC2APIProtocol_ResponseObservation)
    case action(SC2APIProtocol_ResponseAction)
    case obsAction(SC2APIProtocol_ResponseObserverAction)
    case step(SC2APIProtocol_ResponseStep)
    case data(SC2APIProtocol_ResponseData)
    case query(SC2APIProtocol_ResponseQuery)
    case saveReplay(SC2APIProtocol_ResponseSaveReplay)
    case replayInfo(SC2APIProtocol_ResponseReplayInfo)
    case availableMaps(SC2APIProtocol_ResponseAvailableMaps)
    case saveMap(SC2APIProtocol_ResponseSaveMap)
    case mapCommand(SC2APIProtocol_ResponseMapCommand)
    /// Debugging
    case ping(SC2APIProtocol_ResponsePing)
    case debug(SC2APIProtocol_ResponseDebug)

  #if !swift(>=4.1)
    static func ==(lhs: SC2APIProtocol_Response.OneOf_Response, rhs: SC2APIProtocol_Response.OneOf_Response) -> Bool {
      switch (lhs, rhs) {
      case (.createGame(let l), .createGame(let r)): return l == r
      case (.joinGame(let l), .joinGame(let r)): return l == r
      case (.restartGame(let l), .restartGame(let r)): return l == r
      case (.startReplay(let l), .startReplay(let r)): return l == r
      case (.leaveGame(let l), .leaveGame(let r)): return l == r
      case (.quickSave(let l), .quickSave(let r)): return l == r
      case (.quickLoad(let l), .quickLoad(let r)): return l == r
      case (.quit(let l), .quit(let r)): return l == r
      case (.gameInfo(let l), .gameInfo(let r)): return l == r
      case (.observation(let l), .observation(let r)): return l == r
      case (.action(let l), .action(let r)): return l == r
      case (.obsAction(let l), .obsAction(let r)): return l == r
      case (.step(let l), .step(let r)): return l == r
      case (.data(let l), .data(let r)): return l == r
      case (.query(let l), .query(let r)): return l == r
      case (.saveReplay(let l), .saveReplay(let r)): return l == r
      case (.replayInfo(let l), .replayInfo(let r)): return l == r
      case (.availableMaps(let l), .availableMaps(let r)): return l == r
      case (.saveMap(let l), .saveMap(let r)): return l == r
      case (.mapCommand(let l), .mapCommand(let r)): return l == r
      case (.ping(let l), .ping(let r)): return l == r
      case (.debug(let l), .debug(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///-----------------------------------------------------------------------------
/// If successful, puts the game into the status: init_game.
/// The next expected request should be RequestJoinGame. Can also quit (exit).
struct SC2APIProtocol_RequestCreateGame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var map: OneOf_Map? {
    get {return _storage._map}
    set {_uniqueStorage()._map = newValue}
  }

  /// Local .SC2Map file
  var localMap: SC2APIProtocol_LocalMap {
    get {
      if case .localMap(let v)? = _storage._map {return v}
      return SC2APIProtocol_LocalMap()
    }
    set {_uniqueStorage()._map = .localMap(newValue)}
  }

  /// Map published to BattleNet
  var battlenetMapName: String {
    get {
      if case .battlenetMapName(let v)? = _storage._map {return v}
      return String()
    }
    set {_uniqueStorage()._map = .battlenetMapName(newValue)}
  }

  var playerSetup: [SC2APIProtocol_PlayerSetup] {
    get {return _storage._playerSetup}
    set {_uniqueStorage()._playerSetup = newValue}
  }

  var disableFog: Bool {
    get {return _storage._disableFog ?? false}
    set {_uniqueStorage()._disableFog = newValue}
  }
  /// Returns true if `disableFog` has been explicitly set.
  var hasDisableFog: Bool {return _storage._disableFog != nil}
  /// Clears the value of `disableFog`. Subsequent reads from it will return its default value.
  mutating func clearDisableFog() {_uniqueStorage()._disableFog = nil}

  /// Sets the pseudo-random seed for the game.
  var randomSeed: UInt32 {
    get {return _storage._randomSeed ?? 0}
    set {_uniqueStorage()._randomSeed = newValue}
  }
  /// Returns true if `randomSeed` has been explicitly set.
  var hasRandomSeed: Bool {return _storage._randomSeed != nil}
  /// Clears the value of `randomSeed`. Subsequent reads from it will return its default value.
  mutating func clearRandomSeed() {_uniqueStorage()._randomSeed = nil}

  /// If set, the game plays in real time.
  var realtime: Bool {
    get {return _storage._realtime ?? false}
    set {_uniqueStorage()._realtime = newValue}
  }
  /// Returns true if `realtime` has been explicitly set.
  var hasRealtime: Bool {return _storage._realtime != nil}
  /// Clears the value of `realtime`. Subsequent reads from it will return its default value.
  mutating func clearRealtime() {_uniqueStorage()._realtime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Map: Equatable {
    /// Local .SC2Map file
    case localMap(SC2APIProtocol_LocalMap)
    /// Map published to BattleNet
    case battlenetMapName(String)

  #if !swift(>=4.1)
    static func ==(lhs: SC2APIProtocol_RequestCreateGame.OneOf_Map, rhs: SC2APIProtocol_RequestCreateGame.OneOf_Map) -> Bool {
      switch (lhs, rhs) {
      case (.localMap(let l), .localMap(let r)): return l == r
      case (.battlenetMapName(let l), .battlenetMapName(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_LocalMap {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A map can be specified either by a file path or the data of the .SC2Map file.
  /// If you provide both, it will play the game using map_data and store map_path
  /// into the replay. (260 character max)
  var mapPath: String {
    get {return _mapPath ?? String()}
    set {_mapPath = newValue}
  }
  /// Returns true if `mapPath` has been explicitly set.
  var hasMapPath: Bool {return self._mapPath != nil}
  /// Clears the value of `mapPath`. Subsequent reads from it will return its default value.
  mutating func clearMapPath() {self._mapPath = nil}

  var mapData: Data {
    get {return _mapData ?? SwiftProtobuf.Internal.emptyData}
    set {_mapData = newValue}
  }
  /// Returns true if `mapData` has been explicitly set.
  var hasMapData: Bool {return self._mapData != nil}
  /// Clears the value of `mapData`. Subsequent reads from it will return its default value.
  mutating func clearMapData() {self._mapData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mapPath: String? = nil
  fileprivate var _mapData: Data? = nil
}

struct SC2APIProtocol_ResponseCreateGame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: SC2APIProtocol_ResponseCreateGame.Error {
    get {return _error ?? .missingMap}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var errorDetails: String {
    get {return _errorDetails ?? String()}
    set {_errorDetails = newValue}
  }
  /// Returns true if `errorDetails` has been explicitly set.
  var hasErrorDetails: Bool {return self._errorDetails != nil}
  /// Clears the value of `errorDetails`. Subsequent reads from it will return its default value.
  mutating func clearErrorDetails() {self._errorDetails = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Error: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case missingMap // = 1
    case invalidMapPath // = 2
    case invalidMapData // = 3
    case invalidMapName // = 4
    case invalidMapHandle // = 5
    case missingPlayerSetup // = 6
    case invalidPlayerSetup // = 7

    /// Multiplayer is not supported in the current build.
    case multiplayerUnsupported // = 8

    init() {
      self = .missingMap
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .missingMap
      case 2: self = .invalidMapPath
      case 3: self = .invalidMapData
      case 4: self = .invalidMapName
      case 5: self = .invalidMapHandle
      case 6: self = .missingPlayerSetup
      case 7: self = .invalidPlayerSetup
      case 8: self = .multiplayerUnsupported
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .missingMap: return 1
      case .invalidMapPath: return 2
      case .invalidMapData: return 3
      case .invalidMapName: return 4
      case .invalidMapHandle: return 5
      case .missingPlayerSetup: return 6
      case .invalidPlayerSetup: return 7
      case .multiplayerUnsupported: return 8
      }
    }

  }

  init() {}

  fileprivate var _error: SC2APIProtocol_ResponseCreateGame.Error? = nil
  fileprivate var _errorDetails: String? = nil
}

#if swift(>=4.2)

extension SC2APIProtocol_ResponseCreateGame.Error: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///-----------------------------------------------------------------------------
/// If successful, puts the game into the status: in_game. Will be able to
/// request actions, observations and step the game.
struct SC2APIProtocol_RequestJoinGame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var participation: OneOf_Participation? {
    get {return _storage._participation}
    set {_uniqueStorage()._participation = newValue}
  }

  /// Join as participant
  var race: SC2APIProtocol_Race {
    get {
      if case .race(let v)? = _storage._participation {return v}
      return .noRace
    }
    set {_uniqueStorage()._participation = .race(newValue)}
  }

  /// Join as observer
  var observedPlayerID: UInt32 {
    get {
      if case .observedPlayerID(let v)? = _storage._participation {return v}
      return 0
    }
    set {_uniqueStorage()._participation = .observedPlayerID(newValue)}
  }

  /// This is limited to what is specified in RequestCreateGame, but you can request less information if you want.
  var options: SC2APIProtocol_InterfaceOptions {
    get {return _storage._options ?? SC2APIProtocol_InterfaceOptions()}
    set {_uniqueStorage()._options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  var hasOptions: Bool {return _storage._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  mutating func clearOptions() {_uniqueStorage()._options = nil}

  /// Do not set in the single-player case. This is the port a server will use.
  var serverPorts: SC2APIProtocol_PortSet {
    get {return _storage._serverPorts ?? SC2APIProtocol_PortSet()}
    set {_uniqueStorage()._serverPorts = newValue}
  }
  /// Returns true if `serverPorts` has been explicitly set.
  var hasServerPorts: Bool {return _storage._serverPorts != nil}
  /// Clears the value of `serverPorts`. Subsequent reads from it will return its default value.
  mutating func clearServerPorts() {_uniqueStorage()._serverPorts = nil}

  /// Do not set in the single-player case. These are the ports clients will use to initialize communication.
  var clientPorts: [SC2APIProtocol_PortSet] {
    get {return _storage._clientPorts}
    set {_uniqueStorage()._clientPorts = newValue}
  }

  /// Currently only a singe client is supported.
  var sharedPort: Int32 {
    get {return _storage._sharedPort ?? 0}
    set {_uniqueStorage()._sharedPort = newValue}
  }
  /// Returns true if `sharedPort` has been explicitly set.
  var hasSharedPort: Bool {return _storage._sharedPort != nil}
  /// Clears the value of `sharedPort`. Subsequent reads from it will return its default value.
  mutating func clearSharedPort() {_uniqueStorage()._sharedPort = nil}

  /// Use this to set the player's name to something other than autogenerated name.
  var playerName: String {
    get {return _storage._playerName ?? String()}
    set {_uniqueStorage()._playerName = newValue}
  }
  /// Returns true if `playerName` has been explicitly set.
  var hasPlayerName: Bool {return _storage._playerName != nil}
  /// Clears the value of `playerName`. Subsequent reads from it will return its default value.
  mutating func clearPlayerName() {_uniqueStorage()._playerName = nil}

  /// Both game creator and joiner should provide the ip address of the game creator in order to play remotely. Defaults to localhost.
  var hostIp: String {
    get {return _storage._hostIp ?? String()}
    set {_uniqueStorage()._hostIp = newValue}
  }
  /// Returns true if `hostIp` has been explicitly set.
  var hasHostIp: Bool {return _storage._hostIp != nil}
  /// Clears the value of `hostIp`. Subsequent reads from it will return its default value.
  mutating func clearHostIp() {_uniqueStorage()._hostIp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Participation: Equatable {
    /// Join as participant
    case race(SC2APIProtocol_Race)
    /// Join as observer
    case observedPlayerID(UInt32)

  #if !swift(>=4.1)
    static func ==(lhs: SC2APIProtocol_RequestJoinGame.OneOf_Participation, rhs: SC2APIProtocol_RequestJoinGame.OneOf_Participation) -> Bool {
      switch (lhs, rhs) {
      case (.race(let l), .race(let r)): return l == r
      case (.observedPlayerID(let l), .observedPlayerID(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_PortSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Game right now needs two internal ports to establish a multiplay game on the local host.
  var gamePort: Int32 {
    get {return _gamePort ?? 0}
    set {_gamePort = newValue}
  }
  /// Returns true if `gamePort` has been explicitly set.
  var hasGamePort: Bool {return self._gamePort != nil}
  /// Clears the value of `gamePort`. Subsequent reads from it will return its default value.
  mutating func clearGamePort() {self._gamePort = nil}

  var basePort: Int32 {
    get {return _basePort ?? 0}
    set {_basePort = newValue}
  }
  /// Returns true if `basePort` has been explicitly set.
  var hasBasePort: Bool {return self._basePort != nil}
  /// Clears the value of `basePort`. Subsequent reads from it will return its default value.
  mutating func clearBasePort() {self._basePort = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _gamePort: Int32? = nil
  fileprivate var _basePort: Int32? = nil
}

struct SC2APIProtocol_ResponseJoinGame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var playerID: UInt32 {
    get {return _playerID ?? 0}
    set {_playerID = newValue}
  }
  /// Returns true if `playerID` has been explicitly set.
  var hasPlayerID: Bool {return self._playerID != nil}
  /// Clears the value of `playerID`. Subsequent reads from it will return its default value.
  mutating func clearPlayerID() {self._playerID = nil}

  var error: SC2APIProtocol_ResponseJoinGame.Error {
    get {return _error ?? .missingParticipation}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var errorDetails: String {
    get {return _errorDetails ?? String()}
    set {_errorDetails = newValue}
  }
  /// Returns true if `errorDetails` has been explicitly set.
  var hasErrorDetails: Bool {return self._errorDetails != nil}
  /// Clears the value of `errorDetails`. Subsequent reads from it will return its default value.
  mutating func clearErrorDetails() {self._errorDetails = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Error: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case missingParticipation // = 1
    case invalidObservedPlayerID // = 2
    case missingOptions // = 3
    case missingPorts // = 4
    case gameFull // = 5
    case launchError // = 6

    /// Multiplayer specific.
    case featureUnsupported // = 7
    case noSpaceForUser // = 8
    case mapDoesNotExist // = 9
    case cannotOpenMap // = 10
    case checksumError // = 11
    case networkError // = 12
    case otherError // = 13

    init() {
      self = .missingParticipation
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .missingParticipation
      case 2: self = .invalidObservedPlayerID
      case 3: self = .missingOptions
      case 4: self = .missingPorts
      case 5: self = .gameFull
      case 6: self = .launchError
      case 7: self = .featureUnsupported
      case 8: self = .noSpaceForUser
      case 9: self = .mapDoesNotExist
      case 10: self = .cannotOpenMap
      case 11: self = .checksumError
      case 12: self = .networkError
      case 13: self = .otherError
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .missingParticipation: return 1
      case .invalidObservedPlayerID: return 2
      case .missingOptions: return 3
      case .missingPorts: return 4
      case .gameFull: return 5
      case .launchError: return 6
      case .featureUnsupported: return 7
      case .noSpaceForUser: return 8
      case .mapDoesNotExist: return 9
      case .cannotOpenMap: return 10
      case .checksumError: return 11
      case .networkError: return 12
      case .otherError: return 13
      }
    }

  }

  init() {}

  fileprivate var _playerID: UInt32? = nil
  fileprivate var _error: SC2APIProtocol_ResponseJoinGame.Error? = nil
  fileprivate var _errorDetails: String? = nil
}

#if swift(>=4.2)

extension SC2APIProtocol_ResponseJoinGame.Error: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///-----------------------------------------------------------------------------
struct SC2APIProtocol_RequestRestartGame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The defaultRestartGameLoops is specified to be (1<<18) by default
struct SC2APIProtocol_ResponseRestartGame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: SC2APIProtocol_ResponseRestartGame.Error {
    get {return _error ?? .launchError}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var errorDetails: String {
    get {return _errorDetails ?? String()}
    set {_errorDetails = newValue}
  }
  /// Returns true if `errorDetails` has been explicitly set.
  var hasErrorDetails: Bool {return self._errorDetails != nil}
  /// Clears the value of `errorDetails`. Subsequent reads from it will return its default value.
  mutating func clearErrorDetails() {self._errorDetails = nil}

  /// This will occur once the simulation_loop is greater then defaultRestartGameLoops
  var needHardReset: Bool {
    get {return _needHardReset ?? false}
    set {_needHardReset = newValue}
  }
  /// Returns true if `needHardReset` has been explicitly set.
  var hasNeedHardReset: Bool {return self._needHardReset != nil}
  /// Clears the value of `needHardReset`. Subsequent reads from it will return its default value.
  mutating func clearNeedHardReset() {self._needHardReset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Error: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case launchError // = 1

    init() {
      self = .launchError
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .launchError
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .launchError: return 1
      }
    }

  }

  init() {}

  fileprivate var _error: SC2APIProtocol_ResponseRestartGame.Error? = nil
  fileprivate var _errorDetails: String? = nil
  fileprivate var _needHardReset: Bool? = nil
}

#if swift(>=4.2)

extension SC2APIProtocol_ResponseRestartGame.Error: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///-----------------------------------------------------------------------------
struct SC2APIProtocol_RequestStartReplay {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var replay: OneOf_Replay? {
    get {return _storage._replay}
    set {_uniqueStorage()._replay = newValue}
  }

  var replayPath: String {
    get {
      if case .replayPath(let v)? = _storage._replay {return v}
      return String()
    }
    set {_uniqueStorage()._replay = .replayPath(newValue)}
  }

  var replayData: Data {
    get {
      if case .replayData(let v)? = _storage._replay {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {_uniqueStorage()._replay = .replayData(newValue)}
  }

  /// Overrides the map path stored in the replay.
  var mapData: Data {
    get {return _storage._mapData ?? SwiftProtobuf.Internal.emptyData}
    set {_uniqueStorage()._mapData = newValue}
  }
  /// Returns true if `mapData` has been explicitly set.
  var hasMapData: Bool {return _storage._mapData != nil}
  /// Clears the value of `mapData`. Subsequent reads from it will return its default value.
  mutating func clearMapData() {_uniqueStorage()._mapData = nil}

  var observedPlayerID: Int32 {
    get {return _storage._observedPlayerID ?? 0}
    set {_uniqueStorage()._observedPlayerID = newValue}
  }
  /// Returns true if `observedPlayerID` has been explicitly set.
  var hasObservedPlayerID: Bool {return _storage._observedPlayerID != nil}
  /// Clears the value of `observedPlayerID`. Subsequent reads from it will return its default value.
  mutating func clearObservedPlayerID() {_uniqueStorage()._observedPlayerID = nil}

  var options: SC2APIProtocol_InterfaceOptions {
    get {return _storage._options ?? SC2APIProtocol_InterfaceOptions()}
    set {_uniqueStorage()._options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  var hasOptions: Bool {return _storage._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  mutating func clearOptions() {_uniqueStorage()._options = nil}

  var disableFog: Bool {
    get {return _storage._disableFog ?? false}
    set {_uniqueStorage()._disableFog = newValue}
  }
  /// Returns true if `disableFog` has been explicitly set.
  var hasDisableFog: Bool {return _storage._disableFog != nil}
  /// Clears the value of `disableFog`. Subsequent reads from it will return its default value.
  mutating func clearDisableFog() {_uniqueStorage()._disableFog = nil}

  var realtime: Bool {
    get {return _storage._realtime ?? false}
    set {_uniqueStorage()._realtime = newValue}
  }
  /// Returns true if `realtime` has been explicitly set.
  var hasRealtime: Bool {return _storage._realtime != nil}
  /// Clears the value of `realtime`. Subsequent reads from it will return its default value.
  mutating func clearRealtime() {_uniqueStorage()._realtime = nil}

  /// Allow RequestSaveReplay from a replay. Useful for truncating a replay, or restoring tracker.events.
  var recordReplay: Bool {
    get {return _storage._recordReplay ?? false}
    set {_uniqueStorage()._recordReplay = newValue}
  }
  /// Returns true if `recordReplay` has been explicitly set.
  var hasRecordReplay: Bool {return _storage._recordReplay != nil}
  /// Clears the value of `recordReplay`. Subsequent reads from it will return its default value.
  mutating func clearRecordReplay() {_uniqueStorage()._recordReplay = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Replay: Equatable {
    case replayPath(String)
    case replayData(Data)

  #if !swift(>=4.1)
    static func ==(lhs: SC2APIProtocol_RequestStartReplay.OneOf_Replay, rhs: SC2APIProtocol_RequestStartReplay.OneOf_Replay) -> Bool {
      switch (lhs, rhs) {
      case (.replayPath(let l), .replayPath(let r)): return l == r
      case (.replayData(let l), .replayData(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_ResponseStartReplay {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: SC2APIProtocol_ResponseStartReplay.Error {
    get {return _error ?? .missingReplay}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var errorDetails: String {
    get {return _errorDetails ?? String()}
    set {_errorDetails = newValue}
  }
  /// Returns true if `errorDetails` has been explicitly set.
  var hasErrorDetails: Bool {return self._errorDetails != nil}
  /// Clears the value of `errorDetails`. Subsequent reads from it will return its default value.
  mutating func clearErrorDetails() {self._errorDetails = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Error: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case missingReplay // = 1
    case invalidReplayPath // = 2
    case invalidReplayData // = 3
    case invalidMapData // = 4
    case invalidObservedPlayerID // = 5
    case missingOptions // = 6
    case launchError // = 7

    init() {
      self = .missingReplay
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .missingReplay
      case 2: self = .invalidReplayPath
      case 3: self = .invalidReplayData
      case 4: self = .invalidMapData
      case 5: self = .invalidObservedPlayerID
      case 6: self = .missingOptions
      case 7: self = .launchError
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .missingReplay: return 1
      case .invalidReplayPath: return 2
      case .invalidReplayData: return 3
      case .invalidMapData: return 4
      case .invalidObservedPlayerID: return 5
      case .missingOptions: return 6
      case .launchError: return 7
      }
    }

  }

  init() {}

  fileprivate var _error: SC2APIProtocol_ResponseStartReplay.Error? = nil
  fileprivate var _errorDetails: String? = nil
}

#if swift(>=4.2)

extension SC2APIProtocol_ResponseStartReplay.Error: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///-----------------------------------------------------------------------------
struct SC2APIProtocol_RequestMapCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var triggerCmd: String {
    get {return _triggerCmd ?? String()}
    set {_triggerCmd = newValue}
  }
  /// Returns true if `triggerCmd` has been explicitly set.
  var hasTriggerCmd: Bool {return self._triggerCmd != nil}
  /// Clears the value of `triggerCmd`. Subsequent reads from it will return its default value.
  mutating func clearTriggerCmd() {self._triggerCmd = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _triggerCmd: String? = nil
}

struct SC2APIProtocol_ResponseMapCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: SC2APIProtocol_ResponseMapCommand.Error {
    get {return _error ?? .noTriggerError}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var errorDetails: String {
    get {return _errorDetails ?? String()}
    set {_errorDetails = newValue}
  }
  /// Returns true if `errorDetails` has been explicitly set.
  var hasErrorDetails: Bool {return self._errorDetails != nil}
  /// Clears the value of `errorDetails`. Subsequent reads from it will return its default value.
  mutating func clearErrorDetails() {self._errorDetails = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Error: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case noTriggerError // = 1

    init() {
      self = .noTriggerError
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .noTriggerError
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .noTriggerError: return 1
      }
    }

  }

  init() {}

  fileprivate var _error: SC2APIProtocol_ResponseMapCommand.Error? = nil
  fileprivate var _errorDetails: String? = nil
}

#if swift(>=4.2)

extension SC2APIProtocol_ResponseMapCommand.Error: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///-----------------------------------------------------------------------------
struct SC2APIProtocol_RequestLeaveGame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SC2APIProtocol_ResponseLeaveGame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///-----------------------------------------------------------------------------
struct SC2APIProtocol_RequestQuickSave {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///-----------------------------------------------------------------------------
struct SC2APIProtocol_ResponseQuickSave {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///-----------------------------------------------------------------------------
struct SC2APIProtocol_RequestQuickLoad {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///-----------------------------------------------------------------------------
struct SC2APIProtocol_ResponseQuickLoad {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///-----------------------------------------------------------------------------
struct SC2APIProtocol_RequestQuit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SC2APIProtocol_ResponseQuit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///-----------------------------------------------------------------------------
struct SC2APIProtocol_RequestGameInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SC2APIProtocol_ResponseGameInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mapName: String {
    get {return _storage._mapName ?? String()}
    set {_uniqueStorage()._mapName = newValue}
  }
  /// Returns true if `mapName` has been explicitly set.
  var hasMapName: Bool {return _storage._mapName != nil}
  /// Clears the value of `mapName`. Subsequent reads from it will return its default value.
  mutating func clearMapName() {_uniqueStorage()._mapName = nil}

  var modNames: [String] {
    get {return _storage._modNames}
    set {_uniqueStorage()._modNames = newValue}
  }

  var localMapPath: String {
    get {return _storage._localMapPath ?? String()}
    set {_uniqueStorage()._localMapPath = newValue}
  }
  /// Returns true if `localMapPath` has been explicitly set.
  var hasLocalMapPath: Bool {return _storage._localMapPath != nil}
  /// Clears the value of `localMapPath`. Subsequent reads from it will return its default value.
  mutating func clearLocalMapPath() {_uniqueStorage()._localMapPath = nil}

  var playerInfo: [SC2APIProtocol_PlayerInfo] {
    get {return _storage._playerInfo}
    set {_uniqueStorage()._playerInfo = newValue}
  }

  /// Populated if Raw interface is enabled.
  var startRaw: SC2APIProtocol_StartRaw {
    get {return _storage._startRaw ?? SC2APIProtocol_StartRaw()}
    set {_uniqueStorage()._startRaw = newValue}
  }
  /// Returns true if `startRaw` has been explicitly set.
  var hasStartRaw: Bool {return _storage._startRaw != nil}
  /// Clears the value of `startRaw`. Subsequent reads from it will return its default value.
  mutating func clearStartRaw() {_uniqueStorage()._startRaw = nil}

  var options: SC2APIProtocol_InterfaceOptions {
    get {return _storage._options ?? SC2APIProtocol_InterfaceOptions()}
    set {_uniqueStorage()._options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  var hasOptions: Bool {return _storage._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  mutating func clearOptions() {_uniqueStorage()._options = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///-----------------------------------------------------------------------------
struct SC2APIProtocol_RequestObservation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var disableFog: Bool {
    get {return _disableFog ?? false}
    set {_disableFog = newValue}
  }
  /// Returns true if `disableFog` has been explicitly set.
  var hasDisableFog: Bool {return self._disableFog != nil}
  /// Clears the value of `disableFog`. Subsequent reads from it will return its default value.
  mutating func clearDisableFog() {self._disableFog = nil}

  /// In realtime the request will only return once the simulation game loop has reached this value. When not realtime this value is ignored.
  var gameLoop: UInt32 {
    get {return _gameLoop ?? 0}
    set {_gameLoop = newValue}
  }
  /// Returns true if `gameLoop` has been explicitly set.
  var hasGameLoop: Bool {return self._gameLoop != nil}
  /// Clears the value of `gameLoop`. Subsequent reads from it will return its default value.
  mutating func clearGameLoop() {self._gameLoop = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _disableFog: Bool? = nil
  fileprivate var _gameLoop: UInt32? = nil
}

struct SC2APIProtocol_ResponseObservation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Actions this player did since the last Observation.
  var actions: [SC2APIProtocol_Action] {
    get {return _storage._actions}
    set {_uniqueStorage()._actions = newValue}
  }

  /// Equivalent of UI "red text" errors.
  var actionErrors: [SC2APIProtocol_ActionError] {
    get {return _storage._actionErrors}
    set {_uniqueStorage()._actionErrors = newValue}
  }

  var observation: SC2APIProtocol_Observation {
    get {return _storage._observation ?? SC2APIProtocol_Observation()}
    set {_uniqueStorage()._observation = newValue}
  }
  /// Returns true if `observation` has been explicitly set.
  var hasObservation: Bool {return _storage._observation != nil}
  /// Clears the value of `observation`. Subsequent reads from it will return its default value.
  mutating func clearObservation() {_uniqueStorage()._observation = nil}

  /// Only populated if the game ended during this step.
  var playerResult: [SC2APIProtocol_PlayerResult] {
    get {return _storage._playerResult}
    set {_uniqueStorage()._playerResult = newValue}
  }

  var chat: [SC2APIProtocol_ChatReceived] {
    get {return _storage._chat}
    set {_uniqueStorage()._chat = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_ChatReceived {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var playerID: UInt32 {
    get {return _playerID ?? 0}
    set {_playerID = newValue}
  }
  /// Returns true if `playerID` has been explicitly set.
  var hasPlayerID: Bool {return self._playerID != nil}
  /// Clears the value of `playerID`. Subsequent reads from it will return its default value.
  mutating func clearPlayerID() {self._playerID = nil}

  var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {self._message = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _playerID: UInt32? = nil
  fileprivate var _message: String? = nil
}

///-----------------------------------------------------------------------------
struct SC2APIProtocol_RequestAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actions: [SC2APIProtocol_Action] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SC2APIProtocol_ResponseAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: [SC2APIProtocol_ActionResult] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///-----------------------------------------------------------------------------
struct SC2APIProtocol_RequestObserverAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actions: [SC2APIProtocol_ObserverAction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SC2APIProtocol_ResponseObserverAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///-----------------------------------------------------------------------------
struct SC2APIProtocol_RequestStep {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Number of game loops to simulate for the next frame.
  var count: UInt32 {
    get {return _count ?? 0}
    set {_count = newValue}
  }
  /// Returns true if `count` has been explicitly set.
  var hasCount: Bool {return self._count != nil}
  /// Clears the value of `count`. Subsequent reads from it will return its default value.
  mutating func clearCount() {self._count = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _count: UInt32? = nil
}

struct SC2APIProtocol_ResponseStep {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///  Max simulation_loop is (1<<19) before "end of time" will occur
  ///  The "end of time" is classified as the maximum number of game loops or absolute game time
  ///  representable as a positive fixed point number.
  ///  When we reach the "end of time", permanently pause the game and end the game for all.
  var simulationLoop: UInt32 {
    get {return _simulationLoop ?? 0}
    set {_simulationLoop = newValue}
  }
  /// Returns true if `simulationLoop` has been explicitly set.
  var hasSimulationLoop: Bool {return self._simulationLoop != nil}
  /// Clears the value of `simulationLoop`. Subsequent reads from it will return its default value.
  mutating func clearSimulationLoop() {self._simulationLoop = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _simulationLoop: UInt32? = nil
}

///-----------------------------------------------------------------------------
struct SC2APIProtocol_RequestData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var abilityID: Bool {
    get {return _abilityID ?? false}
    set {_abilityID = newValue}
  }
  /// Returns true if `abilityID` has been explicitly set.
  var hasAbilityID: Bool {return self._abilityID != nil}
  /// Clears the value of `abilityID`. Subsequent reads from it will return its default value.
  mutating func clearAbilityID() {self._abilityID = nil}

  var unitTypeID: Bool {
    get {return _unitTypeID ?? false}
    set {_unitTypeID = newValue}
  }
  /// Returns true if `unitTypeID` has been explicitly set.
  var hasUnitTypeID: Bool {return self._unitTypeID != nil}
  /// Clears the value of `unitTypeID`. Subsequent reads from it will return its default value.
  mutating func clearUnitTypeID() {self._unitTypeID = nil}

  var upgradeID: Bool {
    get {return _upgradeID ?? false}
    set {_upgradeID = newValue}
  }
  /// Returns true if `upgradeID` has been explicitly set.
  var hasUpgradeID: Bool {return self._upgradeID != nil}
  /// Clears the value of `upgradeID`. Subsequent reads from it will return its default value.
  mutating func clearUpgradeID() {self._upgradeID = nil}

  var buffID: Bool {
    get {return _buffID ?? false}
    set {_buffID = newValue}
  }
  /// Returns true if `buffID` has been explicitly set.
  var hasBuffID: Bool {return self._buffID != nil}
  /// Clears the value of `buffID`. Subsequent reads from it will return its default value.
  mutating func clearBuffID() {self._buffID = nil}

  var effectID: Bool {
    get {return _effectID ?? false}
    set {_effectID = newValue}
  }
  /// Returns true if `effectID` has been explicitly set.
  var hasEffectID: Bool {return self._effectID != nil}
  /// Clears the value of `effectID`. Subsequent reads from it will return its default value.
  mutating func clearEffectID() {self._effectID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _abilityID: Bool? = nil
  fileprivate var _unitTypeID: Bool? = nil
  fileprivate var _upgradeID: Bool? = nil
  fileprivate var _buffID: Bool? = nil
  fileprivate var _effectID: Bool? = nil
}

struct SC2APIProtocol_ResponseData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var abilities: [SC2APIProtocol_AbilityData] = []

  var units: [SC2APIProtocol_UnitTypeData] = []

  var upgrades: [SC2APIProtocol_UpgradeData] = []

  var buffs: [SC2APIProtocol_BuffData] = []

  var effects: [SC2APIProtocol_EffectData] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///-----------------------------------------------------------------------------
struct SC2APIProtocol_RequestSaveReplay {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SC2APIProtocol_ResponseSaveReplay {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Data {
    get {return _data ?? SwiftProtobuf.Internal.emptyData}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {self._data = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _data: Data? = nil
}

///-----------------------------------------------------------------------------
struct SC2APIProtocol_RequestReplayInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var replay: SC2APIProtocol_RequestReplayInfo.OneOf_Replay? = nil

  /// Limitation: might fail if the replay file is currently loaded.
  var replayPath: String {
    get {
      if case .replayPath(let v)? = replay {return v}
      return String()
    }
    set {replay = .replayPath(newValue)}
  }

  var replayData: Data {
    get {
      if case .replayData(let v)? = replay {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {replay = .replayData(newValue)}
  }

  /// Ensure the data and binary are downloaded if this is an old version replay.
  var downloadData: Bool {
    get {return _downloadData ?? false}
    set {_downloadData = newValue}
  }
  /// Returns true if `downloadData` has been explicitly set.
  var hasDownloadData: Bool {return self._downloadData != nil}
  /// Clears the value of `downloadData`. Subsequent reads from it will return its default value.
  mutating func clearDownloadData() {self._downloadData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Replay: Equatable {
    /// Limitation: might fail if the replay file is currently loaded.
    case replayPath(String)
    case replayData(Data)

  #if !swift(>=4.1)
    static func ==(lhs: SC2APIProtocol_RequestReplayInfo.OneOf_Replay, rhs: SC2APIProtocol_RequestReplayInfo.OneOf_Replay) -> Bool {
      switch (lhs, rhs) {
      case (.replayPath(let l), .replayPath(let r)): return l == r
      case (.replayData(let l), .replayData(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _downloadData: Bool? = nil
}

struct SC2APIProtocol_PlayerInfoExtra {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var playerInfo: SC2APIProtocol_PlayerInfo {
    get {return _storage._playerInfo ?? SC2APIProtocol_PlayerInfo()}
    set {_uniqueStorage()._playerInfo = newValue}
  }
  /// Returns true if `playerInfo` has been explicitly set.
  var hasPlayerInfo: Bool {return _storage._playerInfo != nil}
  /// Clears the value of `playerInfo`. Subsequent reads from it will return its default value.
  mutating func clearPlayerInfo() {_uniqueStorage()._playerInfo = nil}

  var playerResult: SC2APIProtocol_PlayerResult {
    get {return _storage._playerResult ?? SC2APIProtocol_PlayerResult()}
    set {_uniqueStorage()._playerResult = newValue}
  }
  /// Returns true if `playerResult` has been explicitly set.
  var hasPlayerResult: Bool {return _storage._playerResult != nil}
  /// Clears the value of `playerResult`. Subsequent reads from it will return its default value.
  mutating func clearPlayerResult() {_uniqueStorage()._playerResult = nil}

  var playerMmr: Int32 {
    get {return _storage._playerMmr ?? 0}
    set {_uniqueStorage()._playerMmr = newValue}
  }
  /// Returns true if `playerMmr` has been explicitly set.
  var hasPlayerMmr: Bool {return _storage._playerMmr != nil}
  /// Clears the value of `playerMmr`. Subsequent reads from it will return its default value.
  mutating func clearPlayerMmr() {_uniqueStorage()._playerMmr = nil}

  var playerApm: Int32 {
    get {return _storage._playerApm ?? 0}
    set {_uniqueStorage()._playerApm = newValue}
  }
  /// Returns true if `playerApm` has been explicitly set.
  var hasPlayerApm: Bool {return _storage._playerApm != nil}
  /// Clears the value of `playerApm`. Subsequent reads from it will return its default value.
  mutating func clearPlayerApm() {_uniqueStorage()._playerApm = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_ResponseReplayInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mapName: String {
    get {return _mapName ?? String()}
    set {_mapName = newValue}
  }
  /// Returns true if `mapName` has been explicitly set.
  var hasMapName: Bool {return self._mapName != nil}
  /// Clears the value of `mapName`. Subsequent reads from it will return its default value.
  mutating func clearMapName() {self._mapName = nil}

  var localMapPath: String {
    get {return _localMapPath ?? String()}
    set {_localMapPath = newValue}
  }
  /// Returns true if `localMapPath` has been explicitly set.
  var hasLocalMapPath: Bool {return self._localMapPath != nil}
  /// Clears the value of `localMapPath`. Subsequent reads from it will return its default value.
  mutating func clearLocalMapPath() {self._localMapPath = nil}

  var playerInfo: [SC2APIProtocol_PlayerInfoExtra] = []

  var gameDurationLoops: UInt32 {
    get {return _gameDurationLoops ?? 0}
    set {_gameDurationLoops = newValue}
  }
  /// Returns true if `gameDurationLoops` has been explicitly set.
  var hasGameDurationLoops: Bool {return self._gameDurationLoops != nil}
  /// Clears the value of `gameDurationLoops`. Subsequent reads from it will return its default value.
  mutating func clearGameDurationLoops() {self._gameDurationLoops = nil}

  var gameDurationSeconds: Float {
    get {return _gameDurationSeconds ?? 0}
    set {_gameDurationSeconds = newValue}
  }
  /// Returns true if `gameDurationSeconds` has been explicitly set.
  var hasGameDurationSeconds: Bool {return self._gameDurationSeconds != nil}
  /// Clears the value of `gameDurationSeconds`. Subsequent reads from it will return its default value.
  mutating func clearGameDurationSeconds() {self._gameDurationSeconds = nil}

  var gameVersion: String {
    get {return _gameVersion ?? String()}
    set {_gameVersion = newValue}
  }
  /// Returns true if `gameVersion` has been explicitly set.
  var hasGameVersion: Bool {return self._gameVersion != nil}
  /// Clears the value of `gameVersion`. Subsequent reads from it will return its default value.
  mutating func clearGameVersion() {self._gameVersion = nil}

  var dataVersion: String {
    get {return _dataVersion ?? String()}
    set {_dataVersion = newValue}
  }
  /// Returns true if `dataVersion` has been explicitly set.
  var hasDataVersion: Bool {return self._dataVersion != nil}
  /// Clears the value of `dataVersion`. Subsequent reads from it will return its default value.
  mutating func clearDataVersion() {self._dataVersion = nil}

  var dataBuild: UInt32 {
    get {return _dataBuild ?? 0}
    set {_dataBuild = newValue}
  }
  /// Returns true if `dataBuild` has been explicitly set.
  var hasDataBuild: Bool {return self._dataBuild != nil}
  /// Clears the value of `dataBuild`. Subsequent reads from it will return its default value.
  mutating func clearDataBuild() {self._dataBuild = nil}

  var baseBuild: UInt32 {
    get {return _baseBuild ?? 0}
    set {_baseBuild = newValue}
  }
  /// Returns true if `baseBuild` has been explicitly set.
  var hasBaseBuild: Bool {return self._baseBuild != nil}
  /// Clears the value of `baseBuild`. Subsequent reads from it will return its default value.
  mutating func clearBaseBuild() {self._baseBuild = nil}

  var error: SC2APIProtocol_ResponseReplayInfo.Error {
    get {return _error ?? .missingReplay}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var errorDetails: String {
    get {return _errorDetails ?? String()}
    set {_errorDetails = newValue}
  }
  /// Returns true if `errorDetails` has been explicitly set.
  var hasErrorDetails: Bool {return self._errorDetails != nil}
  /// Clears the value of `errorDetails`. Subsequent reads from it will return its default value.
  mutating func clearErrorDetails() {self._errorDetails = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Error: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case missingReplay // = 1
    case invalidReplayPath // = 2
    case invalidReplayData // = 3
    case parsingError // = 4
    case downloadError // = 5

    init() {
      self = .missingReplay
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .missingReplay
      case 2: self = .invalidReplayPath
      case 3: self = .invalidReplayData
      case 4: self = .parsingError
      case 5: self = .downloadError
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .missingReplay: return 1
      case .invalidReplayPath: return 2
      case .invalidReplayData: return 3
      case .parsingError: return 4
      case .downloadError: return 5
      }
    }

  }

  init() {}

  fileprivate var _mapName: String? = nil
  fileprivate var _localMapPath: String? = nil
  fileprivate var _gameDurationLoops: UInt32? = nil
  fileprivate var _gameDurationSeconds: Float? = nil
  fileprivate var _gameVersion: String? = nil
  fileprivate var _dataVersion: String? = nil
  fileprivate var _dataBuild: UInt32? = nil
  fileprivate var _baseBuild: UInt32? = nil
  fileprivate var _error: SC2APIProtocol_ResponseReplayInfo.Error? = nil
  fileprivate var _errorDetails: String? = nil
}

#if swift(>=4.2)

extension SC2APIProtocol_ResponseReplayInfo.Error: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///-----------------------------------------------------------------------------
struct SC2APIProtocol_RequestAvailableMaps {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// This will only contain locally cached BattleNet maps.
/// To download all ladder maps, log in and queue into a ladder match.
/// To download any other map, play a custom game on that map.
struct SC2APIProtocol_ResponseAvailableMaps {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// All the maps in the "Maps/" directory.
  var localMapPaths: [String] = []

  /// All the maps in the BattleNet cache.
  var battlenetMapNames: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///-----------------------------------------------------------------------------
/// Copies map data into the path specified.
struct SC2APIProtocol_RequestSaveMap {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Path the game process will write to, relative to the temp directory. (260 character max)
  var mapPath: String {
    get {return _mapPath ?? String()}
    set {_mapPath = newValue}
  }
  /// Returns true if `mapPath` has been explicitly set.
  var hasMapPath: Bool {return self._mapPath != nil}
  /// Clears the value of `mapPath`. Subsequent reads from it will return its default value.
  mutating func clearMapPath() {self._mapPath = nil}

  /// Binary map data of a .SC2Map.
  var mapData: Data {
    get {return _mapData ?? SwiftProtobuf.Internal.emptyData}
    set {_mapData = newValue}
  }
  /// Returns true if `mapData` has been explicitly set.
  var hasMapData: Bool {return self._mapData != nil}
  /// Clears the value of `mapData`. Subsequent reads from it will return its default value.
  mutating func clearMapData() {self._mapData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mapPath: String? = nil
  fileprivate var _mapData: Data? = nil
}

struct SC2APIProtocol_ResponseSaveMap {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: SC2APIProtocol_ResponseSaveMap.Error {
    get {return _error ?? .invalidMapData}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Error: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case invalidMapData // = 1

    init() {
      self = .invalidMapData
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .invalidMapData
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .invalidMapData: return 1
      }
    }

  }

  init() {}

  fileprivate var _error: SC2APIProtocol_ResponseSaveMap.Error? = nil
}

#if swift(>=4.2)

extension SC2APIProtocol_ResponseSaveMap.Error: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///-----------------------------------------------------------------------------
struct SC2APIProtocol_RequestPing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SC2APIProtocol_ResponsePing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gameVersion: String {
    get {return _gameVersion ?? String()}
    set {_gameVersion = newValue}
  }
  /// Returns true if `gameVersion` has been explicitly set.
  var hasGameVersion: Bool {return self._gameVersion != nil}
  /// Clears the value of `gameVersion`. Subsequent reads from it will return its default value.
  mutating func clearGameVersion() {self._gameVersion = nil}

  var dataVersion: String {
    get {return _dataVersion ?? String()}
    set {_dataVersion = newValue}
  }
  /// Returns true if `dataVersion` has been explicitly set.
  var hasDataVersion: Bool {return self._dataVersion != nil}
  /// Clears the value of `dataVersion`. Subsequent reads from it will return its default value.
  mutating func clearDataVersion() {self._dataVersion = nil}

  var dataBuild: UInt32 {
    get {return _dataBuild ?? 0}
    set {_dataBuild = newValue}
  }
  /// Returns true if `dataBuild` has been explicitly set.
  var hasDataBuild: Bool {return self._dataBuild != nil}
  /// Clears the value of `dataBuild`. Subsequent reads from it will return its default value.
  mutating func clearDataBuild() {self._dataBuild = nil}

  var baseBuild: UInt32 {
    get {return _baseBuild ?? 0}
    set {_baseBuild = newValue}
  }
  /// Returns true if `baseBuild` has been explicitly set.
  var hasBaseBuild: Bool {return self._baseBuild != nil}
  /// Clears the value of `baseBuild`. Subsequent reads from it will return its default value.
  mutating func clearBaseBuild() {self._baseBuild = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _gameVersion: String? = nil
  fileprivate var _dataVersion: String? = nil
  fileprivate var _dataBuild: UInt32? = nil
  fileprivate var _baseBuild: UInt32? = nil
}

///-----------------------------------------------------------------------------
struct SC2APIProtocol_RequestDebug {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var debug: [SC2APIProtocol_DebugCommand] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SC2APIProtocol_ResponseDebug {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SC2APIProtocol_PlayerSetup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: SC2APIProtocol_PlayerType {
    get {return _type ?? .participant}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  /// Only used for a computer player.
  var race: SC2APIProtocol_Race {
    get {return _race ?? .noRace}
    set {_race = newValue}
  }
  /// Returns true if `race` has been explicitly set.
  var hasRace: Bool {return self._race != nil}
  /// Clears the value of `race`. Subsequent reads from it will return its default value.
  mutating func clearRace() {self._race = nil}

  var difficulty: SC2APIProtocol_Difficulty {
    get {return _difficulty ?? .veryEasy}
    set {_difficulty = newValue}
  }
  /// Returns true if `difficulty` has been explicitly set.
  var hasDifficulty: Bool {return self._difficulty != nil}
  /// Clears the value of `difficulty`. Subsequent reads from it will return its default value.
  mutating func clearDifficulty() {self._difficulty = nil}

  var playerName: String {
    get {return _playerName ?? String()}
    set {_playerName = newValue}
  }
  /// Returns true if `playerName` has been explicitly set.
  var hasPlayerName: Bool {return self._playerName != nil}
  /// Clears the value of `playerName`. Subsequent reads from it will return its default value.
  mutating func clearPlayerName() {self._playerName = nil}

  var aiBuild: SC2APIProtocol_AIBuild {
    get {return _aiBuild ?? .randomBuild}
    set {_aiBuild = newValue}
  }
  /// Returns true if `aiBuild` has been explicitly set.
  var hasAiBuild: Bool {return self._aiBuild != nil}
  /// Clears the value of `aiBuild`. Subsequent reads from it will return its default value.
  mutating func clearAiBuild() {self._aiBuild = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _type: SC2APIProtocol_PlayerType? = nil
  fileprivate var _race: SC2APIProtocol_Race? = nil
  fileprivate var _difficulty: SC2APIProtocol_Difficulty? = nil
  fileprivate var _playerName: String? = nil
  fileprivate var _aiBuild: SC2APIProtocol_AIBuild? = nil
}

struct SC2APIProtocol_SpatialCameraSetup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var resolution: SC2APIProtocol_Size2DI {
    get {return _storage._resolution ?? SC2APIProtocol_Size2DI()}
    set {_uniqueStorage()._resolution = newValue}
  }
  /// Returns true if `resolution` has been explicitly set.
  var hasResolution: Bool {return _storage._resolution != nil}
  /// Clears the value of `resolution`. Subsequent reads from it will return its default value.
  mutating func clearResolution() {_uniqueStorage()._resolution = nil}

  var minimapResolution: SC2APIProtocol_Size2DI {
    get {return _storage._minimapResolution ?? SC2APIProtocol_Size2DI()}
    set {_uniqueStorage()._minimapResolution = newValue}
  }
  /// Returns true if `minimapResolution` has been explicitly set.
  var hasMinimapResolution: Bool {return _storage._minimapResolution != nil}
  /// Clears the value of `minimapResolution`. Subsequent reads from it will return its default value.
  mutating func clearMinimapResolution() {_uniqueStorage()._minimapResolution = nil}

  /// Below are only relevant for feature layers.
  var width: Float {
    get {return _storage._width ?? 0}
    set {_uniqueStorage()._width = newValue}
  }
  /// Returns true if `width` has been explicitly set.
  var hasWidth: Bool {return _storage._width != nil}
  /// Clears the value of `width`. Subsequent reads from it will return its default value.
  mutating func clearWidth() {_uniqueStorage()._width = nil}

  /// Crop minimap to the playable area.
  var cropToPlayableArea: Bool {
    get {return _storage._cropToPlayableArea ?? false}
    set {_uniqueStorage()._cropToPlayableArea = newValue}
  }
  /// Returns true if `cropToPlayableArea` has been explicitly set.
  var hasCropToPlayableArea: Bool {return _storage._cropToPlayableArea != nil}
  /// Clears the value of `cropToPlayableArea`. Subsequent reads from it will return its default value.
  mutating func clearCropToPlayableArea() {_uniqueStorage()._cropToPlayableArea = nil}

  /// Return unit_type on the minimap, and potentially other cheating layers.
  var allowCheatingLayers: Bool {
    get {return _storage._allowCheatingLayers ?? false}
    set {_uniqueStorage()._allowCheatingLayers = newValue}
  }
  /// Returns true if `allowCheatingLayers` has been explicitly set.
  var hasAllowCheatingLayers: Bool {return _storage._allowCheatingLayers != nil}
  /// Clears the value of `allowCheatingLayers`. Subsequent reads from it will return its default value.
  mutating func clearAllowCheatingLayers() {_uniqueStorage()._allowCheatingLayers = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_InterfaceOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Interface options
  var raw: Bool {
    get {return _storage._raw ?? false}
    set {_uniqueStorage()._raw = newValue}
  }
  /// Returns true if `raw` has been explicitly set.
  var hasRaw: Bool {return _storage._raw != nil}
  /// Clears the value of `raw`. Subsequent reads from it will return its default value.
  mutating func clearRaw() {_uniqueStorage()._raw = nil}

  var score: Bool {
    get {return _storage._score ?? false}
    set {_uniqueStorage()._score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  var hasScore: Bool {return _storage._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  mutating func clearScore() {_uniqueStorage()._score = nil}

  /// Omit to disable.
  var featureLayer: SC2APIProtocol_SpatialCameraSetup {
    get {return _storage._featureLayer ?? SC2APIProtocol_SpatialCameraSetup()}
    set {_uniqueStorage()._featureLayer = newValue}
  }
  /// Returns true if `featureLayer` has been explicitly set.
  var hasFeatureLayer: Bool {return _storage._featureLayer != nil}
  /// Clears the value of `featureLayer`. Subsequent reads from it will return its default value.
  mutating func clearFeatureLayer() {_uniqueStorage()._featureLayer = nil}

  /// Omit to disable.
  var render: SC2APIProtocol_SpatialCameraSetup {
    get {return _storage._render ?? SC2APIProtocol_SpatialCameraSetup()}
    set {_uniqueStorage()._render = newValue}
  }
  /// Returns true if `render` has been explicitly set.
  var hasRender: Bool {return _storage._render != nil}
  /// Clears the value of `render`. Subsequent reads from it will return its default value.
  mutating func clearRender() {_uniqueStorage()._render = nil}

  /// By default cloaked units are completely hidden. This shows some details.
  var showCloaked: Bool {
    get {return _storage._showCloaked ?? false}
    set {_uniqueStorage()._showCloaked = newValue}
  }
  /// Returns true if `showCloaked` has been explicitly set.
  var hasShowCloaked: Bool {return _storage._showCloaked != nil}
  /// Clears the value of `showCloaked`. Subsequent reads from it will return its default value.
  mutating func clearShowCloaked() {_uniqueStorage()._showCloaked = nil}

  /// By default burrowed units are completely hidden. This shows some details for those that produce a shadow.
  var showBurrowedShadows: Bool {
    get {return _storage._showBurrowedShadows ?? false}
    set {_uniqueStorage()._showBurrowedShadows = newValue}
  }
  /// Returns true if `showBurrowedShadows` has been explicitly set.
  var hasShowBurrowedShadows: Bool {return _storage._showBurrowedShadows != nil}
  /// Clears the value of `showBurrowedShadows`. Subsequent reads from it will return its default value.
  mutating func clearShowBurrowedShadows() {_uniqueStorage()._showBurrowedShadows = nil}

  /// Return placeholder units (buildings to be constructed), both for raw and feature layers.
  var showPlaceholders: Bool {
    get {return _storage._showPlaceholders ?? false}
    set {_uniqueStorage()._showPlaceholders = newValue}
  }
  /// Returns true if `showPlaceholders` has been explicitly set.
  var hasShowPlaceholders: Bool {return _storage._showPlaceholders != nil}
  /// Clears the value of `showPlaceholders`. Subsequent reads from it will return its default value.
  mutating func clearShowPlaceholders() {_uniqueStorage()._showPlaceholders = nil}

  /// By default raw actions select, act and revert the selection. This is useful
  /// if you're playing simultaneously with the agent so it doesn't steal your
  /// selection. This inflates APM (due to deselect) and makes the actions hard
  /// to follow in a replay. Setting this to true will cause raw actions to do
  /// select, act, but not revert the selection.
  var rawAffectsSelection: Bool {
    get {return _storage._rawAffectsSelection ?? false}
    set {_uniqueStorage()._rawAffectsSelection = newValue}
  }
  /// Returns true if `rawAffectsSelection` has been explicitly set.
  var hasRawAffectsSelection: Bool {return _storage._rawAffectsSelection != nil}
  /// Clears the value of `rawAffectsSelection`. Subsequent reads from it will return its default value.
  mutating func clearRawAffectsSelection() {_uniqueStorage()._rawAffectsSelection = nil}

  /// Changes the coordinates in raw.proto to be relative to the playable area.
  /// The map_size and playable_area will be the diagonal of the real playable area.
  var rawCropToPlayableArea: Bool {
    get {return _storage._rawCropToPlayableArea ?? false}
    set {_uniqueStorage()._rawCropToPlayableArea = newValue}
  }
  /// Returns true if `rawCropToPlayableArea` has been explicitly set.
  var hasRawCropToPlayableArea: Bool {return _storage._rawCropToPlayableArea != nil}
  /// Clears the value of `rawCropToPlayableArea`. Subsequent reads from it will return its default value.
  mutating func clearRawCropToPlayableArea() {_uniqueStorage()._rawCropToPlayableArea = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_PlayerInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identifier that will be used to reference this player.
  /// SC2 will always assign playerIds starting from 1 in standard Melee maps. This may not be true in custom maps.
  var playerID: UInt32 {
    get {return _playerID ?? 0}
    set {_playerID = newValue}
  }
  /// Returns true if `playerID` has been explicitly set.
  var hasPlayerID: Bool {return self._playerID != nil}
  /// Clears the value of `playerID`. Subsequent reads from it will return its default value.
  mutating func clearPlayerID() {self._playerID = nil}

  var type: SC2APIProtocol_PlayerType {
    get {return _type ?? .participant}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var raceRequested: SC2APIProtocol_Race {
    get {return _raceRequested ?? .noRace}
    set {_raceRequested = newValue}
  }
  /// Returns true if `raceRequested` has been explicitly set.
  var hasRaceRequested: Bool {return self._raceRequested != nil}
  /// Clears the value of `raceRequested`. Subsequent reads from it will return its default value.
  mutating func clearRaceRequested() {self._raceRequested = nil}

  /// Only populated for your player or when watching replay
  var raceActual: SC2APIProtocol_Race {
    get {return _raceActual ?? .noRace}
    set {_raceActual = newValue}
  }
  /// Returns true if `raceActual` has been explicitly set.
  var hasRaceActual: Bool {return self._raceActual != nil}
  /// Clears the value of `raceActual`. Subsequent reads from it will return its default value.
  mutating func clearRaceActual() {self._raceActual = nil}

  var difficulty: SC2APIProtocol_Difficulty {
    get {return _difficulty ?? .veryEasy}
    set {_difficulty = newValue}
  }
  /// Returns true if `difficulty` has been explicitly set.
  var hasDifficulty: Bool {return self._difficulty != nil}
  /// Clears the value of `difficulty`. Subsequent reads from it will return its default value.
  mutating func clearDifficulty() {self._difficulty = nil}

  var aiBuild: SC2APIProtocol_AIBuild {
    get {return _aiBuild ?? .randomBuild}
    set {_aiBuild = newValue}
  }
  /// Returns true if `aiBuild` has been explicitly set.
  var hasAiBuild: Bool {return self._aiBuild != nil}
  /// Clears the value of `aiBuild`. Subsequent reads from it will return its default value.
  mutating func clearAiBuild() {self._aiBuild = nil}

  var playerName: String {
    get {return _playerName ?? String()}
    set {_playerName = newValue}
  }
  /// Returns true if `playerName` has been explicitly set.
  var hasPlayerName: Bool {return self._playerName != nil}
  /// Clears the value of `playerName`. Subsequent reads from it will return its default value.
  mutating func clearPlayerName() {self._playerName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _playerID: UInt32? = nil
  fileprivate var _type: SC2APIProtocol_PlayerType? = nil
  fileprivate var _raceRequested: SC2APIProtocol_Race? = nil
  fileprivate var _raceActual: SC2APIProtocol_Race? = nil
  fileprivate var _difficulty: SC2APIProtocol_Difficulty? = nil
  fileprivate var _aiBuild: SC2APIProtocol_AIBuild? = nil
  fileprivate var _playerName: String? = nil
}

struct SC2APIProtocol_PlayerCommon {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var playerID: UInt32 {
    get {return _playerID ?? 0}
    set {_playerID = newValue}
  }
  /// Returns true if `playerID` has been explicitly set.
  var hasPlayerID: Bool {return self._playerID != nil}
  /// Clears the value of `playerID`. Subsequent reads from it will return its default value.
  mutating func clearPlayerID() {self._playerID = nil}

  var minerals: UInt32 {
    get {return _minerals ?? 0}
    set {_minerals = newValue}
  }
  /// Returns true if `minerals` has been explicitly set.
  var hasMinerals: Bool {return self._minerals != nil}
  /// Clears the value of `minerals`. Subsequent reads from it will return its default value.
  mutating func clearMinerals() {self._minerals = nil}

  var vespene: UInt32 {
    get {return _vespene ?? 0}
    set {_vespene = newValue}
  }
  /// Returns true if `vespene` has been explicitly set.
  var hasVespene: Bool {return self._vespene != nil}
  /// Clears the value of `vespene`. Subsequent reads from it will return its default value.
  mutating func clearVespene() {self._vespene = nil}

  var foodCap: UInt32 {
    get {return _foodCap ?? 0}
    set {_foodCap = newValue}
  }
  /// Returns true if `foodCap` has been explicitly set.
  var hasFoodCap: Bool {return self._foodCap != nil}
  /// Clears the value of `foodCap`. Subsequent reads from it will return its default value.
  mutating func clearFoodCap() {self._foodCap = nil}

  var foodUsed: UInt32 {
    get {return _foodUsed ?? 0}
    set {_foodUsed = newValue}
  }
  /// Returns true if `foodUsed` has been explicitly set.
  var hasFoodUsed: Bool {return self._foodUsed != nil}
  /// Clears the value of `foodUsed`. Subsequent reads from it will return its default value.
  mutating func clearFoodUsed() {self._foodUsed = nil}

  var foodArmy: UInt32 {
    get {return _foodArmy ?? 0}
    set {_foodArmy = newValue}
  }
  /// Returns true if `foodArmy` has been explicitly set.
  var hasFoodArmy: Bool {return self._foodArmy != nil}
  /// Clears the value of `foodArmy`. Subsequent reads from it will return its default value.
  mutating func clearFoodArmy() {self._foodArmy = nil}

  var foodWorkers: UInt32 {
    get {return _foodWorkers ?? 0}
    set {_foodWorkers = newValue}
  }
  /// Returns true if `foodWorkers` has been explicitly set.
  var hasFoodWorkers: Bool {return self._foodWorkers != nil}
  /// Clears the value of `foodWorkers`. Subsequent reads from it will return its default value.
  mutating func clearFoodWorkers() {self._foodWorkers = nil}

  var idleWorkerCount: UInt32 {
    get {return _idleWorkerCount ?? 0}
    set {_idleWorkerCount = newValue}
  }
  /// Returns true if `idleWorkerCount` has been explicitly set.
  var hasIdleWorkerCount: Bool {return self._idleWorkerCount != nil}
  /// Clears the value of `idleWorkerCount`. Subsequent reads from it will return its default value.
  mutating func clearIdleWorkerCount() {self._idleWorkerCount = nil}

  var armyCount: UInt32 {
    get {return _armyCount ?? 0}
    set {_armyCount = newValue}
  }
  /// Returns true if `armyCount` has been explicitly set.
  var hasArmyCount: Bool {return self._armyCount != nil}
  /// Clears the value of `armyCount`. Subsequent reads from it will return its default value.
  mutating func clearArmyCount() {self._armyCount = nil}

  var warpGateCount: UInt32 {
    get {return _warpGateCount ?? 0}
    set {_warpGateCount = newValue}
  }
  /// Returns true if `warpGateCount` has been explicitly set.
  var hasWarpGateCount: Bool {return self._warpGateCount != nil}
  /// Clears the value of `warpGateCount`. Subsequent reads from it will return its default value.
  mutating func clearWarpGateCount() {self._warpGateCount = nil}

  var larvaCount: UInt32 {
    get {return _larvaCount ?? 0}
    set {_larvaCount = newValue}
  }
  /// Returns true if `larvaCount` has been explicitly set.
  var hasLarvaCount: Bool {return self._larvaCount != nil}
  /// Clears the value of `larvaCount`. Subsequent reads from it will return its default value.
  mutating func clearLarvaCount() {self._larvaCount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _playerID: UInt32? = nil
  fileprivate var _minerals: UInt32? = nil
  fileprivate var _vespene: UInt32? = nil
  fileprivate var _foodCap: UInt32? = nil
  fileprivate var _foodUsed: UInt32? = nil
  fileprivate var _foodArmy: UInt32? = nil
  fileprivate var _foodWorkers: UInt32? = nil
  fileprivate var _idleWorkerCount: UInt32? = nil
  fileprivate var _armyCount: UInt32? = nil
  fileprivate var _warpGateCount: UInt32? = nil
  fileprivate var _larvaCount: UInt32? = nil
}

struct SC2APIProtocol_Observation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gameLoop: UInt32 {
    get {return _storage._gameLoop ?? 0}
    set {_uniqueStorage()._gameLoop = newValue}
  }
  /// Returns true if `gameLoop` has been explicitly set.
  var hasGameLoop: Bool {return _storage._gameLoop != nil}
  /// Clears the value of `gameLoop`. Subsequent reads from it will return its default value.
  mutating func clearGameLoop() {_uniqueStorage()._gameLoop = nil}

  var playerCommon: SC2APIProtocol_PlayerCommon {
    get {return _storage._playerCommon ?? SC2APIProtocol_PlayerCommon()}
    set {_uniqueStorage()._playerCommon = newValue}
  }
  /// Returns true if `playerCommon` has been explicitly set.
  var hasPlayerCommon: Bool {return _storage._playerCommon != nil}
  /// Clears the value of `playerCommon`. Subsequent reads from it will return its default value.
  mutating func clearPlayerCommon() {_uniqueStorage()._playerCommon = nil}

  var alerts: [SC2APIProtocol_Alert] {
    get {return _storage._alerts}
    set {_uniqueStorage()._alerts = newValue}
  }

  /// Abilities available in the selection. Enabled if in this list, disabled otherwise.
  var abilities: [SC2APIProtocol_AvailableAbility] {
    get {return _storage._abilities}
    set {_uniqueStorage()._abilities = newValue}
  }

  var score: SC2APIProtocol_Score {
    get {return _storage._score ?? SC2APIProtocol_Score()}
    set {_uniqueStorage()._score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  var hasScore: Bool {return _storage._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  mutating func clearScore() {_uniqueStorage()._score = nil}

  /// Populated if Raw interface is enabled.
  var rawData: SC2APIProtocol_ObservationRaw {
    get {return _storage._rawData ?? SC2APIProtocol_ObservationRaw()}
    set {_uniqueStorage()._rawData = newValue}
  }
  /// Returns true if `rawData` has been explicitly set.
  var hasRawData: Bool {return _storage._rawData != nil}
  /// Clears the value of `rawData`. Subsequent reads from it will return its default value.
  mutating func clearRawData() {_uniqueStorage()._rawData = nil}

  /// Populated if Feature Layer interface is enabled.
  var featureLayerData: SC2APIProtocol_ObservationFeatureLayer {
    get {return _storage._featureLayerData ?? SC2APIProtocol_ObservationFeatureLayer()}
    set {_uniqueStorage()._featureLayerData = newValue}
  }
  /// Returns true if `featureLayerData` has been explicitly set.
  var hasFeatureLayerData: Bool {return _storage._featureLayerData != nil}
  /// Clears the value of `featureLayerData`. Subsequent reads from it will return its default value.
  mutating func clearFeatureLayerData() {_uniqueStorage()._featureLayerData = nil}

  /// Populated if Render interface is enabled.
  var renderData: SC2APIProtocol_ObservationRender {
    get {return _storage._renderData ?? SC2APIProtocol_ObservationRender()}
    set {_uniqueStorage()._renderData = newValue}
  }
  /// Returns true if `renderData` has been explicitly set.
  var hasRenderData: Bool {return _storage._renderData != nil}
  /// Clears the value of `renderData`. Subsequent reads from it will return its default value.
  mutating func clearRenderData() {_uniqueStorage()._renderData = nil}

  /// Populated if Feature Layer or Render interface is enabled.
  var uiData: SC2APIProtocol_ObservationUI {
    get {return _storage._uiData ?? SC2APIProtocol_ObservationUI()}
    set {_uniqueStorage()._uiData = newValue}
  }
  /// Returns true if `uiData` has been explicitly set.
  var hasUiData: Bool {return _storage._uiData != nil}
  /// Clears the value of `uiData`. Subsequent reads from it will return its default value.
  mutating func clearUiData() {_uniqueStorage()._uiData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_Action {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Populated if Raw interface is enabled.
  var actionRaw: SC2APIProtocol_ActionRaw {
    get {return _storage._actionRaw ?? SC2APIProtocol_ActionRaw()}
    set {_uniqueStorage()._actionRaw = newValue}
  }
  /// Returns true if `actionRaw` has been explicitly set.
  var hasActionRaw: Bool {return _storage._actionRaw != nil}
  /// Clears the value of `actionRaw`. Subsequent reads from it will return its default value.
  mutating func clearActionRaw() {_uniqueStorage()._actionRaw = nil}

  /// Populated if Feature Layer interface is enabled.
  var actionFeatureLayer: SC2APIProtocol_ActionSpatial {
    get {return _storage._actionFeatureLayer ?? SC2APIProtocol_ActionSpatial()}
    set {_uniqueStorage()._actionFeatureLayer = newValue}
  }
  /// Returns true if `actionFeatureLayer` has been explicitly set.
  var hasActionFeatureLayer: Bool {return _storage._actionFeatureLayer != nil}
  /// Clears the value of `actionFeatureLayer`. Subsequent reads from it will return its default value.
  mutating func clearActionFeatureLayer() {_uniqueStorage()._actionFeatureLayer = nil}

  /// Not implemented. Populated if Render interface is enabled.
  var actionRender: SC2APIProtocol_ActionSpatial {
    get {return _storage._actionRender ?? SC2APIProtocol_ActionSpatial()}
    set {_uniqueStorage()._actionRender = newValue}
  }
  /// Returns true if `actionRender` has been explicitly set.
  var hasActionRender: Bool {return _storage._actionRender != nil}
  /// Clears the value of `actionRender`. Subsequent reads from it will return its default value.
  mutating func clearActionRender() {_uniqueStorage()._actionRender = nil}

  /// Populated if Feature Layer or Render interface is enabled.
  var actionUi: SC2APIProtocol_ActionUI {
    get {return _storage._actionUi ?? SC2APIProtocol_ActionUI()}
    set {_uniqueStorage()._actionUi = newValue}
  }
  /// Returns true if `actionUi` has been explicitly set.
  var hasActionUi: Bool {return _storage._actionUi != nil}
  /// Clears the value of `actionUi`. Subsequent reads from it will return its default value.
  mutating func clearActionUi() {_uniqueStorage()._actionUi = nil}

  /// Chat messages as a player typing into the chat channel.
  var actionChat: SC2APIProtocol_ActionChat {
    get {return _storage._actionChat ?? SC2APIProtocol_ActionChat()}
    set {_uniqueStorage()._actionChat = newValue}
  }
  /// Returns true if `actionChat` has been explicitly set.
  var hasActionChat: Bool {return _storage._actionChat != nil}
  /// Clears the value of `actionChat`. Subsequent reads from it will return its default value.
  mutating func clearActionChat() {_uniqueStorage()._actionChat = nil}

  /// Populated for actions in ResponseObservation. The game loop on which the action was executed.
  var gameLoop: UInt32 {
    get {return _storage._gameLoop ?? 0}
    set {_uniqueStorage()._gameLoop = newValue}
  }
  /// Returns true if `gameLoop` has been explicitly set.
  var hasGameLoop: Bool {return _storage._gameLoop != nil}
  /// Clears the value of `gameLoop`. Subsequent reads from it will return its default value.
  mutating func clearGameLoop() {_uniqueStorage()._gameLoop = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_ActionChat {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channel: SC2APIProtocol_ActionChat.Channel {
    get {return _channel ?? .broadcast}
    set {_channel = newValue}
  }
  /// Returns true if `channel` has been explicitly set.
  var hasChannel: Bool {return self._channel != nil}
  /// Clears the value of `channel`. Subsequent reads from it will return its default value.
  mutating func clearChannel() {self._channel = nil}

  var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {self._message = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Channel: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case broadcast // = 1
    case team // = 2

    init() {
      self = .broadcast
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .broadcast
      case 2: self = .team
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .broadcast: return 1
      case .team: return 2
      }
    }

  }

  init() {}

  fileprivate var _channel: SC2APIProtocol_ActionChat.Channel? = nil
  fileprivate var _message: String? = nil
}

#if swift(>=4.2)

extension SC2APIProtocol_ActionChat.Channel: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct SC2APIProtocol_ActionError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Only populated when using raw interface.
  var unitTag: UInt64 {
    get {return _unitTag ?? 0}
    set {_unitTag = newValue}
  }
  /// Returns true if `unitTag` has been explicitly set.
  var hasUnitTag: Bool {return self._unitTag != nil}
  /// Clears the value of `unitTag`. Subsequent reads from it will return its default value.
  mutating func clearUnitTag() {self._unitTag = nil}

  var abilityID: UInt64 {
    get {return _abilityID ?? 0}
    set {_abilityID = newValue}
  }
  /// Returns true if `abilityID` has been explicitly set.
  var hasAbilityID: Bool {return self._abilityID != nil}
  /// Clears the value of `abilityID`. Subsequent reads from it will return its default value.
  mutating func clearAbilityID() {self._abilityID = nil}

  var result: SC2APIProtocol_ActionResult {
    get {return _result ?? .success}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {self._result = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _unitTag: UInt64? = nil
  fileprivate var _abilityID: UInt64? = nil
  fileprivate var _result: SC2APIProtocol_ActionResult? = nil
}

struct SC2APIProtocol_ObserverAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var action: OneOf_Action? {
    get {return _storage._action}
    set {_uniqueStorage()._action = newValue}
  }

  /// Not implemented
  var playerPerspective: SC2APIProtocol_ActionObserverPlayerPerspective {
    get {
      if case .playerPerspective(let v)? = _storage._action {return v}
      return SC2APIProtocol_ActionObserverPlayerPerspective()
    }
    set {_uniqueStorage()._action = .playerPerspective(newValue)}
  }

  var cameraMove: SC2APIProtocol_ActionObserverCameraMove {
    get {
      if case .cameraMove(let v)? = _storage._action {return v}
      return SC2APIProtocol_ActionObserverCameraMove()
    }
    set {_uniqueStorage()._action = .cameraMove(newValue)}
  }

  var cameraFollowPlayer: SC2APIProtocol_ActionObserverCameraFollowPlayer {
    get {
      if case .cameraFollowPlayer(let v)? = _storage._action {return v}
      return SC2APIProtocol_ActionObserverCameraFollowPlayer()
    }
    set {_uniqueStorage()._action = .cameraFollowPlayer(newValue)}
  }

  /// Not implemented
  var cameraFollowUnits: SC2APIProtocol_ActionObserverCameraFollowUnits {
    get {
      if case .cameraFollowUnits(let v)? = _storage._action {return v}
      return SC2APIProtocol_ActionObserverCameraFollowUnits()
    }
    set {_uniqueStorage()._action = .cameraFollowUnits(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Action: Equatable {
    /// Not implemented
    case playerPerspective(SC2APIProtocol_ActionObserverPlayerPerspective)
    case cameraMove(SC2APIProtocol_ActionObserverCameraMove)
    case cameraFollowPlayer(SC2APIProtocol_ActionObserverCameraFollowPlayer)
    /// Not implemented
    case cameraFollowUnits(SC2APIProtocol_ActionObserverCameraFollowUnits)

  #if !swift(>=4.1)
    static func ==(lhs: SC2APIProtocol_ObserverAction.OneOf_Action, rhs: SC2APIProtocol_ObserverAction.OneOf_Action) -> Bool {
      switch (lhs, rhs) {
      case (.playerPerspective(let l), .playerPerspective(let r)): return l == r
      case (.cameraMove(let l), .cameraMove(let r)): return l == r
      case (.cameraFollowPlayer(let l), .cameraFollowPlayer(let r)): return l == r
      case (.cameraFollowUnits(let l), .cameraFollowUnits(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_ActionObserverPlayerPerspective {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 0 to observe "Everyone"
  var playerID: UInt32 {
    get {return _playerID ?? 0}
    set {_playerID = newValue}
  }
  /// Returns true if `playerID` has been explicitly set.
  var hasPlayerID: Bool {return self._playerID != nil}
  /// Clears the value of `playerID`. Subsequent reads from it will return its default value.
  mutating func clearPlayerID() {self._playerID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _playerID: UInt32? = nil
}

struct SC2APIProtocol_ActionObserverCameraMove {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var worldPos: SC2APIProtocol_Point2D {
    get {return _storage._worldPos ?? SC2APIProtocol_Point2D()}
    set {_uniqueStorage()._worldPos = newValue}
  }
  /// Returns true if `worldPos` has been explicitly set.
  var hasWorldPos: Bool {return _storage._worldPos != nil}
  /// Clears the value of `worldPos`. Subsequent reads from it will return its default value.
  mutating func clearWorldPos() {_uniqueStorage()._worldPos = nil}

  /// Distance between camera and terrain. Larger value zooms out camera.
  /// Defaults to standard camera distance if set to 0.
  var distance: Float {
    get {return _storage._distance ?? 0}
    set {_uniqueStorage()._distance = newValue}
  }
  /// Returns true if `distance` has been explicitly set.
  var hasDistance: Bool {return _storage._distance != nil}
  /// Clears the value of `distance`. Subsequent reads from it will return its default value.
  mutating func clearDistance() {_uniqueStorage()._distance = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_ActionObserverCameraFollowPlayer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Not implemented. Value must be [1, 15]
  var playerID: UInt32 {
    get {return _playerID ?? 0}
    set {_playerID = newValue}
  }
  /// Returns true if `playerID` has been explicitly set.
  var hasPlayerID: Bool {return self._playerID != nil}
  /// Clears the value of `playerID`. Subsequent reads from it will return its default value.
  mutating func clearPlayerID() {self._playerID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _playerID: UInt32? = nil
}

struct SC2APIProtocol_ActionObserverCameraFollowUnits {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unitTags: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SC2APIProtocol_PlayerResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var playerID: UInt32 {
    get {return _playerID ?? 0}
    set {_playerID = newValue}
  }
  /// Returns true if `playerID` has been explicitly set.
  var hasPlayerID: Bool {return self._playerID != nil}
  /// Clears the value of `playerID`. Subsequent reads from it will return its default value.
  mutating func clearPlayerID() {self._playerID = nil}

  var result: SC2APIProtocol_Result {
    get {return _result ?? .victory}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {self._result = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _playerID: UInt32? = nil
  fileprivate var _result: SC2APIProtocol_Result? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "SC2APIProtocol"

extension SC2APIProtocol_Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "launched"),
    2: .same(proto: "init_game"),
    3: .same(proto: "in_game"),
    4: .same(proto: "in_replay"),
    5: .same(proto: "ended"),
    6: .same(proto: "quit"),
    99: .same(proto: "unknown"),
  ]
}

extension SC2APIProtocol_Difficulty: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "VeryEasy"),
    2: .same(proto: "Easy"),
    3: .same(proto: "Medium"),
    4: .same(proto: "MediumHard"),
    5: .same(proto: "Hard"),
    6: .same(proto: "Harder"),
    7: .same(proto: "VeryHard"),
    8: .same(proto: "CheatVision"),
    9: .same(proto: "CheatMoney"),
    10: .same(proto: "CheatInsane"),
  ]
}

extension SC2APIProtocol_PlayerType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Participant"),
    2: .same(proto: "Computer"),
    3: .same(proto: "Observer"),
  ]
}

extension SC2APIProtocol_AIBuild: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "RandomBuild"),
    2: .same(proto: "Rush"),
    3: .same(proto: "Timing"),
    4: .same(proto: "Power"),
    5: .same(proto: "Macro"),
    6: .same(proto: "Air"),
  ]
}

extension SC2APIProtocol_Alert: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "NuclearLaunchDetected"),
    2: .same(proto: "NydusWormDetected"),
    3: .same(proto: "AlertError"),
    4: .same(proto: "AddOnComplete"),
    5: .same(proto: "BuildingComplete"),
    6: .same(proto: "BuildingUnderAttack"),
    7: .same(proto: "LarvaHatched"),
    8: .same(proto: "MergeComplete"),
    9: .same(proto: "MineralsExhausted"),
    10: .same(proto: "MorphComplete"),
    11: .same(proto: "MothershipComplete"),
    12: .same(proto: "MULEExpired"),
    13: .same(proto: "NukeComplete"),
    14: .same(proto: "ResearchComplete"),
    15: .same(proto: "TrainError"),
    16: .same(proto: "TrainUnitComplete"),
    17: .same(proto: "TrainWorkerComplete"),
    18: .same(proto: "TransformationComplete"),
    19: .same(proto: "UnitUnderAttack"),
    20: .same(proto: "UpgradeComplete"),
    21: .same(proto: "VespeneExhausted"),
    22: .same(proto: "WarpInComplete"),
  ]
}

extension SC2APIProtocol_Result: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Victory"),
    2: .same(proto: "Defeat"),
    3: .same(proto: "Tie"),
    4: .same(proto: "Undecided"),
  ]
}

extension SC2APIProtocol_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "create_game"),
    2: .standard(proto: "join_game"),
    3: .standard(proto: "restart_game"),
    4: .standard(proto: "start_replay"),
    5: .standard(proto: "leave_game"),
    6: .standard(proto: "quick_save"),
    7: .standard(proto: "quick_load"),
    8: .same(proto: "quit"),
    9: .standard(proto: "game_info"),
    10: .same(proto: "observation"),
    11: .same(proto: "action"),
    21: .standard(proto: "obs_action"),
    12: .same(proto: "step"),
    13: .same(proto: "data"),
    14: .same(proto: "query"),
    15: .standard(proto: "save_replay"),
    22: .standard(proto: "map_command"),
    16: .standard(proto: "replay_info"),
    17: .standard(proto: "available_maps"),
    18: .standard(proto: "save_map"),
    19: .same(proto: "ping"),
    20: .same(proto: "debug"),
    97: .same(proto: "id"),
  ]

  fileprivate class _StorageClass {
    var _request: SC2APIProtocol_Request.OneOf_Request?
    var _id: UInt32? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _request = source._request
      _id = source._id
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: SC2APIProtocol_RequestCreateGame?
          if let current = _storage._request {
            try decoder.handleConflictingOneOf()
            if case .createGame(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._request = .createGame(v)}
        case 2:
          var v: SC2APIProtocol_RequestJoinGame?
          if let current = _storage._request {
            try decoder.handleConflictingOneOf()
            if case .joinGame(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._request = .joinGame(v)}
        case 3:
          var v: SC2APIProtocol_RequestRestartGame?
          if let current = _storage._request {
            try decoder.handleConflictingOneOf()
            if case .restartGame(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._request = .restartGame(v)}
        case 4:
          var v: SC2APIProtocol_RequestStartReplay?
          if let current = _storage._request {
            try decoder.handleConflictingOneOf()
            if case .startReplay(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._request = .startReplay(v)}
        case 5:
          var v: SC2APIProtocol_RequestLeaveGame?
          if let current = _storage._request {
            try decoder.handleConflictingOneOf()
            if case .leaveGame(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._request = .leaveGame(v)}
        case 6:
          var v: SC2APIProtocol_RequestQuickSave?
          if let current = _storage._request {
            try decoder.handleConflictingOneOf()
            if case .quickSave(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._request = .quickSave(v)}
        case 7:
          var v: SC2APIProtocol_RequestQuickLoad?
          if let current = _storage._request {
            try decoder.handleConflictingOneOf()
            if case .quickLoad(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._request = .quickLoad(v)}
        case 8:
          var v: SC2APIProtocol_RequestQuit?
          if let current = _storage._request {
            try decoder.handleConflictingOneOf()
            if case .quit(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._request = .quit(v)}
        case 9:
          var v: SC2APIProtocol_RequestGameInfo?
          if let current = _storage._request {
            try decoder.handleConflictingOneOf()
            if case .gameInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._request = .gameInfo(v)}
        case 10:
          var v: SC2APIProtocol_RequestObservation?
          if let current = _storage._request {
            try decoder.handleConflictingOneOf()
            if case .observation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._request = .observation(v)}
        case 11:
          var v: SC2APIProtocol_RequestAction?
          if let current = _storage._request {
            try decoder.handleConflictingOneOf()
            if case .action(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._request = .action(v)}
        case 12:
          var v: SC2APIProtocol_RequestStep?
          if let current = _storage._request {
            try decoder.handleConflictingOneOf()
            if case .step(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._request = .step(v)}
        case 13:
          var v: SC2APIProtocol_RequestData?
          if let current = _storage._request {
            try decoder.handleConflictingOneOf()
            if case .data(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._request = .data(v)}
        case 14:
          var v: SC2APIProtocol_RequestQuery?
          if let current = _storage._request {
            try decoder.handleConflictingOneOf()
            if case .query(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._request = .query(v)}
        case 15:
          var v: SC2APIProtocol_RequestSaveReplay?
          if let current = _storage._request {
            try decoder.handleConflictingOneOf()
            if case .saveReplay(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._request = .saveReplay(v)}
        case 16:
          var v: SC2APIProtocol_RequestReplayInfo?
          if let current = _storage._request {
            try decoder.handleConflictingOneOf()
            if case .replayInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._request = .replayInfo(v)}
        case 17:
          var v: SC2APIProtocol_RequestAvailableMaps?
          if let current = _storage._request {
            try decoder.handleConflictingOneOf()
            if case .availableMaps(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._request = .availableMaps(v)}
        case 18:
          var v: SC2APIProtocol_RequestSaveMap?
          if let current = _storage._request {
            try decoder.handleConflictingOneOf()
            if case .saveMap(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._request = .saveMap(v)}
        case 19:
          var v: SC2APIProtocol_RequestPing?
          if let current = _storage._request {
            try decoder.handleConflictingOneOf()
            if case .ping(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._request = .ping(v)}
        case 20:
          var v: SC2APIProtocol_RequestDebug?
          if let current = _storage._request {
            try decoder.handleConflictingOneOf()
            if case .debug(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._request = .debug(v)}
        case 21:
          var v: SC2APIProtocol_RequestObserverAction?
          if let current = _storage._request {
            try decoder.handleConflictingOneOf()
            if case .obsAction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._request = .obsAction(v)}
        case 22:
          var v: SC2APIProtocol_RequestMapCommand?
          if let current = _storage._request {
            try decoder.handleConflictingOneOf()
            if case .mapCommand(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._request = .mapCommand(v)}
        case 97: try decoder.decodeSingularUInt32Field(value: &_storage._id)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._request {
      case .createGame(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .joinGame(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .restartGame(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .startReplay(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .leaveGame(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .quickSave(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .quickLoad(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .quit(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .gameInfo(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case .observation(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .action(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case .step(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .data(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .query(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .saveReplay(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .replayInfo(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .availableMaps(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case .saveMap(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      case .ping(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      case .debug(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      case .obsAction(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      case .mapCommand(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      case nil: break
      }
      if let v = _storage._id {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 97)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_Request, rhs: SC2APIProtocol_Request) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._request != rhs_storage._request {return false}
        if _storage._id != rhs_storage._id {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "create_game"),
    2: .standard(proto: "join_game"),
    3: .standard(proto: "restart_game"),
    4: .standard(proto: "start_replay"),
    5: .standard(proto: "leave_game"),
    6: .standard(proto: "quick_save"),
    7: .standard(proto: "quick_load"),
    8: .same(proto: "quit"),
    9: .standard(proto: "game_info"),
    10: .same(proto: "observation"),
    11: .same(proto: "action"),
    21: .standard(proto: "obs_action"),
    12: .same(proto: "step"),
    13: .same(proto: "data"),
    14: .same(proto: "query"),
    15: .standard(proto: "save_replay"),
    16: .standard(proto: "replay_info"),
    17: .standard(proto: "available_maps"),
    18: .standard(proto: "save_map"),
    22: .standard(proto: "map_command"),
    19: .same(proto: "ping"),
    20: .same(proto: "debug"),
    97: .same(proto: "id"),
    98: .same(proto: "error"),
    99: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _response: SC2APIProtocol_Response.OneOf_Response?
    var _id: UInt32? = nil
    var _error: [String] = []
    var _status: SC2APIProtocol_Status? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _response = source._response
      _id = source._id
      _error = source._error
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: SC2APIProtocol_ResponseCreateGame?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .createGame(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .createGame(v)}
        case 2:
          var v: SC2APIProtocol_ResponseJoinGame?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .joinGame(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .joinGame(v)}
        case 3:
          var v: SC2APIProtocol_ResponseRestartGame?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .restartGame(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .restartGame(v)}
        case 4:
          var v: SC2APIProtocol_ResponseStartReplay?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .startReplay(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .startReplay(v)}
        case 5:
          var v: SC2APIProtocol_ResponseLeaveGame?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .leaveGame(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .leaveGame(v)}
        case 6:
          var v: SC2APIProtocol_ResponseQuickSave?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .quickSave(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .quickSave(v)}
        case 7:
          var v: SC2APIProtocol_ResponseQuickLoad?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .quickLoad(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .quickLoad(v)}
        case 8:
          var v: SC2APIProtocol_ResponseQuit?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .quit(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .quit(v)}
        case 9:
          var v: SC2APIProtocol_ResponseGameInfo?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .gameInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .gameInfo(v)}
        case 10:
          var v: SC2APIProtocol_ResponseObservation?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .observation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .observation(v)}
        case 11:
          var v: SC2APIProtocol_ResponseAction?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .action(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .action(v)}
        case 12:
          var v: SC2APIProtocol_ResponseStep?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .step(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .step(v)}
        case 13:
          var v: SC2APIProtocol_ResponseData?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .data(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .data(v)}
        case 14:
          var v: SC2APIProtocol_ResponseQuery?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .query(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .query(v)}
        case 15:
          var v: SC2APIProtocol_ResponseSaveReplay?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .saveReplay(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .saveReplay(v)}
        case 16:
          var v: SC2APIProtocol_ResponseReplayInfo?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .replayInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .replayInfo(v)}
        case 17:
          var v: SC2APIProtocol_ResponseAvailableMaps?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .availableMaps(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .availableMaps(v)}
        case 18:
          var v: SC2APIProtocol_ResponseSaveMap?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .saveMap(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .saveMap(v)}
        case 19:
          var v: SC2APIProtocol_ResponsePing?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .ping(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .ping(v)}
        case 20:
          var v: SC2APIProtocol_ResponseDebug?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .debug(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .debug(v)}
        case 21:
          var v: SC2APIProtocol_ResponseObserverAction?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .obsAction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .obsAction(v)}
        case 22:
          var v: SC2APIProtocol_ResponseMapCommand?
          if let current = _storage._response {
            try decoder.handleConflictingOneOf()
            if case .mapCommand(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._response = .mapCommand(v)}
        case 97: try decoder.decodeSingularUInt32Field(value: &_storage._id)
        case 98: try decoder.decodeRepeatedStringField(value: &_storage._error)
        case 99: try decoder.decodeSingularEnumField(value: &_storage._status)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._response {
      case .createGame(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .joinGame(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .restartGame(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .startReplay(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .leaveGame(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .quickSave(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .quickLoad(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .quit(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .gameInfo(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case .observation(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .action(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case .step(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .data(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .query(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .saveReplay(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .replayInfo(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .availableMaps(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case .saveMap(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      case .ping(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      case .debug(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      case .obsAction(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      case .mapCommand(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      case nil: break
      }
      if let v = _storage._id {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 97)
      }
      if !_storage._error.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._error, fieldNumber: 98)
      }
      if let v = _storage._status {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 99)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_Response, rhs: SC2APIProtocol_Response) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._response != rhs_storage._response {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._error != rhs_storage._error {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_RequestCreateGame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestCreateGame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "local_map"),
    2: .standard(proto: "battlenet_map_name"),
    3: .standard(proto: "player_setup"),
    4: .standard(proto: "disable_fog"),
    5: .standard(proto: "random_seed"),
    6: .same(proto: "realtime"),
  ]

  fileprivate class _StorageClass {
    var _map: SC2APIProtocol_RequestCreateGame.OneOf_Map?
    var _playerSetup: [SC2APIProtocol_PlayerSetup] = []
    var _disableFog: Bool? = nil
    var _randomSeed: UInt32? = nil
    var _realtime: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _map = source._map
      _playerSetup = source._playerSetup
      _disableFog = source._disableFog
      _randomSeed = source._randomSeed
      _realtime = source._realtime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: SC2APIProtocol_LocalMap?
          if let current = _storage._map {
            try decoder.handleConflictingOneOf()
            if case .localMap(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._map = .localMap(v)}
        case 2:
          if _storage._map != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._map = .battlenetMapName(v)}
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._playerSetup)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._disableFog)
        case 5: try decoder.decodeSingularUInt32Field(value: &_storage._randomSeed)
        case 6: try decoder.decodeSingularBoolField(value: &_storage._realtime)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._map {
      case .localMap(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .battlenetMapName(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      case nil: break
      }
      if !_storage._playerSetup.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._playerSetup, fieldNumber: 3)
      }
      if let v = _storage._disableFog {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      }
      if let v = _storage._randomSeed {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
      }
      if let v = _storage._realtime {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_RequestCreateGame, rhs: SC2APIProtocol_RequestCreateGame) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._map != rhs_storage._map {return false}
        if _storage._playerSetup != rhs_storage._playerSetup {return false}
        if _storage._disableFog != rhs_storage._disableFog {return false}
        if _storage._randomSeed != rhs_storage._randomSeed {return false}
        if _storage._realtime != rhs_storage._realtime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_LocalMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LocalMap"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "map_path"),
    7: .standard(proto: "map_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._mapPath)
      case 7: try decoder.decodeSingularBytesField(value: &self._mapData)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mapPath {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._mapData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_LocalMap, rhs: SC2APIProtocol_LocalMap) -> Bool {
    if lhs._mapPath != rhs._mapPath {return false}
    if lhs._mapData != rhs._mapData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponseCreateGame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseCreateGame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .standard(proto: "error_details"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._error)
      case 2: try decoder.decodeSingularStringField(value: &self._errorDetails)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._error {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._errorDetails {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ResponseCreateGame, rhs: SC2APIProtocol_ResponseCreateGame) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._errorDetails != rhs._errorDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponseCreateGame.Error: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "MissingMap"),
    2: .same(proto: "InvalidMapPath"),
    3: .same(proto: "InvalidMapData"),
    4: .same(proto: "InvalidMapName"),
    5: .same(proto: "InvalidMapHandle"),
    6: .same(proto: "MissingPlayerSetup"),
    7: .same(proto: "InvalidPlayerSetup"),
    8: .same(proto: "MultiplayerUnsupported"),
  ]
}

extension SC2APIProtocol_RequestJoinGame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestJoinGame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "race"),
    2: .standard(proto: "observed_player_id"),
    3: .same(proto: "options"),
    4: .standard(proto: "server_ports"),
    5: .standard(proto: "client_ports"),
    6: .standard(proto: "shared_port"),
    7: .standard(proto: "player_name"),
    8: .standard(proto: "host_ip"),
  ]

  fileprivate class _StorageClass {
    var _participation: SC2APIProtocol_RequestJoinGame.OneOf_Participation?
    var _options: SC2APIProtocol_InterfaceOptions? = nil
    var _serverPorts: SC2APIProtocol_PortSet? = nil
    var _clientPorts: [SC2APIProtocol_PortSet] = []
    var _sharedPort: Int32? = nil
    var _playerName: String? = nil
    var _hostIp: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _participation = source._participation
      _options = source._options
      _serverPorts = source._serverPorts
      _clientPorts = source._clientPorts
      _sharedPort = source._sharedPort
      _playerName = source._playerName
      _hostIp = source._hostIp
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if _storage._participation != nil {try decoder.handleConflictingOneOf()}
          var v: SC2APIProtocol_Race?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {_storage._participation = .race(v)}
        case 2:
          if _storage._participation != nil {try decoder.handleConflictingOneOf()}
          var v: UInt32?
          try decoder.decodeSingularUInt32Field(value: &v)
          if let v = v {_storage._participation = .observedPlayerID(v)}
        case 3: try decoder.decodeSingularMessageField(value: &_storage._options)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._serverPorts)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._clientPorts)
        case 6: try decoder.decodeSingularInt32Field(value: &_storage._sharedPort)
        case 7: try decoder.decodeSingularStringField(value: &_storage._playerName)
        case 8: try decoder.decodeSingularStringField(value: &_storage._hostIp)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._participation {
      case .race(let v)?:
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      case .observedPlayerID(let v)?:
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
      case nil: break
      }
      if let v = _storage._options {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._serverPorts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._clientPorts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._clientPorts, fieldNumber: 5)
      }
      if let v = _storage._sharedPort {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
      }
      if let v = _storage._playerName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      }
      if let v = _storage._hostIp {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_RequestJoinGame, rhs: SC2APIProtocol_RequestJoinGame) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._participation != rhs_storage._participation {return false}
        if _storage._options != rhs_storage._options {return false}
        if _storage._serverPorts != rhs_storage._serverPorts {return false}
        if _storage._clientPorts != rhs_storage._clientPorts {return false}
        if _storage._sharedPort != rhs_storage._sharedPort {return false}
        if _storage._playerName != rhs_storage._playerName {return false}
        if _storage._hostIp != rhs_storage._hostIp {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_PortSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PortSet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "game_port"),
    2: .standard(proto: "base_port"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self._gamePort)
      case 2: try decoder.decodeSingularInt32Field(value: &self._basePort)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._gamePort {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._basePort {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_PortSet, rhs: SC2APIProtocol_PortSet) -> Bool {
    if lhs._gamePort != rhs._gamePort {return false}
    if lhs._basePort != rhs._basePort {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponseJoinGame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseJoinGame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "player_id"),
    2: .same(proto: "error"),
    3: .standard(proto: "error_details"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self._playerID)
      case 2: try decoder.decodeSingularEnumField(value: &self._error)
      case 3: try decoder.decodeSingularStringField(value: &self._errorDetails)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._playerID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._error {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }
    if let v = self._errorDetails {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ResponseJoinGame, rhs: SC2APIProtocol_ResponseJoinGame) -> Bool {
    if lhs._playerID != rhs._playerID {return false}
    if lhs._error != rhs._error {return false}
    if lhs._errorDetails != rhs._errorDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponseJoinGame.Error: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "MissingParticipation"),
    2: .same(proto: "InvalidObservedPlayerId"),
    3: .same(proto: "MissingOptions"),
    4: .same(proto: "MissingPorts"),
    5: .same(proto: "GameFull"),
    6: .same(proto: "LaunchError"),
    7: .same(proto: "FeatureUnsupported"),
    8: .same(proto: "NoSpaceForUser"),
    9: .same(proto: "MapDoesNotExist"),
    10: .same(proto: "CannotOpenMap"),
    11: .same(proto: "ChecksumError"),
    12: .same(proto: "NetworkError"),
    13: .same(proto: "OtherError"),
  ]
}

extension SC2APIProtocol_RequestRestartGame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestRestartGame"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_RequestRestartGame, rhs: SC2APIProtocol_RequestRestartGame) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponseRestartGame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseRestartGame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .standard(proto: "error_details"),
    3: .standard(proto: "need_hard_reset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._error)
      case 2: try decoder.decodeSingularStringField(value: &self._errorDetails)
      case 3: try decoder.decodeSingularBoolField(value: &self._needHardReset)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._error {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._errorDetails {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._needHardReset {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ResponseRestartGame, rhs: SC2APIProtocol_ResponseRestartGame) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._errorDetails != rhs._errorDetails {return false}
    if lhs._needHardReset != rhs._needHardReset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponseRestartGame.Error: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "LaunchError"),
  ]
}

extension SC2APIProtocol_RequestStartReplay: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestStartReplay"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "replay_path"),
    5: .standard(proto: "replay_data"),
    6: .standard(proto: "map_data"),
    2: .standard(proto: "observed_player_id"),
    3: .same(proto: "options"),
    4: .standard(proto: "disable_fog"),
    7: .same(proto: "realtime"),
    8: .standard(proto: "record_replay"),
  ]

  fileprivate class _StorageClass {
    var _replay: SC2APIProtocol_RequestStartReplay.OneOf_Replay?
    var _mapData: Data? = nil
    var _observedPlayerID: Int32? = nil
    var _options: SC2APIProtocol_InterfaceOptions? = nil
    var _disableFog: Bool? = nil
    var _realtime: Bool? = nil
    var _recordReplay: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _replay = source._replay
      _mapData = source._mapData
      _observedPlayerID = source._observedPlayerID
      _options = source._options
      _disableFog = source._disableFog
      _realtime = source._realtime
      _recordReplay = source._recordReplay
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if _storage._replay != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._replay = .replayPath(v)}
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._observedPlayerID)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._options)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._disableFog)
        case 5:
          if _storage._replay != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._replay = .replayData(v)}
        case 6: try decoder.decodeSingularBytesField(value: &_storage._mapData)
        case 7: try decoder.decodeSingularBoolField(value: &_storage._realtime)
        case 8: try decoder.decodeSingularBoolField(value: &_storage._recordReplay)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if case .replayPath(let v)? = _storage._replay {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._observedPlayerID {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
      }
      if let v = _storage._options {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._disableFog {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      }
      if case .replayData(let v)? = _storage._replay {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
      }
      if let v = _storage._mapData {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
      }
      if let v = _storage._realtime {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      }
      if let v = _storage._recordReplay {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_RequestStartReplay, rhs: SC2APIProtocol_RequestStartReplay) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._replay != rhs_storage._replay {return false}
        if _storage._mapData != rhs_storage._mapData {return false}
        if _storage._observedPlayerID != rhs_storage._observedPlayerID {return false}
        if _storage._options != rhs_storage._options {return false}
        if _storage._disableFog != rhs_storage._disableFog {return false}
        if _storage._realtime != rhs_storage._realtime {return false}
        if _storage._recordReplay != rhs_storage._recordReplay {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponseStartReplay: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseStartReplay"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .standard(proto: "error_details"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._error)
      case 2: try decoder.decodeSingularStringField(value: &self._errorDetails)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._error {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._errorDetails {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ResponseStartReplay, rhs: SC2APIProtocol_ResponseStartReplay) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._errorDetails != rhs._errorDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponseStartReplay.Error: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "MissingReplay"),
    2: .same(proto: "InvalidReplayPath"),
    3: .same(proto: "InvalidReplayData"),
    4: .same(proto: "InvalidMapData"),
    5: .same(proto: "InvalidObservedPlayerId"),
    6: .same(proto: "MissingOptions"),
    7: .same(proto: "LaunchError"),
  ]
}

extension SC2APIProtocol_RequestMapCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestMapCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trigger_cmd"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._triggerCmd)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._triggerCmd {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_RequestMapCommand, rhs: SC2APIProtocol_RequestMapCommand) -> Bool {
    if lhs._triggerCmd != rhs._triggerCmd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponseMapCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseMapCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .standard(proto: "error_details"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._error)
      case 2: try decoder.decodeSingularStringField(value: &self._errorDetails)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._error {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._errorDetails {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ResponseMapCommand, rhs: SC2APIProtocol_ResponseMapCommand) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs._errorDetails != rhs._errorDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponseMapCommand.Error: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "NoTriggerError"),
  ]
}

extension SC2APIProtocol_RequestLeaveGame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestLeaveGame"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_RequestLeaveGame, rhs: SC2APIProtocol_RequestLeaveGame) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponseLeaveGame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseLeaveGame"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ResponseLeaveGame, rhs: SC2APIProtocol_ResponseLeaveGame) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_RequestQuickSave: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestQuickSave"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_RequestQuickSave, rhs: SC2APIProtocol_RequestQuickSave) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponseQuickSave: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseQuickSave"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ResponseQuickSave, rhs: SC2APIProtocol_ResponseQuickSave) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_RequestQuickLoad: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestQuickLoad"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_RequestQuickLoad, rhs: SC2APIProtocol_RequestQuickLoad) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponseQuickLoad: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseQuickLoad"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ResponseQuickLoad, rhs: SC2APIProtocol_ResponseQuickLoad) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_RequestQuit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestQuit"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_RequestQuit, rhs: SC2APIProtocol_RequestQuit) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponseQuit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseQuit"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ResponseQuit, rhs: SC2APIProtocol_ResponseQuit) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_RequestGameInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestGameInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_RequestGameInfo, rhs: SC2APIProtocol_RequestGameInfo) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponseGameInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseGameInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "map_name"),
    6: .standard(proto: "mod_names"),
    2: .standard(proto: "local_map_path"),
    3: .standard(proto: "player_info"),
    4: .standard(proto: "start_raw"),
    5: .same(proto: "options"),
  ]

  fileprivate class _StorageClass {
    var _mapName: String? = nil
    var _modNames: [String] = []
    var _localMapPath: String? = nil
    var _playerInfo: [SC2APIProtocol_PlayerInfo] = []
    var _startRaw: SC2APIProtocol_StartRaw? = nil
    var _options: SC2APIProtocol_InterfaceOptions? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _mapName = source._mapName
      _modNames = source._modNames
      _localMapPath = source._localMapPath
      _playerInfo = source._playerInfo
      _startRaw = source._startRaw
      _options = source._options
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._mapName)
        case 2: try decoder.decodeSingularStringField(value: &_storage._localMapPath)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._playerInfo)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._startRaw)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._options)
        case 6: try decoder.decodeRepeatedStringField(value: &_storage._modNames)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._mapName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._localMapPath {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if !_storage._playerInfo.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._playerInfo, fieldNumber: 3)
      }
      if let v = _storage._startRaw {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._options {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._modNames.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._modNames, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ResponseGameInfo, rhs: SC2APIProtocol_ResponseGameInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._mapName != rhs_storage._mapName {return false}
        if _storage._modNames != rhs_storage._modNames {return false}
        if _storage._localMapPath != rhs_storage._localMapPath {return false}
        if _storage._playerInfo != rhs_storage._playerInfo {return false}
        if _storage._startRaw != rhs_storage._startRaw {return false}
        if _storage._options != rhs_storage._options {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_RequestObservation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestObservation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "disable_fog"),
    2: .standard(proto: "game_loop"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self._disableFog)
      case 2: try decoder.decodeSingularUInt32Field(value: &self._gameLoop)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._disableFog {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }
    if let v = self._gameLoop {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_RequestObservation, rhs: SC2APIProtocol_RequestObservation) -> Bool {
    if lhs._disableFog != rhs._disableFog {return false}
    if lhs._gameLoop != rhs._gameLoop {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponseObservation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseObservation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "actions"),
    2: .standard(proto: "action_errors"),
    3: .same(proto: "observation"),
    4: .standard(proto: "player_result"),
    5: .same(proto: "chat"),
  ]

  fileprivate class _StorageClass {
    var _actions: [SC2APIProtocol_Action] = []
    var _actionErrors: [SC2APIProtocol_ActionError] = []
    var _observation: SC2APIProtocol_Observation? = nil
    var _playerResult: [SC2APIProtocol_PlayerResult] = []
    var _chat: [SC2APIProtocol_ChatReceived] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _actions = source._actions
      _actionErrors = source._actionErrors
      _observation = source._observation
      _playerResult = source._playerResult
      _chat = source._chat
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._actions)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._actionErrors)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._observation)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._playerResult)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._chat)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._actions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._actions, fieldNumber: 1)
      }
      if !_storage._actionErrors.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._actionErrors, fieldNumber: 2)
      }
      if let v = _storage._observation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._playerResult.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._playerResult, fieldNumber: 4)
      }
      if !_storage._chat.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._chat, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ResponseObservation, rhs: SC2APIProtocol_ResponseObservation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._actions != rhs_storage._actions {return false}
        if _storage._actionErrors != rhs_storage._actionErrors {return false}
        if _storage._observation != rhs_storage._observation {return false}
        if _storage._playerResult != rhs_storage._playerResult {return false}
        if _storage._chat != rhs_storage._chat {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ChatReceived: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChatReceived"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "player_id"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self._playerID)
      case 2: try decoder.decodeSingularStringField(value: &self._message)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._playerID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ChatReceived, rhs: SC2APIProtocol_ChatReceived) -> Bool {
    if lhs._playerID != rhs._playerID {return false}
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_RequestAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "actions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.actions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_RequestAction, rhs: SC2APIProtocol_RequestAction) -> Bool {
    if lhs.actions != rhs.actions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponseAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedEnumField(value: &self.result)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.result.isEmpty {
      try visitor.visitRepeatedEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ResponseAction, rhs: SC2APIProtocol_ResponseAction) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_RequestObserverAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestObserverAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "actions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.actions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_RequestObserverAction, rhs: SC2APIProtocol_RequestObserverAction) -> Bool {
    if lhs.actions != rhs.actions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponseObserverAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseObserverAction"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ResponseObserverAction, rhs: SC2APIProtocol_ResponseObserverAction) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_RequestStep: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestStep"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self._count)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._count {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_RequestStep, rhs: SC2APIProtocol_RequestStep) -> Bool {
    if lhs._count != rhs._count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponseStep: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseStep"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "simulation_loop"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self._simulationLoop)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._simulationLoop {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ResponseStep, rhs: SC2APIProtocol_ResponseStep) -> Bool {
    if lhs._simulationLoop != rhs._simulationLoop {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_RequestData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ability_id"),
    2: .standard(proto: "unit_type_id"),
    3: .standard(proto: "upgrade_id"),
    4: .standard(proto: "buff_id"),
    5: .standard(proto: "effect_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self._abilityID)
      case 2: try decoder.decodeSingularBoolField(value: &self._unitTypeID)
      case 3: try decoder.decodeSingularBoolField(value: &self._upgradeID)
      case 4: try decoder.decodeSingularBoolField(value: &self._buffID)
      case 5: try decoder.decodeSingularBoolField(value: &self._effectID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._abilityID {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }
    if let v = self._unitTypeID {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    if let v = self._upgradeID {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    if let v = self._buffID {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    if let v = self._effectID {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_RequestData, rhs: SC2APIProtocol_RequestData) -> Bool {
    if lhs._abilityID != rhs._abilityID {return false}
    if lhs._unitTypeID != rhs._unitTypeID {return false}
    if lhs._upgradeID != rhs._upgradeID {return false}
    if lhs._buffID != rhs._buffID {return false}
    if lhs._effectID != rhs._effectID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponseData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "abilities"),
    2: .same(proto: "units"),
    3: .same(proto: "upgrades"),
    4: .same(proto: "buffs"),
    5: .same(proto: "effects"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.abilities)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.units)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.upgrades)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.buffs)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.effects)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.abilities.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.abilities, fieldNumber: 1)
    }
    if !self.units.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.units, fieldNumber: 2)
    }
    if !self.upgrades.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.upgrades, fieldNumber: 3)
    }
    if !self.buffs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.buffs, fieldNumber: 4)
    }
    if !self.effects.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.effects, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ResponseData, rhs: SC2APIProtocol_ResponseData) -> Bool {
    if lhs.abilities != rhs.abilities {return false}
    if lhs.units != rhs.units {return false}
    if lhs.upgrades != rhs.upgrades {return false}
    if lhs.buffs != rhs.buffs {return false}
    if lhs.effects != rhs.effects {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_RequestSaveReplay: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestSaveReplay"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_RequestSaveReplay, rhs: SC2APIProtocol_RequestSaveReplay) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponseSaveReplay: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseSaveReplay"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self._data)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._data {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ResponseSaveReplay, rhs: SC2APIProtocol_ResponseSaveReplay) -> Bool {
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_RequestReplayInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestReplayInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "replay_path"),
    2: .standard(proto: "replay_data"),
    3: .standard(proto: "download_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        if self.replay != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.replay = .replayPath(v)}
      case 2:
        if self.replay != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.replay = .replayData(v)}
      case 3: try decoder.decodeSingularBoolField(value: &self._downloadData)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.replay {
    case .replayPath(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    case .replayData(let v)?:
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    case nil: break
    }
    if let v = self._downloadData {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_RequestReplayInfo, rhs: SC2APIProtocol_RequestReplayInfo) -> Bool {
    if lhs.replay != rhs.replay {return false}
    if lhs._downloadData != rhs._downloadData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_PlayerInfoExtra: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayerInfoExtra"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "player_info"),
    2: .standard(proto: "player_result"),
    3: .standard(proto: "player_mmr"),
    4: .standard(proto: "player_apm"),
  ]

  fileprivate class _StorageClass {
    var _playerInfo: SC2APIProtocol_PlayerInfo? = nil
    var _playerResult: SC2APIProtocol_PlayerResult? = nil
    var _playerMmr: Int32? = nil
    var _playerApm: Int32? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _playerInfo = source._playerInfo
      _playerResult = source._playerResult
      _playerMmr = source._playerMmr
      _playerApm = source._playerApm
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._playerInfo)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._playerResult)
        case 3: try decoder.decodeSingularInt32Field(value: &_storage._playerMmr)
        case 4: try decoder.decodeSingularInt32Field(value: &_storage._playerApm)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._playerInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._playerResult {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._playerMmr {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
      }
      if let v = _storage._playerApm {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_PlayerInfoExtra, rhs: SC2APIProtocol_PlayerInfoExtra) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._playerInfo != rhs_storage._playerInfo {return false}
        if _storage._playerResult != rhs_storage._playerResult {return false}
        if _storage._playerMmr != rhs_storage._playerMmr {return false}
        if _storage._playerApm != rhs_storage._playerApm {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponseReplayInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseReplayInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "map_name"),
    2: .standard(proto: "local_map_path"),
    3: .standard(proto: "player_info"),
    4: .standard(proto: "game_duration_loops"),
    5: .standard(proto: "game_duration_seconds"),
    6: .standard(proto: "game_version"),
    11: .standard(proto: "data_version"),
    7: .standard(proto: "data_build"),
    8: .standard(proto: "base_build"),
    9: .same(proto: "error"),
    10: .standard(proto: "error_details"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._mapName)
      case 2: try decoder.decodeSingularStringField(value: &self._localMapPath)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.playerInfo)
      case 4: try decoder.decodeSingularUInt32Field(value: &self._gameDurationLoops)
      case 5: try decoder.decodeSingularFloatField(value: &self._gameDurationSeconds)
      case 6: try decoder.decodeSingularStringField(value: &self._gameVersion)
      case 7: try decoder.decodeSingularUInt32Field(value: &self._dataBuild)
      case 8: try decoder.decodeSingularUInt32Field(value: &self._baseBuild)
      case 9: try decoder.decodeSingularEnumField(value: &self._error)
      case 10: try decoder.decodeSingularStringField(value: &self._errorDetails)
      case 11: try decoder.decodeSingularStringField(value: &self._dataVersion)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mapName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._localMapPath {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if !self.playerInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.playerInfo, fieldNumber: 3)
    }
    if let v = self._gameDurationLoops {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._gameDurationSeconds {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    }
    if let v = self._gameVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    if let v = self._dataBuild {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._baseBuild {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    }
    if let v = self._error {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 9)
    }
    if let v = self._errorDetails {
      try visitor.visitSingularStringField(value: v, fieldNumber: 10)
    }
    if let v = self._dataVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ResponseReplayInfo, rhs: SC2APIProtocol_ResponseReplayInfo) -> Bool {
    if lhs._mapName != rhs._mapName {return false}
    if lhs._localMapPath != rhs._localMapPath {return false}
    if lhs.playerInfo != rhs.playerInfo {return false}
    if lhs._gameDurationLoops != rhs._gameDurationLoops {return false}
    if lhs._gameDurationSeconds != rhs._gameDurationSeconds {return false}
    if lhs._gameVersion != rhs._gameVersion {return false}
    if lhs._dataVersion != rhs._dataVersion {return false}
    if lhs._dataBuild != rhs._dataBuild {return false}
    if lhs._baseBuild != rhs._baseBuild {return false}
    if lhs._error != rhs._error {return false}
    if lhs._errorDetails != rhs._errorDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponseReplayInfo.Error: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "MissingReplay"),
    2: .same(proto: "InvalidReplayPath"),
    3: .same(proto: "InvalidReplayData"),
    4: .same(proto: "ParsingError"),
    5: .same(proto: "DownloadError"),
  ]
}

extension SC2APIProtocol_RequestAvailableMaps: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestAvailableMaps"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_RequestAvailableMaps, rhs: SC2APIProtocol_RequestAvailableMaps) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponseAvailableMaps: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseAvailableMaps"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "local_map_paths"),
    2: .standard(proto: "battlenet_map_names"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.localMapPaths)
      case 2: try decoder.decodeRepeatedStringField(value: &self.battlenetMapNames)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.localMapPaths.isEmpty {
      try visitor.visitRepeatedStringField(value: self.localMapPaths, fieldNumber: 1)
    }
    if !self.battlenetMapNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.battlenetMapNames, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ResponseAvailableMaps, rhs: SC2APIProtocol_ResponseAvailableMaps) -> Bool {
    if lhs.localMapPaths != rhs.localMapPaths {return false}
    if lhs.battlenetMapNames != rhs.battlenetMapNames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_RequestSaveMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestSaveMap"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "map_path"),
    2: .standard(proto: "map_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._mapPath)
      case 2: try decoder.decodeSingularBytesField(value: &self._mapData)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mapPath {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._mapData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_RequestSaveMap, rhs: SC2APIProtocol_RequestSaveMap) -> Bool {
    if lhs._mapPath != rhs._mapPath {return false}
    if lhs._mapData != rhs._mapData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponseSaveMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseSaveMap"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._error)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._error {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ResponseSaveMap, rhs: SC2APIProtocol_ResponseSaveMap) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponseSaveMap.Error: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "InvalidMapData"),
  ]
}

extension SC2APIProtocol_RequestPing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestPing"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_RequestPing, rhs: SC2APIProtocol_RequestPing) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponsePing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponsePing"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "game_version"),
    2: .standard(proto: "data_version"),
    3: .standard(proto: "data_build"),
    4: .standard(proto: "base_build"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._gameVersion)
      case 2: try decoder.decodeSingularStringField(value: &self._dataVersion)
      case 3: try decoder.decodeSingularUInt32Field(value: &self._dataBuild)
      case 4: try decoder.decodeSingularUInt32Field(value: &self._baseBuild)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._gameVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._dataVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._dataBuild {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._baseBuild {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ResponsePing, rhs: SC2APIProtocol_ResponsePing) -> Bool {
    if lhs._gameVersion != rhs._gameVersion {return false}
    if lhs._dataVersion != rhs._dataVersion {return false}
    if lhs._dataBuild != rhs._dataBuild {return false}
    if lhs._baseBuild != rhs._baseBuild {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_RequestDebug: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestDebug"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "debug"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.debug)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.debug.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.debug, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_RequestDebug, rhs: SC2APIProtocol_RequestDebug) -> Bool {
    if lhs.debug != rhs.debug {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponseDebug: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseDebug"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ResponseDebug, rhs: SC2APIProtocol_ResponseDebug) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_PlayerSetup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayerSetup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "race"),
    3: .same(proto: "difficulty"),
    4: .standard(proto: "player_name"),
    5: .standard(proto: "ai_build"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._type)
      case 2: try decoder.decodeSingularEnumField(value: &self._race)
      case 3: try decoder.decodeSingularEnumField(value: &self._difficulty)
      case 4: try decoder.decodeSingularStringField(value: &self._playerName)
      case 5: try decoder.decodeSingularEnumField(value: &self._aiBuild)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._race {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }
    if let v = self._difficulty {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }
    if let v = self._playerName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._aiBuild {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_PlayerSetup, rhs: SC2APIProtocol_PlayerSetup) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._race != rhs._race {return false}
    if lhs._difficulty != rhs._difficulty {return false}
    if lhs._playerName != rhs._playerName {return false}
    if lhs._aiBuild != rhs._aiBuild {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_SpatialCameraSetup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SpatialCameraSetup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "resolution"),
    3: .standard(proto: "minimap_resolution"),
    1: .same(proto: "width"),
    4: .standard(proto: "crop_to_playable_area"),
    5: .standard(proto: "allow_cheating_layers"),
  ]

  fileprivate class _StorageClass {
    var _resolution: SC2APIProtocol_Size2DI? = nil
    var _minimapResolution: SC2APIProtocol_Size2DI? = nil
    var _width: Float? = nil
    var _cropToPlayableArea: Bool? = nil
    var _allowCheatingLayers: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _resolution = source._resolution
      _minimapResolution = source._minimapResolution
      _width = source._width
      _cropToPlayableArea = source._cropToPlayableArea
      _allowCheatingLayers = source._allowCheatingLayers
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularFloatField(value: &_storage._width)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._resolution)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._minimapResolution)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._cropToPlayableArea)
        case 5: try decoder.decodeSingularBoolField(value: &_storage._allowCheatingLayers)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._width {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
      }
      if let v = _storage._resolution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._minimapResolution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._cropToPlayableArea {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      }
      if let v = _storage._allowCheatingLayers {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_SpatialCameraSetup, rhs: SC2APIProtocol_SpatialCameraSetup) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._resolution != rhs_storage._resolution {return false}
        if _storage._minimapResolution != rhs_storage._minimapResolution {return false}
        if _storage._width != rhs_storage._width {return false}
        if _storage._cropToPlayableArea != rhs_storage._cropToPlayableArea {return false}
        if _storage._allowCheatingLayers != rhs_storage._allowCheatingLayers {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_InterfaceOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InterfaceOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "raw"),
    2: .same(proto: "score"),
    3: .standard(proto: "feature_layer"),
    4: .same(proto: "render"),
    5: .standard(proto: "show_cloaked"),
    9: .standard(proto: "show_burrowed_shadows"),
    8: .standard(proto: "show_placeholders"),
    6: .standard(proto: "raw_affects_selection"),
    7: .standard(proto: "raw_crop_to_playable_area"),
  ]

  fileprivate class _StorageClass {
    var _raw: Bool? = nil
    var _score: Bool? = nil
    var _featureLayer: SC2APIProtocol_SpatialCameraSetup? = nil
    var _render: SC2APIProtocol_SpatialCameraSetup? = nil
    var _showCloaked: Bool? = nil
    var _showBurrowedShadows: Bool? = nil
    var _showPlaceholders: Bool? = nil
    var _rawAffectsSelection: Bool? = nil
    var _rawCropToPlayableArea: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _raw = source._raw
      _score = source._score
      _featureLayer = source._featureLayer
      _render = source._render
      _showCloaked = source._showCloaked
      _showBurrowedShadows = source._showBurrowedShadows
      _showPlaceholders = source._showPlaceholders
      _rawAffectsSelection = source._rawAffectsSelection
      _rawCropToPlayableArea = source._rawCropToPlayableArea
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBoolField(value: &_storage._raw)
        case 2: try decoder.decodeSingularBoolField(value: &_storage._score)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._featureLayer)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._render)
        case 5: try decoder.decodeSingularBoolField(value: &_storage._showCloaked)
        case 6: try decoder.decodeSingularBoolField(value: &_storage._rawAffectsSelection)
        case 7: try decoder.decodeSingularBoolField(value: &_storage._rawCropToPlayableArea)
        case 8: try decoder.decodeSingularBoolField(value: &_storage._showPlaceholders)
        case 9: try decoder.decodeSingularBoolField(value: &_storage._showBurrowedShadows)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._raw {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
      }
      if let v = _storage._score {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      }
      if let v = _storage._featureLayer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._render {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._showCloaked {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      }
      if let v = _storage._rawAffectsSelection {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      }
      if let v = _storage._rawCropToPlayableArea {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      }
      if let v = _storage._showPlaceholders {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      }
      if let v = _storage._showBurrowedShadows {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_InterfaceOptions, rhs: SC2APIProtocol_InterfaceOptions) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._raw != rhs_storage._raw {return false}
        if _storage._score != rhs_storage._score {return false}
        if _storage._featureLayer != rhs_storage._featureLayer {return false}
        if _storage._render != rhs_storage._render {return false}
        if _storage._showCloaked != rhs_storage._showCloaked {return false}
        if _storage._showBurrowedShadows != rhs_storage._showBurrowedShadows {return false}
        if _storage._showPlaceholders != rhs_storage._showPlaceholders {return false}
        if _storage._rawAffectsSelection != rhs_storage._rawAffectsSelection {return false}
        if _storage._rawCropToPlayableArea != rhs_storage._rawCropToPlayableArea {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_PlayerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayerInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "player_id"),
    2: .same(proto: "type"),
    3: .standard(proto: "race_requested"),
    4: .standard(proto: "race_actual"),
    5: .same(proto: "difficulty"),
    7: .standard(proto: "ai_build"),
    6: .standard(proto: "player_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self._playerID)
      case 2: try decoder.decodeSingularEnumField(value: &self._type)
      case 3: try decoder.decodeSingularEnumField(value: &self._raceRequested)
      case 4: try decoder.decodeSingularEnumField(value: &self._raceActual)
      case 5: try decoder.decodeSingularEnumField(value: &self._difficulty)
      case 6: try decoder.decodeSingularStringField(value: &self._playerName)
      case 7: try decoder.decodeSingularEnumField(value: &self._aiBuild)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._playerID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }
    if let v = self._raceRequested {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }
    if let v = self._raceActual {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    }
    if let v = self._difficulty {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    }
    if let v = self._playerName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    if let v = self._aiBuild {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_PlayerInfo, rhs: SC2APIProtocol_PlayerInfo) -> Bool {
    if lhs._playerID != rhs._playerID {return false}
    if lhs._type != rhs._type {return false}
    if lhs._raceRequested != rhs._raceRequested {return false}
    if lhs._raceActual != rhs._raceActual {return false}
    if lhs._difficulty != rhs._difficulty {return false}
    if lhs._aiBuild != rhs._aiBuild {return false}
    if lhs._playerName != rhs._playerName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_PlayerCommon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayerCommon"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "player_id"),
    2: .same(proto: "minerals"),
    3: .same(proto: "vespene"),
    4: .standard(proto: "food_cap"),
    5: .standard(proto: "food_used"),
    6: .standard(proto: "food_army"),
    7: .standard(proto: "food_workers"),
    8: .standard(proto: "idle_worker_count"),
    9: .standard(proto: "army_count"),
    10: .standard(proto: "warp_gate_count"),
    11: .standard(proto: "larva_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self._playerID)
      case 2: try decoder.decodeSingularUInt32Field(value: &self._minerals)
      case 3: try decoder.decodeSingularUInt32Field(value: &self._vespene)
      case 4: try decoder.decodeSingularUInt32Field(value: &self._foodCap)
      case 5: try decoder.decodeSingularUInt32Field(value: &self._foodUsed)
      case 6: try decoder.decodeSingularUInt32Field(value: &self._foodArmy)
      case 7: try decoder.decodeSingularUInt32Field(value: &self._foodWorkers)
      case 8: try decoder.decodeSingularUInt32Field(value: &self._idleWorkerCount)
      case 9: try decoder.decodeSingularUInt32Field(value: &self._armyCount)
      case 10: try decoder.decodeSingularUInt32Field(value: &self._warpGateCount)
      case 11: try decoder.decodeSingularUInt32Field(value: &self._larvaCount)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._playerID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._minerals {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._vespene {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._foodCap {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._foodUsed {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._foodArmy {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    if let v = self._foodWorkers {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._idleWorkerCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    }
    if let v = self._armyCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
    }
    if let v = self._warpGateCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    }
    if let v = self._larvaCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_PlayerCommon, rhs: SC2APIProtocol_PlayerCommon) -> Bool {
    if lhs._playerID != rhs._playerID {return false}
    if lhs._minerals != rhs._minerals {return false}
    if lhs._vespene != rhs._vespene {return false}
    if lhs._foodCap != rhs._foodCap {return false}
    if lhs._foodUsed != rhs._foodUsed {return false}
    if lhs._foodArmy != rhs._foodArmy {return false}
    if lhs._foodWorkers != rhs._foodWorkers {return false}
    if lhs._idleWorkerCount != rhs._idleWorkerCount {return false}
    if lhs._armyCount != rhs._armyCount {return false}
    if lhs._warpGateCount != rhs._warpGateCount {return false}
    if lhs._larvaCount != rhs._larvaCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_Observation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Observation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    9: .standard(proto: "game_loop"),
    1: .standard(proto: "player_common"),
    10: .same(proto: "alerts"),
    3: .same(proto: "abilities"),
    4: .same(proto: "score"),
    5: .standard(proto: "raw_data"),
    6: .standard(proto: "feature_layer_data"),
    7: .standard(proto: "render_data"),
    8: .standard(proto: "ui_data"),
  ]

  fileprivate class _StorageClass {
    var _gameLoop: UInt32? = nil
    var _playerCommon: SC2APIProtocol_PlayerCommon? = nil
    var _alerts: [SC2APIProtocol_Alert] = []
    var _abilities: [SC2APIProtocol_AvailableAbility] = []
    var _score: SC2APIProtocol_Score? = nil
    var _rawData: SC2APIProtocol_ObservationRaw? = nil
    var _featureLayerData: SC2APIProtocol_ObservationFeatureLayer? = nil
    var _renderData: SC2APIProtocol_ObservationRender? = nil
    var _uiData: SC2APIProtocol_ObservationUI? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _gameLoop = source._gameLoop
      _playerCommon = source._playerCommon
      _alerts = source._alerts
      _abilities = source._abilities
      _score = source._score
      _rawData = source._rawData
      _featureLayerData = source._featureLayerData
      _renderData = source._renderData
      _uiData = source._uiData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._playerCommon)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._abilities)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._score)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._rawData)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._featureLayerData)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._renderData)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._uiData)
        case 9: try decoder.decodeSingularUInt32Field(value: &_storage._gameLoop)
        case 10: try decoder.decodeRepeatedEnumField(value: &_storage._alerts)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._playerCommon {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._abilities.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._abilities, fieldNumber: 3)
      }
      if let v = _storage._score {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._rawData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._featureLayerData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._renderData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._uiData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._gameLoop {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
      }
      if !_storage._alerts.isEmpty {
        try visitor.visitRepeatedEnumField(value: _storage._alerts, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_Observation, rhs: SC2APIProtocol_Observation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._gameLoop != rhs_storage._gameLoop {return false}
        if _storage._playerCommon != rhs_storage._playerCommon {return false}
        if _storage._alerts != rhs_storage._alerts {return false}
        if _storage._abilities != rhs_storage._abilities {return false}
        if _storage._score != rhs_storage._score {return false}
        if _storage._rawData != rhs_storage._rawData {return false}
        if _storage._featureLayerData != rhs_storage._featureLayerData {return false}
        if _storage._renderData != rhs_storage._renderData {return false}
        if _storage._uiData != rhs_storage._uiData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_Action: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Action"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_raw"),
    2: .standard(proto: "action_feature_layer"),
    3: .standard(proto: "action_render"),
    4: .standard(proto: "action_ui"),
    6: .standard(proto: "action_chat"),
    7: .standard(proto: "game_loop"),
  ]

  fileprivate class _StorageClass {
    var _actionRaw: SC2APIProtocol_ActionRaw? = nil
    var _actionFeatureLayer: SC2APIProtocol_ActionSpatial? = nil
    var _actionRender: SC2APIProtocol_ActionSpatial? = nil
    var _actionUi: SC2APIProtocol_ActionUI? = nil
    var _actionChat: SC2APIProtocol_ActionChat? = nil
    var _gameLoop: UInt32? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _actionRaw = source._actionRaw
      _actionFeatureLayer = source._actionFeatureLayer
      _actionRender = source._actionRender
      _actionUi = source._actionUi
      _actionChat = source._actionChat
      _gameLoop = source._gameLoop
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._actionRaw)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._actionFeatureLayer)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._actionRender)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._actionUi)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._actionChat)
        case 7: try decoder.decodeSingularUInt32Field(value: &_storage._gameLoop)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._actionRaw {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._actionFeatureLayer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._actionRender {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._actionUi {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._actionChat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._gameLoop {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_Action, rhs: SC2APIProtocol_Action) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._actionRaw != rhs_storage._actionRaw {return false}
        if _storage._actionFeatureLayer != rhs_storage._actionFeatureLayer {return false}
        if _storage._actionRender != rhs_storage._actionRender {return false}
        if _storage._actionUi != rhs_storage._actionUi {return false}
        if _storage._actionChat != rhs_storage._actionChat {return false}
        if _storage._gameLoop != rhs_storage._gameLoop {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ActionChat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionChat"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._channel)
      case 2: try decoder.decodeSingularStringField(value: &self._message)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._channel {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ActionChat, rhs: SC2APIProtocol_ActionChat) -> Bool {
    if lhs._channel != rhs._channel {return false}
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ActionChat.Channel: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Broadcast"),
    2: .same(proto: "Team"),
  ]
}

extension SC2APIProtocol_ActionError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "unit_tag"),
    2: .standard(proto: "ability_id"),
    3: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self._unitTag)
      case 2: try decoder.decodeSingularUInt64Field(value: &self._abilityID)
      case 3: try decoder.decodeSingularEnumField(value: &self._result)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._unitTag {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }
    if let v = self._abilityID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }
    if let v = self._result {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ActionError, rhs: SC2APIProtocol_ActionError) -> Bool {
    if lhs._unitTag != rhs._unitTag {return false}
    if lhs._abilityID != rhs._abilityID {return false}
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ObserverAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ObserverAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "player_perspective"),
    2: .standard(proto: "camera_move"),
    3: .standard(proto: "camera_follow_player"),
    4: .standard(proto: "camera_follow_units"),
  ]

  fileprivate class _StorageClass {
    var _action: SC2APIProtocol_ObserverAction.OneOf_Action?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _action = source._action
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: SC2APIProtocol_ActionObserverPlayerPerspective?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .playerPerspective(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .playerPerspective(v)}
        case 2:
          var v: SC2APIProtocol_ActionObserverCameraMove?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .cameraMove(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .cameraMove(v)}
        case 3:
          var v: SC2APIProtocol_ActionObserverCameraFollowPlayer?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .cameraFollowPlayer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .cameraFollowPlayer(v)}
        case 4:
          var v: SC2APIProtocol_ActionObserverCameraFollowUnits?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .cameraFollowUnits(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .cameraFollowUnits(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._action {
      case .playerPerspective(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .cameraMove(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .cameraFollowPlayer(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .cameraFollowUnits(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ObserverAction, rhs: SC2APIProtocol_ObserverAction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._action != rhs_storage._action {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ActionObserverPlayerPerspective: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionObserverPlayerPerspective"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "player_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self._playerID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._playerID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ActionObserverPlayerPerspective, rhs: SC2APIProtocol_ActionObserverPlayerPerspective) -> Bool {
    if lhs._playerID != rhs._playerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ActionObserverCameraMove: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionObserverCameraMove"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "world_pos"),
    2: .same(proto: "distance"),
  ]

  fileprivate class _StorageClass {
    var _worldPos: SC2APIProtocol_Point2D? = nil
    var _distance: Float? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _worldPos = source._worldPos
      _distance = source._distance
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._worldPos)
        case 2: try decoder.decodeSingularFloatField(value: &_storage._distance)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._worldPos {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._distance {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ActionObserverCameraMove, rhs: SC2APIProtocol_ActionObserverCameraMove) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._worldPos != rhs_storage._worldPos {return false}
        if _storage._distance != rhs_storage._distance {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ActionObserverCameraFollowPlayer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionObserverCameraFollowPlayer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "player_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self._playerID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._playerID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ActionObserverCameraFollowPlayer, rhs: SC2APIProtocol_ActionObserverCameraFollowPlayer) -> Bool {
    if lhs._playerID != rhs._playerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ActionObserverCameraFollowUnits: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionObserverCameraFollowUnits"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "unit_tags"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedUInt64Field(value: &self.unitTags)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.unitTags.isEmpty {
      try visitor.visitRepeatedUInt64Field(value: self.unitTags, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ActionObserverCameraFollowUnits, rhs: SC2APIProtocol_ActionObserverCameraFollowUnits) -> Bool {
    if lhs.unitTags != rhs.unitTags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_PlayerResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayerResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "player_id"),
    2: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self._playerID)
      case 2: try decoder.decodeSingularEnumField(value: &self._result)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._playerID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._result {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_PlayerResult, rhs: SC2APIProtocol_PlayerResult) -> Bool {
    if lhs._playerID != rhs._playerID {return false}
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
