// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: s2clientprotocol/query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct SC2APIProtocol_RequestQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pathing: [SC2APIProtocol_RequestQueryPathing] = []

  var abilities: [SC2APIProtocol_RequestQueryAvailableAbilities] = []

  var placements: [SC2APIProtocol_RequestQueryBuildingPlacement] = []

  /// Ignores requirements like food, minerals and so on.
  var ignoreResourceRequirements: Bool {
    get {return _ignoreResourceRequirements ?? false}
    set {_ignoreResourceRequirements = newValue}
  }
  /// Returns true if `ignoreResourceRequirements` has been explicitly set.
  var hasIgnoreResourceRequirements: Bool {return self._ignoreResourceRequirements != nil}
  /// Clears the value of `ignoreResourceRequirements`. Subsequent reads from it will return its default value.
  mutating func clearIgnoreResourceRequirements() {self._ignoreResourceRequirements = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ignoreResourceRequirements: Bool? = nil
}

struct SC2APIProtocol_ResponseQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pathing: [SC2APIProtocol_ResponseQueryPathing] = []

  var abilities: [SC2APIProtocol_ResponseQueryAvailableAbilities] = []

  var placements: [SC2APIProtocol_ResponseQueryBuildingPlacement] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///--------------------------------------------------------------------------------------------------
struct SC2APIProtocol_RequestQueryPathing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var start: OneOf_Start? {
    get {return _storage._start}
    set {_uniqueStorage()._start = newValue}
  }

  var startPos: SC2APIProtocol_Point2D {
    get {
      if case .startPos(let v)? = _storage._start {return v}
      return SC2APIProtocol_Point2D()
    }
    set {_uniqueStorage()._start = .startPos(newValue)}
  }

  var unitTag: UInt64 {
    get {
      if case .unitTag(let v)? = _storage._start {return v}
      return 0
    }
    set {_uniqueStorage()._start = .unitTag(newValue)}
  }

  var endPos: SC2APIProtocol_Point2D {
    get {return _storage._endPos ?? SC2APIProtocol_Point2D()}
    set {_uniqueStorage()._endPos = newValue}
  }
  /// Returns true if `endPos` has been explicitly set.
  var hasEndPos: Bool {return _storage._endPos != nil}
  /// Clears the value of `endPos`. Subsequent reads from it will return its default value.
  mutating func clearEndPos() {_uniqueStorage()._endPos = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Start: Equatable {
    case startPos(SC2APIProtocol_Point2D)
    case unitTag(UInt64)

  #if !swift(>=4.1)
    static func ==(lhs: SC2APIProtocol_RequestQueryPathing.OneOf_Start, rhs: SC2APIProtocol_RequestQueryPathing.OneOf_Start) -> Bool {
      switch (lhs, rhs) {
      case (.startPos(let l), .startPos(let r)): return l == r
      case (.unitTag(let l), .unitTag(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_ResponseQueryPathing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 0 if no path exists
  var distance: Float {
    get {return _distance ?? 0}
    set {_distance = newValue}
  }
  /// Returns true if `distance` has been explicitly set.
  var hasDistance: Bool {return self._distance != nil}
  /// Clears the value of `distance`. Subsequent reads from it will return its default value.
  mutating func clearDistance() {self._distance = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _distance: Float? = nil
}

///--------------------------------------------------------------------------------------------------
struct SC2APIProtocol_RequestQueryAvailableAbilities {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unitTag: UInt64 {
    get {return _unitTag ?? 0}
    set {_unitTag = newValue}
  }
  /// Returns true if `unitTag` has been explicitly set.
  var hasUnitTag: Bool {return self._unitTag != nil}
  /// Clears the value of `unitTag`. Subsequent reads from it will return its default value.
  mutating func clearUnitTag() {self._unitTag = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _unitTag: UInt64? = nil
}

struct SC2APIProtocol_ResponseQueryAvailableAbilities {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var abilities: [SC2APIProtocol_AvailableAbility] = []

  var unitTag: UInt64 {
    get {return _unitTag ?? 0}
    set {_unitTag = newValue}
  }
  /// Returns true if `unitTag` has been explicitly set.
  var hasUnitTag: Bool {return self._unitTag != nil}
  /// Clears the value of `unitTag`. Subsequent reads from it will return its default value.
  mutating func clearUnitTag() {self._unitTag = nil}

  var unitTypeID: UInt32 {
    get {return _unitTypeID ?? 0}
    set {_unitTypeID = newValue}
  }
  /// Returns true if `unitTypeID` has been explicitly set.
  var hasUnitTypeID: Bool {return self._unitTypeID != nil}
  /// Clears the value of `unitTypeID`. Subsequent reads from it will return its default value.
  mutating func clearUnitTypeID() {self._unitTypeID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _unitTag: UInt64? = nil
  fileprivate var _unitTypeID: UInt32? = nil
}

///--------------------------------------------------------------------------------------------------
struct SC2APIProtocol_RequestQueryBuildingPlacement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var abilityID: Int32 {
    get {return _storage._abilityID ?? 0}
    set {_uniqueStorage()._abilityID = newValue}
  }
  /// Returns true if `abilityID` has been explicitly set.
  var hasAbilityID: Bool {return _storage._abilityID != nil}
  /// Clears the value of `abilityID`. Subsequent reads from it will return its default value.
  mutating func clearAbilityID() {_uniqueStorage()._abilityID = nil}

  var targetPos: SC2APIProtocol_Point2D {
    get {return _storage._targetPos ?? SC2APIProtocol_Point2D()}
    set {_uniqueStorage()._targetPos = newValue}
  }
  /// Returns true if `targetPos` has been explicitly set.
  var hasTargetPos: Bool {return _storage._targetPos != nil}
  /// Clears the value of `targetPos`. Subsequent reads from it will return its default value.
  mutating func clearTargetPos() {_uniqueStorage()._targetPos = nil}

  /// Not required
  var placingUnitTag: UInt64 {
    get {return _storage._placingUnitTag ?? 0}
    set {_uniqueStorage()._placingUnitTag = newValue}
  }
  /// Returns true if `placingUnitTag` has been explicitly set.
  var hasPlacingUnitTag: Bool {return _storage._placingUnitTag != nil}
  /// Clears the value of `placingUnitTag`. Subsequent reads from it will return its default value.
  mutating func clearPlacingUnitTag() {_uniqueStorage()._placingUnitTag = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_ResponseQueryBuildingPlacement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: SC2APIProtocol_ActionResult {
    get {return _result ?? .success}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {self._result = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _result: SC2APIProtocol_ActionResult? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "SC2APIProtocol"

extension SC2APIProtocol_RequestQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestQuery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pathing"),
    2: .same(proto: "abilities"),
    3: .same(proto: "placements"),
    4: .standard(proto: "ignore_resource_requirements"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.pathing)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.abilities)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.placements)
      case 4: try decoder.decodeSingularBoolField(value: &self._ignoreResourceRequirements)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pathing.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pathing, fieldNumber: 1)
    }
    if !self.abilities.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.abilities, fieldNumber: 2)
    }
    if !self.placements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.placements, fieldNumber: 3)
    }
    if let v = self._ignoreResourceRequirements {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_RequestQuery, rhs: SC2APIProtocol_RequestQuery) -> Bool {
    if lhs.pathing != rhs.pathing {return false}
    if lhs.abilities != rhs.abilities {return false}
    if lhs.placements != rhs.placements {return false}
    if lhs._ignoreResourceRequirements != rhs._ignoreResourceRequirements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponseQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseQuery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pathing"),
    2: .same(proto: "abilities"),
    3: .same(proto: "placements"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.pathing)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.abilities)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.placements)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pathing.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pathing, fieldNumber: 1)
    }
    if !self.abilities.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.abilities, fieldNumber: 2)
    }
    if !self.placements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.placements, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ResponseQuery, rhs: SC2APIProtocol_ResponseQuery) -> Bool {
    if lhs.pathing != rhs.pathing {return false}
    if lhs.abilities != rhs.abilities {return false}
    if lhs.placements != rhs.placements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_RequestQueryPathing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestQueryPathing"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_pos"),
    2: .standard(proto: "unit_tag"),
    3: .standard(proto: "end_pos"),
  ]

  fileprivate class _StorageClass {
    var _start: SC2APIProtocol_RequestQueryPathing.OneOf_Start?
    var _endPos: SC2APIProtocol_Point2D? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _start = source._start
      _endPos = source._endPos
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: SC2APIProtocol_Point2D?
          if let current = _storage._start {
            try decoder.handleConflictingOneOf()
            if case .startPos(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._start = .startPos(v)}
        case 2:
          if _storage._start != nil {try decoder.handleConflictingOneOf()}
          var v: UInt64?
          try decoder.decodeSingularUInt64Field(value: &v)
          if let v = v {_storage._start = .unitTag(v)}
        case 3: try decoder.decodeSingularMessageField(value: &_storage._endPos)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._start {
      case .startPos(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .unitTag(let v)?:
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
      case nil: break
      }
      if let v = _storage._endPos {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_RequestQueryPathing, rhs: SC2APIProtocol_RequestQueryPathing) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._start != rhs_storage._start {return false}
        if _storage._endPos != rhs_storage._endPos {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponseQueryPathing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseQueryPathing"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "distance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self._distance)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._distance {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ResponseQueryPathing, rhs: SC2APIProtocol_ResponseQueryPathing) -> Bool {
    if lhs._distance != rhs._distance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_RequestQueryAvailableAbilities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestQueryAvailableAbilities"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "unit_tag"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self._unitTag)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._unitTag {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_RequestQueryAvailableAbilities, rhs: SC2APIProtocol_RequestQueryAvailableAbilities) -> Bool {
    if lhs._unitTag != rhs._unitTag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponseQueryAvailableAbilities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseQueryAvailableAbilities"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "abilities"),
    2: .standard(proto: "unit_tag"),
    3: .standard(proto: "unit_type_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.abilities)
      case 2: try decoder.decodeSingularUInt64Field(value: &self._unitTag)
      case 3: try decoder.decodeSingularUInt32Field(value: &self._unitTypeID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.abilities.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.abilities, fieldNumber: 1)
    }
    if let v = self._unitTag {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }
    if let v = self._unitTypeID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ResponseQueryAvailableAbilities, rhs: SC2APIProtocol_ResponseQueryAvailableAbilities) -> Bool {
    if lhs.abilities != rhs.abilities {return false}
    if lhs._unitTag != rhs._unitTag {return false}
    if lhs._unitTypeID != rhs._unitTypeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_RequestQueryBuildingPlacement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestQueryBuildingPlacement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ability_id"),
    2: .standard(proto: "target_pos"),
    3: .standard(proto: "placing_unit_tag"),
  ]

  fileprivate class _StorageClass {
    var _abilityID: Int32? = nil
    var _targetPos: SC2APIProtocol_Point2D? = nil
    var _placingUnitTag: UInt64? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _abilityID = source._abilityID
      _targetPos = source._targetPos
      _placingUnitTag = source._placingUnitTag
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt32Field(value: &_storage._abilityID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._targetPos)
        case 3: try decoder.decodeSingularUInt64Field(value: &_storage._placingUnitTag)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._abilityID {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
      }
      if let v = _storage._targetPos {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._placingUnitTag {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_RequestQueryBuildingPlacement, rhs: SC2APIProtocol_RequestQueryBuildingPlacement) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._abilityID != rhs_storage._abilityID {return false}
        if _storage._targetPos != rhs_storage._targetPos {return false}
        if _storage._placingUnitTag != rhs_storage._placingUnitTag {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ResponseQueryBuildingPlacement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseQueryBuildingPlacement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._result)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._result {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ResponseQueryBuildingPlacement, rhs: SC2APIProtocol_ResponseQueryBuildingPlacement) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
