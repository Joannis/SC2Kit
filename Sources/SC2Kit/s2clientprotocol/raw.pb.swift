// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: s2clientprotocol/raw.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum SC2APIProtocol_DisplayType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Fully visible
  case visible // = 1

  /// Dimmed version of unit left behind after entering fog of war
  case snapshot // = 2

  /// Fully hidden
  case hidden // = 3

  /// Building that hasn't started construction.
  case placeholder // = 4

  init() {
    self = .visible
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .visible
    case 2: self = .snapshot
    case 3: self = .hidden
    case 4: self = .placeholder
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .visible: return 1
    case .snapshot: return 2
    case .hidden: return 3
    case .placeholder: return 4
    }
  }

}

#if swift(>=4.2)

extension SC2APIProtocol_DisplayType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum SC2APIProtocol_Alliance: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case self_ // = 1
  case ally // = 2
  case neutral // = 3
  case enemy // = 4

  init() {
    self = .self_
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .self_
    case 2: self = .ally
    case 3: self = .neutral
    case 4: self = .enemy
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .self_: return 1
    case .ally: return 2
    case .neutral: return 3
    case .enemy: return 4
    }
  }

}

#if swift(>=4.2)

extension SC2APIProtocol_Alliance: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum SC2APIProtocol_CloakState: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Under the fog, so unknown whether it's cloaked or not.
  case cloakedUnknown // = 0
  case cloaked // = 1
  case cloakedDetected // = 2
  case notCloaked // = 3
  case cloakedAllied // = 4

  init() {
    self = .cloakedUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .cloakedUnknown
    case 1: self = .cloaked
    case 2: self = .cloakedDetected
    case 3: self = .notCloaked
    case 4: self = .cloakedAllied
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .cloakedUnknown: return 0
    case .cloaked: return 1
    case .cloakedDetected: return 2
    case .notCloaked: return 3
    case .cloakedAllied: return 4
    }
  }

}

#if swift(>=4.2)

extension SC2APIProtocol_CloakState: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct SC2APIProtocol_StartRaw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Width and height of the map.
  var mapSize: SC2APIProtocol_Size2DI {
    get {return _storage._mapSize ?? SC2APIProtocol_Size2DI()}
    set {_uniqueStorage()._mapSize = newValue}
  }
  /// Returns true if `mapSize` has been explicitly set.
  var hasMapSize: Bool {return _storage._mapSize != nil}
  /// Clears the value of `mapSize`. Subsequent reads from it will return its default value.
  mutating func clearMapSize() {_uniqueStorage()._mapSize = nil}

  /// 1 bit bitmap of the pathing grid.
  var pathingGrid: SC2APIProtocol_ImageData {
    get {return _storage._pathingGrid ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._pathingGrid = newValue}
  }
  /// Returns true if `pathingGrid` has been explicitly set.
  var hasPathingGrid: Bool {return _storage._pathingGrid != nil}
  /// Clears the value of `pathingGrid`. Subsequent reads from it will return its default value.
  mutating func clearPathingGrid() {_uniqueStorage()._pathingGrid = nil}

  /// 1 byte bitmap of the terrain height.
  var terrainHeight: SC2APIProtocol_ImageData {
    get {return _storage._terrainHeight ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._terrainHeight = newValue}
  }
  /// Returns true if `terrainHeight` has been explicitly set.
  var hasTerrainHeight: Bool {return _storage._terrainHeight != nil}
  /// Clears the value of `terrainHeight`. Subsequent reads from it will return its default value.
  mutating func clearTerrainHeight() {_uniqueStorage()._terrainHeight = nil}

  /// 1 bit bitmap of the building placement grid.
  var placementGrid: SC2APIProtocol_ImageData {
    get {return _storage._placementGrid ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._placementGrid = newValue}
  }
  /// Returns true if `placementGrid` has been explicitly set.
  var hasPlacementGrid: Bool {return _storage._placementGrid != nil}
  /// Clears the value of `placementGrid`. Subsequent reads from it will return its default value.
  mutating func clearPlacementGrid() {_uniqueStorage()._placementGrid = nil}

  /// The playable cells.
  var playableArea: SC2APIProtocol_RectangleI {
    get {return _storage._playableArea ?? SC2APIProtocol_RectangleI()}
    set {_uniqueStorage()._playableArea = newValue}
  }
  /// Returns true if `playableArea` has been explicitly set.
  var hasPlayableArea: Bool {return _storage._playableArea != nil}
  /// Clears the value of `playableArea`. Subsequent reads from it will return its default value.
  mutating func clearPlayableArea() {_uniqueStorage()._playableArea = nil}

  /// Possible start locations for players.
  var startLocations: [SC2APIProtocol_Point2D] {
    get {return _storage._startLocations}
    set {_uniqueStorage()._startLocations = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_ObservationRaw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var player: SC2APIProtocol_PlayerRaw {
    get {return _storage._player ?? SC2APIProtocol_PlayerRaw()}
    set {_uniqueStorage()._player = newValue}
  }
  /// Returns true if `player` has been explicitly set.
  var hasPlayer: Bool {return _storage._player != nil}
  /// Clears the value of `player`. Subsequent reads from it will return its default value.
  mutating func clearPlayer() {_uniqueStorage()._player = nil}

  var units: [SC2APIProtocol_Unit] {
    get {return _storage._units}
    set {_uniqueStorage()._units = newValue}
  }

  /// Fog of war, creep and so on. Board stuff that changes per frame.
  var mapState: SC2APIProtocol_MapState {
    get {return _storage._mapState ?? SC2APIProtocol_MapState()}
    set {_uniqueStorage()._mapState = newValue}
  }
  /// Returns true if `mapState` has been explicitly set.
  var hasMapState: Bool {return _storage._mapState != nil}
  /// Clears the value of `mapState`. Subsequent reads from it will return its default value.
  mutating func clearMapState() {_uniqueStorage()._mapState = nil}

  var event: SC2APIProtocol_Event {
    get {return _storage._event ?? SC2APIProtocol_Event()}
    set {_uniqueStorage()._event = newValue}
  }
  /// Returns true if `event` has been explicitly set.
  var hasEvent: Bool {return _storage._event != nil}
  /// Clears the value of `event`. Subsequent reads from it will return its default value.
  mutating func clearEvent() {_uniqueStorage()._event = nil}

  var effects: [SC2APIProtocol_Effect] {
    get {return _storage._effects}
    set {_uniqueStorage()._effects = newValue}
  }

  var radar: [SC2APIProtocol_RadarRing] {
    get {return _storage._radar}
    set {_uniqueStorage()._radar = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_RadarRing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: SC2APIProtocol_Point {
    get {return _storage._pos ?? SC2APIProtocol_Point()}
    set {_uniqueStorage()._pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return _storage._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {_uniqueStorage()._pos = nil}

  var radius: Float {
    get {return _storage._radius ?? 0}
    set {_uniqueStorage()._radius = newValue}
  }
  /// Returns true if `radius` has been explicitly set.
  var hasRadius: Bool {return _storage._radius != nil}
  /// Clears the value of `radius`. Subsequent reads from it will return its default value.
  mutating func clearRadius() {_uniqueStorage()._radius = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_PowerSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pos: SC2APIProtocol_Point {
    get {return _storage._pos ?? SC2APIProtocol_Point()}
    set {_uniqueStorage()._pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return _storage._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {_uniqueStorage()._pos = nil}

  var radius: Float {
    get {return _storage._radius ?? 0}
    set {_uniqueStorage()._radius = newValue}
  }
  /// Returns true if `radius` has been explicitly set.
  var hasRadius: Bool {return _storage._radius != nil}
  /// Clears the value of `radius`. Subsequent reads from it will return its default value.
  mutating func clearRadius() {_uniqueStorage()._radius = nil}

  var tag: UInt64 {
    get {return _storage._tag ?? 0}
    set {_uniqueStorage()._tag = newValue}
  }
  /// Returns true if `tag` has been explicitly set.
  var hasTag: Bool {return _storage._tag != nil}
  /// Clears the value of `tag`. Subsequent reads from it will return its default value.
  mutating func clearTag() {_uniqueStorage()._tag = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_PlayerRaw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var powerSources: [SC2APIProtocol_PowerSource] {
    get {return _storage._powerSources}
    set {_uniqueStorage()._powerSources = newValue}
  }

  var camera: SC2APIProtocol_Point {
    get {return _storage._camera ?? SC2APIProtocol_Point()}
    set {_uniqueStorage()._camera = newValue}
  }
  /// Returns true if `camera` has been explicitly set.
  var hasCamera: Bool {return _storage._camera != nil}
  /// Clears the value of `camera`. Subsequent reads from it will return its default value.
  mutating func clearCamera() {_uniqueStorage()._camera = nil}

  /// TODO: Add to UI observation?
  var upgradeIds: [UInt32] {
    get {return _storage._upgradeIds}
    set {_uniqueStorage()._upgradeIds = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_UnitOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var abilityID: UInt32 {
    get {return _storage._abilityID ?? 0}
    set {_uniqueStorage()._abilityID = newValue}
  }
  /// Returns true if `abilityID` has been explicitly set.
  var hasAbilityID: Bool {return _storage._abilityID != nil}
  /// Clears the value of `abilityID`. Subsequent reads from it will return its default value.
  mutating func clearAbilityID() {_uniqueStorage()._abilityID = nil}

  var target: OneOf_Target? {
    get {return _storage._target}
    set {_uniqueStorage()._target = newValue}
  }

  var targetWorldSpacePos: SC2APIProtocol_Point {
    get {
      if case .targetWorldSpacePos(let v)? = _storage._target {return v}
      return SC2APIProtocol_Point()
    }
    set {_uniqueStorage()._target = .targetWorldSpacePos(newValue)}
  }

  var targetUnitTag: UInt64 {
    get {
      if case .targetUnitTag(let v)? = _storage._target {return v}
      return 0
    }
    set {_uniqueStorage()._target = .targetUnitTag(newValue)}
  }

  /// Progress of train abilities. Range: [0.0, 1.0]
  var progress: Float {
    get {return _storage._progress ?? 0}
    set {_uniqueStorage()._progress = newValue}
  }
  /// Returns true if `progress` has been explicitly set.
  var hasProgress: Bool {return _storage._progress != nil}
  /// Clears the value of `progress`. Subsequent reads from it will return its default value.
  mutating func clearProgress() {_uniqueStorage()._progress = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Target: Equatable {
    case targetWorldSpacePos(SC2APIProtocol_Point)
    case targetUnitTag(UInt64)

  #if !swift(>=4.1)
    static func ==(lhs: SC2APIProtocol_UnitOrder.OneOf_Target, rhs: SC2APIProtocol_UnitOrder.OneOf_Target) -> Bool {
      switch (lhs, rhs) {
      case (.targetWorldSpacePos(let l), .targetWorldSpacePos(let r)): return l == r
      case (.targetUnitTag(let l), .targetUnitTag(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_PassengerUnit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tag: UInt64 {
    get {return _tag ?? 0}
    set {_tag = newValue}
  }
  /// Returns true if `tag` has been explicitly set.
  var hasTag: Bool {return self._tag != nil}
  /// Clears the value of `tag`. Subsequent reads from it will return its default value.
  mutating func clearTag() {self._tag = nil}

  var health: Float {
    get {return _health ?? 0}
    set {_health = newValue}
  }
  /// Returns true if `health` has been explicitly set.
  var hasHealth: Bool {return self._health != nil}
  /// Clears the value of `health`. Subsequent reads from it will return its default value.
  mutating func clearHealth() {self._health = nil}

  var healthMax: Float {
    get {return _healthMax ?? 0}
    set {_healthMax = newValue}
  }
  /// Returns true if `healthMax` has been explicitly set.
  var hasHealthMax: Bool {return self._healthMax != nil}
  /// Clears the value of `healthMax`. Subsequent reads from it will return its default value.
  mutating func clearHealthMax() {self._healthMax = nil}

  var shield: Float {
    get {return _shield ?? 0}
    set {_shield = newValue}
  }
  /// Returns true if `shield` has been explicitly set.
  var hasShield: Bool {return self._shield != nil}
  /// Clears the value of `shield`. Subsequent reads from it will return its default value.
  mutating func clearShield() {self._shield = nil}

  var shieldMax: Float {
    get {return _shieldMax ?? 0}
    set {_shieldMax = newValue}
  }
  /// Returns true if `shieldMax` has been explicitly set.
  var hasShieldMax: Bool {return self._shieldMax != nil}
  /// Clears the value of `shieldMax`. Subsequent reads from it will return its default value.
  mutating func clearShieldMax() {self._shieldMax = nil}

  var energy: Float {
    get {return _energy ?? 0}
    set {_energy = newValue}
  }
  /// Returns true if `energy` has been explicitly set.
  var hasEnergy: Bool {return self._energy != nil}
  /// Clears the value of `energy`. Subsequent reads from it will return its default value.
  mutating func clearEnergy() {self._energy = nil}

  var energyMax: Float {
    get {return _energyMax ?? 0}
    set {_energyMax = newValue}
  }
  /// Returns true if `energyMax` has been explicitly set.
  var hasEnergyMax: Bool {return self._energyMax != nil}
  /// Clears the value of `energyMax`. Subsequent reads from it will return its default value.
  mutating func clearEnergyMax() {self._energyMax = nil}

  var unitType: UInt32 {
    get {return _unitType ?? 0}
    set {_unitType = newValue}
  }
  /// Returns true if `unitType` has been explicitly set.
  var hasUnitType: Bool {return self._unitType != nil}
  /// Clears the value of `unitType`. Subsequent reads from it will return its default value.
  mutating func clearUnitType() {self._unitType = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tag: UInt64? = nil
  fileprivate var _health: Float? = nil
  fileprivate var _healthMax: Float? = nil
  fileprivate var _shield: Float? = nil
  fileprivate var _shieldMax: Float? = nil
  fileprivate var _energy: Float? = nil
  fileprivate var _energyMax: Float? = nil
  fileprivate var _unitType: UInt32? = nil
}

struct SC2APIProtocol_RallyTarget {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Will always be filled.
  var point: SC2APIProtocol_Point {
    get {return _storage._point ?? SC2APIProtocol_Point()}
    set {_uniqueStorage()._point = newValue}
  }
  /// Returns true if `point` has been explicitly set.
  var hasPoint: Bool {return _storage._point != nil}
  /// Clears the value of `point`. Subsequent reads from it will return its default value.
  mutating func clearPoint() {_uniqueStorage()._point = nil}

  /// Only if it's targeting a unit.
  var tag: UInt64 {
    get {return _storage._tag ?? 0}
    set {_uniqueStorage()._tag = newValue}
  }
  /// Returns true if `tag` has been explicitly set.
  var hasTag: Bool {return _storage._tag != nil}
  /// Clears the value of `tag`. Subsequent reads from it will return its default value.
  mutating func clearTag() {_uniqueStorage()._tag = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_Unit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Fields are populated based on type/alliance
  var displayType: SC2APIProtocol_DisplayType {
    get {return _storage._displayType ?? .visible}
    set {_uniqueStorage()._displayType = newValue}
  }
  /// Returns true if `displayType` has been explicitly set.
  var hasDisplayType: Bool {return _storage._displayType != nil}
  /// Clears the value of `displayType`. Subsequent reads from it will return its default value.
  mutating func clearDisplayType() {_uniqueStorage()._displayType = nil}

  var alliance: SC2APIProtocol_Alliance {
    get {return _storage._alliance ?? .self_}
    set {_uniqueStorage()._alliance = newValue}
  }
  /// Returns true if `alliance` has been explicitly set.
  var hasAlliance: Bool {return _storage._alliance != nil}
  /// Clears the value of `alliance`. Subsequent reads from it will return its default value.
  mutating func clearAlliance() {_uniqueStorage()._alliance = nil}

  /// Unique identifier for a unit
  var tag: UInt64 {
    get {return _storage._tag ?? 0}
    set {_uniqueStorage()._tag = newValue}
  }
  /// Returns true if `tag` has been explicitly set.
  var hasTag: Bool {return _storage._tag != nil}
  /// Clears the value of `tag`. Subsequent reads from it will return its default value.
  mutating func clearTag() {_uniqueStorage()._tag = nil}

  var unitType: UInt32 {
    get {return _storage._unitType ?? 0}
    set {_uniqueStorage()._unitType = newValue}
  }
  /// Returns true if `unitType` has been explicitly set.
  var hasUnitType: Bool {return _storage._unitType != nil}
  /// Clears the value of `unitType`. Subsequent reads from it will return its default value.
  mutating func clearUnitType() {_uniqueStorage()._unitType = nil}

  var owner: Int32 {
    get {return _storage._owner ?? 0}
    set {_uniqueStorage()._owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  var hasOwner: Bool {return _storage._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  mutating func clearOwner() {_uniqueStorage()._owner = nil}

  var pos: SC2APIProtocol_Point {
    get {return _storage._pos ?? SC2APIProtocol_Point()}
    set {_uniqueStorage()._pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return _storage._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {_uniqueStorage()._pos = nil}

  var facing: Float {
    get {return _storage._facing ?? 0}
    set {_uniqueStorage()._facing = newValue}
  }
  /// Returns true if `facing` has been explicitly set.
  var hasFacing: Bool {return _storage._facing != nil}
  /// Clears the value of `facing`. Subsequent reads from it will return its default value.
  mutating func clearFacing() {_uniqueStorage()._facing = nil}

  var radius: Float {
    get {return _storage._radius ?? 0}
    set {_uniqueStorage()._radius = newValue}
  }
  /// Returns true if `radius` has been explicitly set.
  var hasRadius: Bool {return _storage._radius != nil}
  /// Clears the value of `radius`. Subsequent reads from it will return its default value.
  mutating func clearRadius() {_uniqueStorage()._radius = nil}

  /// Range: [0.0, 1.0]
  var buildProgress: Float {
    get {return _storage._buildProgress ?? 0}
    set {_uniqueStorage()._buildProgress = newValue}
  }
  /// Returns true if `buildProgress` has been explicitly set.
  var hasBuildProgress: Bool {return _storage._buildProgress != nil}
  /// Clears the value of `buildProgress`. Subsequent reads from it will return its default value.
  mutating func clearBuildProgress() {_uniqueStorage()._buildProgress = nil}

  var cloak: SC2APIProtocol_CloakState {
    get {return _storage._cloak ?? .cloakedUnknown}
    set {_uniqueStorage()._cloak = newValue}
  }
  /// Returns true if `cloak` has been explicitly set.
  var hasCloak: Bool {return _storage._cloak != nil}
  /// Clears the value of `cloak`. Subsequent reads from it will return its default value.
  mutating func clearCloak() {_uniqueStorage()._cloak = nil}

  var buffIds: [UInt32] {
    get {return _storage._buffIds}
    set {_uniqueStorage()._buffIds = newValue}
  }

  var detectRange: Float {
    get {return _storage._detectRange ?? 0}
    set {_uniqueStorage()._detectRange = newValue}
  }
  /// Returns true if `detectRange` has been explicitly set.
  var hasDetectRange: Bool {return _storage._detectRange != nil}
  /// Clears the value of `detectRange`. Subsequent reads from it will return its default value.
  mutating func clearDetectRange() {_uniqueStorage()._detectRange = nil}

  var radarRange: Float {
    get {return _storage._radarRange ?? 0}
    set {_uniqueStorage()._radarRange = newValue}
  }
  /// Returns true if `radarRange` has been explicitly set.
  var hasRadarRange: Bool {return _storage._radarRange != nil}
  /// Clears the value of `radarRange`. Subsequent reads from it will return its default value.
  mutating func clearRadarRange() {_uniqueStorage()._radarRange = nil}

  var isSelected: Bool {
    get {return _storage._isSelected ?? false}
    set {_uniqueStorage()._isSelected = newValue}
  }
  /// Returns true if `isSelected` has been explicitly set.
  var hasIsSelected: Bool {return _storage._isSelected != nil}
  /// Clears the value of `isSelected`. Subsequent reads from it will return its default value.
  mutating func clearIsSelected() {_uniqueStorage()._isSelected = nil}

  /// Visible and within the camera frustrum.
  var isOnScreen: Bool {
    get {return _storage._isOnScreen ?? false}
    set {_uniqueStorage()._isOnScreen = newValue}
  }
  /// Returns true if `isOnScreen` has been explicitly set.
  var hasIsOnScreen: Bool {return _storage._isOnScreen != nil}
  /// Clears the value of `isOnScreen`. Subsequent reads from it will return its default value.
  mutating func clearIsOnScreen() {_uniqueStorage()._isOnScreen = nil}

  /// Detected by sensor tower
  var isBlip: Bool {
    get {return _storage._isBlip ?? false}
    set {_uniqueStorage()._isBlip = newValue}
  }
  /// Returns true if `isBlip` has been explicitly set.
  var hasIsBlip: Bool {return _storage._isBlip != nil}
  /// Clears the value of `isBlip`. Subsequent reads from it will return its default value.
  mutating func clearIsBlip() {_uniqueStorage()._isBlip = nil}

  var isPowered: Bool {
    get {return _storage._isPowered ?? false}
    set {_uniqueStorage()._isPowered = newValue}
  }
  /// Returns true if `isPowered` has been explicitly set.
  var hasIsPowered: Bool {return _storage._isPowered != nil}
  /// Clears the value of `isPowered`. Subsequent reads from it will return its default value.
  mutating func clearIsPowered() {_uniqueStorage()._isPowered = nil}

  /// Building is training/researching (ie animated).
  var isActive: Bool {
    get {return _storage._isActive ?? false}
    set {_uniqueStorage()._isActive = newValue}
  }
  /// Returns true if `isActive` has been explicitly set.
  var hasIsActive: Bool {return _storage._isActive != nil}
  /// Clears the value of `isActive`. Subsequent reads from it will return its default value.
  mutating func clearIsActive() {_uniqueStorage()._isActive = nil}

  var attackUpgradeLevel: Int32 {
    get {return _storage._attackUpgradeLevel ?? 0}
    set {_uniqueStorage()._attackUpgradeLevel = newValue}
  }
  /// Returns true if `attackUpgradeLevel` has been explicitly set.
  var hasAttackUpgradeLevel: Bool {return _storage._attackUpgradeLevel != nil}
  /// Clears the value of `attackUpgradeLevel`. Subsequent reads from it will return its default value.
  mutating func clearAttackUpgradeLevel() {_uniqueStorage()._attackUpgradeLevel = nil}

  var armorUpgradeLevel: Int32 {
    get {return _storage._armorUpgradeLevel ?? 0}
    set {_uniqueStorage()._armorUpgradeLevel = newValue}
  }
  /// Returns true if `armorUpgradeLevel` has been explicitly set.
  var hasArmorUpgradeLevel: Bool {return _storage._armorUpgradeLevel != nil}
  /// Clears the value of `armorUpgradeLevel`. Subsequent reads from it will return its default value.
  mutating func clearArmorUpgradeLevel() {_uniqueStorage()._armorUpgradeLevel = nil}

  var shieldUpgradeLevel: Int32 {
    get {return _storage._shieldUpgradeLevel ?? 0}
    set {_uniqueStorage()._shieldUpgradeLevel = newValue}
  }
  /// Returns true if `shieldUpgradeLevel` has been explicitly set.
  var hasShieldUpgradeLevel: Bool {return _storage._shieldUpgradeLevel != nil}
  /// Clears the value of `shieldUpgradeLevel`. Subsequent reads from it will return its default value.
  mutating func clearShieldUpgradeLevel() {_uniqueStorage()._shieldUpgradeLevel = nil}

  /// Not populated for snapshots
  var health: Float {
    get {return _storage._health ?? 0}
    set {_uniqueStorage()._health = newValue}
  }
  /// Returns true if `health` has been explicitly set.
  var hasHealth: Bool {return _storage._health != nil}
  /// Clears the value of `health`. Subsequent reads from it will return its default value.
  mutating func clearHealth() {_uniqueStorage()._health = nil}

  var healthMax: Float {
    get {return _storage._healthMax ?? 0}
    set {_uniqueStorage()._healthMax = newValue}
  }
  /// Returns true if `healthMax` has been explicitly set.
  var hasHealthMax: Bool {return _storage._healthMax != nil}
  /// Clears the value of `healthMax`. Subsequent reads from it will return its default value.
  mutating func clearHealthMax() {_uniqueStorage()._healthMax = nil}

  var shield: Float {
    get {return _storage._shield ?? 0}
    set {_uniqueStorage()._shield = newValue}
  }
  /// Returns true if `shield` has been explicitly set.
  var hasShield: Bool {return _storage._shield != nil}
  /// Clears the value of `shield`. Subsequent reads from it will return its default value.
  mutating func clearShield() {_uniqueStorage()._shield = nil}

  var shieldMax: Float {
    get {return _storage._shieldMax ?? 0}
    set {_uniqueStorage()._shieldMax = newValue}
  }
  /// Returns true if `shieldMax` has been explicitly set.
  var hasShieldMax: Bool {return _storage._shieldMax != nil}
  /// Clears the value of `shieldMax`. Subsequent reads from it will return its default value.
  mutating func clearShieldMax() {_uniqueStorage()._shieldMax = nil}

  var energy: Float {
    get {return _storage._energy ?? 0}
    set {_uniqueStorage()._energy = newValue}
  }
  /// Returns true if `energy` has been explicitly set.
  var hasEnergy: Bool {return _storage._energy != nil}
  /// Clears the value of `energy`. Subsequent reads from it will return its default value.
  mutating func clearEnergy() {_uniqueStorage()._energy = nil}

  var energyMax: Float {
    get {return _storage._energyMax ?? 0}
    set {_uniqueStorage()._energyMax = newValue}
  }
  /// Returns true if `energyMax` has been explicitly set.
  var hasEnergyMax: Bool {return _storage._energyMax != nil}
  /// Clears the value of `energyMax`. Subsequent reads from it will return its default value.
  mutating func clearEnergyMax() {_uniqueStorage()._energyMax = nil}

  var mineralContents: Int32 {
    get {return _storage._mineralContents ?? 0}
    set {_uniqueStorage()._mineralContents = newValue}
  }
  /// Returns true if `mineralContents` has been explicitly set.
  var hasMineralContents: Bool {return _storage._mineralContents != nil}
  /// Clears the value of `mineralContents`. Subsequent reads from it will return its default value.
  mutating func clearMineralContents() {_uniqueStorage()._mineralContents = nil}

  var vespeneContents: Int32 {
    get {return _storage._vespeneContents ?? 0}
    set {_uniqueStorage()._vespeneContents = newValue}
  }
  /// Returns true if `vespeneContents` has been explicitly set.
  var hasVespeneContents: Bool {return _storage._vespeneContents != nil}
  /// Clears the value of `vespeneContents`. Subsequent reads from it will return its default value.
  mutating func clearVespeneContents() {_uniqueStorage()._vespeneContents = nil}

  var isFlying: Bool {
    get {return _storage._isFlying ?? false}
    set {_uniqueStorage()._isFlying = newValue}
  }
  /// Returns true if `isFlying` has been explicitly set.
  var hasIsFlying: Bool {return _storage._isFlying != nil}
  /// Clears the value of `isFlying`. Subsequent reads from it will return its default value.
  mutating func clearIsFlying() {_uniqueStorage()._isFlying = nil}

  var isBurrowed: Bool {
    get {return _storage._isBurrowed ?? false}
    set {_uniqueStorage()._isBurrowed = newValue}
  }
  /// Returns true if `isBurrowed` has been explicitly set.
  var hasIsBurrowed: Bool {return _storage._isBurrowed != nil}
  /// Clears the value of `isBurrowed`. Subsequent reads from it will return its default value.
  mutating func clearIsBurrowed() {_uniqueStorage()._isBurrowed = nil}

  /// Unit is your own or detected as a hallucination.
  var isHallucination: Bool {
    get {return _storage._isHallucination ?? false}
    set {_uniqueStorage()._isHallucination = newValue}
  }
  /// Returns true if `isHallucination` has been explicitly set.
  var hasIsHallucination: Bool {return _storage._isHallucination != nil}
  /// Clears the value of `isHallucination`. Subsequent reads from it will return its default value.
  mutating func clearIsHallucination() {_uniqueStorage()._isHallucination = nil}

  /// Not populated for enemies
  var orders: [SC2APIProtocol_UnitOrder] {
    get {return _storage._orders}
    set {_uniqueStorage()._orders = newValue}
  }

  var addOnTag: UInt64 {
    get {return _storage._addOnTag ?? 0}
    set {_uniqueStorage()._addOnTag = newValue}
  }
  /// Returns true if `addOnTag` has been explicitly set.
  var hasAddOnTag: Bool {return _storage._addOnTag != nil}
  /// Clears the value of `addOnTag`. Subsequent reads from it will return its default value.
  mutating func clearAddOnTag() {_uniqueStorage()._addOnTag = nil}

  var passengers: [SC2APIProtocol_PassengerUnit] {
    get {return _storage._passengers}
    set {_uniqueStorage()._passengers = newValue}
  }

  var cargoSpaceTaken: Int32 {
    get {return _storage._cargoSpaceTaken ?? 0}
    set {_uniqueStorage()._cargoSpaceTaken = newValue}
  }
  /// Returns true if `cargoSpaceTaken` has been explicitly set.
  var hasCargoSpaceTaken: Bool {return _storage._cargoSpaceTaken != nil}
  /// Clears the value of `cargoSpaceTaken`. Subsequent reads from it will return its default value.
  mutating func clearCargoSpaceTaken() {_uniqueStorage()._cargoSpaceTaken = nil}

  var cargoSpaceMax: Int32 {
    get {return _storage._cargoSpaceMax ?? 0}
    set {_uniqueStorage()._cargoSpaceMax = newValue}
  }
  /// Returns true if `cargoSpaceMax` has been explicitly set.
  var hasCargoSpaceMax: Bool {return _storage._cargoSpaceMax != nil}
  /// Clears the value of `cargoSpaceMax`. Subsequent reads from it will return its default value.
  mutating func clearCargoSpaceMax() {_uniqueStorage()._cargoSpaceMax = nil}

  var assignedHarvesters: Int32 {
    get {return _storage._assignedHarvesters ?? 0}
    set {_uniqueStorage()._assignedHarvesters = newValue}
  }
  /// Returns true if `assignedHarvesters` has been explicitly set.
  var hasAssignedHarvesters: Bool {return _storage._assignedHarvesters != nil}
  /// Clears the value of `assignedHarvesters`. Subsequent reads from it will return its default value.
  mutating func clearAssignedHarvesters() {_uniqueStorage()._assignedHarvesters = nil}

  var idealHarvesters: Int32 {
    get {return _storage._idealHarvesters ?? 0}
    set {_uniqueStorage()._idealHarvesters = newValue}
  }
  /// Returns true if `idealHarvesters` has been explicitly set.
  var hasIdealHarvesters: Bool {return _storage._idealHarvesters != nil}
  /// Clears the value of `idealHarvesters`. Subsequent reads from it will return its default value.
  mutating func clearIdealHarvesters() {_uniqueStorage()._idealHarvesters = nil}

  var weaponCooldown: Float {
    get {return _storage._weaponCooldown ?? 0}
    set {_uniqueStorage()._weaponCooldown = newValue}
  }
  /// Returns true if `weaponCooldown` has been explicitly set.
  var hasWeaponCooldown: Bool {return _storage._weaponCooldown != nil}
  /// Clears the value of `weaponCooldown`. Subsequent reads from it will return its default value.
  mutating func clearWeaponCooldown() {_uniqueStorage()._weaponCooldown = nil}

  var engagedTargetTag: UInt64 {
    get {return _storage._engagedTargetTag ?? 0}
    set {_uniqueStorage()._engagedTargetTag = newValue}
  }
  /// Returns true if `engagedTargetTag` has been explicitly set.
  var hasEngagedTargetTag: Bool {return _storage._engagedTargetTag != nil}
  /// Clears the value of `engagedTargetTag`. Subsequent reads from it will return its default value.
  mutating func clearEngagedTargetTag() {_uniqueStorage()._engagedTargetTag = nil}

  /// How long a buff or unit is still around (eg mule, broodling, chronoboost).
  var buffDurationRemain: Int32 {
    get {return _storage._buffDurationRemain ?? 0}
    set {_uniqueStorage()._buffDurationRemain = newValue}
  }
  /// Returns true if `buffDurationRemain` has been explicitly set.
  var hasBuffDurationRemain: Bool {return _storage._buffDurationRemain != nil}
  /// Clears the value of `buffDurationRemain`. Subsequent reads from it will return its default value.
  mutating func clearBuffDurationRemain() {_uniqueStorage()._buffDurationRemain = nil}

  /// How long the buff or unit is still around (eg mule, broodling, chronoboost).
  var buffDurationMax: Int32 {
    get {return _storage._buffDurationMax ?? 0}
    set {_uniqueStorage()._buffDurationMax = newValue}
  }
  /// Returns true if `buffDurationMax` has been explicitly set.
  var hasBuffDurationMax: Bool {return _storage._buffDurationMax != nil}
  /// Clears the value of `buffDurationMax`. Subsequent reads from it will return its default value.
  mutating func clearBuffDurationMax() {_uniqueStorage()._buffDurationMax = nil}

  var rallyTargets: [SC2APIProtocol_RallyTarget] {
    get {return _storage._rallyTargets}
    set {_uniqueStorage()._rallyTargets = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_MapState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 1 byte visibility layer.
  var visibility: SC2APIProtocol_ImageData {
    get {return _storage._visibility ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._visibility = newValue}
  }
  /// Returns true if `visibility` has been explicitly set.
  var hasVisibility: Bool {return _storage._visibility != nil}
  /// Clears the value of `visibility`. Subsequent reads from it will return its default value.
  mutating func clearVisibility() {_uniqueStorage()._visibility = nil}

  /// 1 bit creep layer.
  var creep: SC2APIProtocol_ImageData {
    get {return _storage._creep ?? SC2APIProtocol_ImageData()}
    set {_uniqueStorage()._creep = newValue}
  }
  /// Returns true if `creep` has been explicitly set.
  var hasCreep: Bool {return _storage._creep != nil}
  /// Clears the value of `creep`. Subsequent reads from it will return its default value.
  mutating func clearCreep() {_uniqueStorage()._creep = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_Event {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deadUnits: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SC2APIProtocol_Effect {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var effectID: UInt32 {
    get {return _effectID ?? 0}
    set {_effectID = newValue}
  }
  /// Returns true if `effectID` has been explicitly set.
  var hasEffectID: Bool {return self._effectID != nil}
  /// Clears the value of `effectID`. Subsequent reads from it will return its default value.
  mutating func clearEffectID() {self._effectID = nil}

  /// Effect may impact multiple locations. (eg. Lurker attack)
  var pos: [SC2APIProtocol_Point2D] = []

  var alliance: SC2APIProtocol_Alliance {
    get {return _alliance ?? .self_}
    set {_alliance = newValue}
  }
  /// Returns true if `alliance` has been explicitly set.
  var hasAlliance: Bool {return self._alliance != nil}
  /// Clears the value of `alliance`. Subsequent reads from it will return its default value.
  mutating func clearAlliance() {self._alliance = nil}

  var owner: Int32 {
    get {return _owner ?? 0}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  mutating func clearOwner() {self._owner = nil}

  var radius: Float {
    get {return _radius ?? 0}
    set {_radius = newValue}
  }
  /// Returns true if `radius` has been explicitly set.
  var hasRadius: Bool {return self._radius != nil}
  /// Clears the value of `radius`. Subsequent reads from it will return its default value.
  mutating func clearRadius() {self._radius = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _effectID: UInt32? = nil
  fileprivate var _alliance: SC2APIProtocol_Alliance? = nil
  fileprivate var _owner: Int32? = nil
  fileprivate var _radius: Float? = nil
}

struct SC2APIProtocol_ActionRaw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var action: OneOf_Action? {
    get {return _storage._action}
    set {_uniqueStorage()._action = newValue}
  }

  var unitCommand: SC2APIProtocol_ActionRawUnitCommand {
    get {
      if case .unitCommand(let v)? = _storage._action {return v}
      return SC2APIProtocol_ActionRawUnitCommand()
    }
    set {_uniqueStorage()._action = .unitCommand(newValue)}
  }

  var cameraMove: SC2APIProtocol_ActionRawCameraMove {
    get {
      if case .cameraMove(let v)? = _storage._action {return v}
      return SC2APIProtocol_ActionRawCameraMove()
    }
    set {_uniqueStorage()._action = .cameraMove(newValue)}
  }

  var toggleAutocast: SC2APIProtocol_ActionRawToggleAutocast {
    get {
      if case .toggleAutocast(let v)? = _storage._action {return v}
      return SC2APIProtocol_ActionRawToggleAutocast()
    }
    set {_uniqueStorage()._action = .toggleAutocast(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Action: Equatable {
    case unitCommand(SC2APIProtocol_ActionRawUnitCommand)
    case cameraMove(SC2APIProtocol_ActionRawCameraMove)
    case toggleAutocast(SC2APIProtocol_ActionRawToggleAutocast)

  #if !swift(>=4.1)
    static func ==(lhs: SC2APIProtocol_ActionRaw.OneOf_Action, rhs: SC2APIProtocol_ActionRaw.OneOf_Action) -> Bool {
      switch (lhs, rhs) {
      case (.unitCommand(let l), .unitCommand(let r)): return l == r
      case (.cameraMove(let l), .cameraMove(let r)): return l == r
      case (.toggleAutocast(let l), .toggleAutocast(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_ActionRawUnitCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var abilityID: Int32 {
    get {return _storage._abilityID ?? 0}
    set {_uniqueStorage()._abilityID = newValue}
  }
  /// Returns true if `abilityID` has been explicitly set.
  var hasAbilityID: Bool {return _storage._abilityID != nil}
  /// Clears the value of `abilityID`. Subsequent reads from it will return its default value.
  mutating func clearAbilityID() {_uniqueStorage()._abilityID = nil}

  var target: OneOf_Target? {
    get {return _storage._target}
    set {_uniqueStorage()._target = newValue}
  }

  var targetWorldSpacePos: SC2APIProtocol_Point2D {
    get {
      if case .targetWorldSpacePos(let v)? = _storage._target {return v}
      return SC2APIProtocol_Point2D()
    }
    set {_uniqueStorage()._target = .targetWorldSpacePos(newValue)}
  }

  var targetUnitTag: UInt64 {
    get {
      if case .targetUnitTag(let v)? = _storage._target {return v}
      return 0
    }
    set {_uniqueStorage()._target = .targetUnitTag(newValue)}
  }

  var unitTags: [UInt64] {
    get {return _storage._unitTags}
    set {_uniqueStorage()._unitTags = newValue}
  }

  var queueCommand: Bool {
    get {return _storage._queueCommand ?? false}
    set {_uniqueStorage()._queueCommand = newValue}
  }
  /// Returns true if `queueCommand` has been explicitly set.
  var hasQueueCommand: Bool {return _storage._queueCommand != nil}
  /// Clears the value of `queueCommand`. Subsequent reads from it will return its default value.
  mutating func clearQueueCommand() {_uniqueStorage()._queueCommand = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Target: Equatable {
    case targetWorldSpacePos(SC2APIProtocol_Point2D)
    case targetUnitTag(UInt64)

  #if !swift(>=4.1)
    static func ==(lhs: SC2APIProtocol_ActionRawUnitCommand.OneOf_Target, rhs: SC2APIProtocol_ActionRawUnitCommand.OneOf_Target) -> Bool {
      switch (lhs, rhs) {
      case (.targetWorldSpacePos(let l), .targetWorldSpacePos(let r)): return l == r
      case (.targetUnitTag(let l), .targetUnitTag(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_ActionRawCameraMove {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var centerWorldSpace: SC2APIProtocol_Point {
    get {return _storage._centerWorldSpace ?? SC2APIProtocol_Point()}
    set {_uniqueStorage()._centerWorldSpace = newValue}
  }
  /// Returns true if `centerWorldSpace` has been explicitly set.
  var hasCenterWorldSpace: Bool {return _storage._centerWorldSpace != nil}
  /// Clears the value of `centerWorldSpace`. Subsequent reads from it will return its default value.
  mutating func clearCenterWorldSpace() {_uniqueStorage()._centerWorldSpace = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SC2APIProtocol_ActionRawToggleAutocast {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var abilityID: Int32 {
    get {return _abilityID ?? 0}
    set {_abilityID = newValue}
  }
  /// Returns true if `abilityID` has been explicitly set.
  var hasAbilityID: Bool {return self._abilityID != nil}
  /// Clears the value of `abilityID`. Subsequent reads from it will return its default value.
  mutating func clearAbilityID() {self._abilityID = nil}

  var unitTags: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _abilityID: Int32? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "SC2APIProtocol"

extension SC2APIProtocol_DisplayType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Visible"),
    2: .same(proto: "Snapshot"),
    3: .same(proto: "Hidden"),
    4: .same(proto: "Placeholder"),
  ]
}

extension SC2APIProtocol_Alliance: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Self"),
    2: .same(proto: "Ally"),
    3: .same(proto: "Neutral"),
    4: .same(proto: "Enemy"),
  ]
}

extension SC2APIProtocol_CloakState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CloakedUnknown"),
    1: .same(proto: "Cloaked"),
    2: .same(proto: "CloakedDetected"),
    3: .same(proto: "NotCloaked"),
    4: .same(proto: "CloakedAllied"),
  ]
}

extension SC2APIProtocol_StartRaw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StartRaw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "map_size"),
    2: .standard(proto: "pathing_grid"),
    3: .standard(proto: "terrain_height"),
    4: .standard(proto: "placement_grid"),
    5: .standard(proto: "playable_area"),
    6: .standard(proto: "start_locations"),
  ]

  fileprivate class _StorageClass {
    var _mapSize: SC2APIProtocol_Size2DI? = nil
    var _pathingGrid: SC2APIProtocol_ImageData? = nil
    var _terrainHeight: SC2APIProtocol_ImageData? = nil
    var _placementGrid: SC2APIProtocol_ImageData? = nil
    var _playableArea: SC2APIProtocol_RectangleI? = nil
    var _startLocations: [SC2APIProtocol_Point2D] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _mapSize = source._mapSize
      _pathingGrid = source._pathingGrid
      _terrainHeight = source._terrainHeight
      _placementGrid = source._placementGrid
      _playableArea = source._playableArea
      _startLocations = source._startLocations
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._mapSize)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._pathingGrid)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._terrainHeight)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._placementGrid)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._playableArea)
        case 6: try decoder.decodeRepeatedMessageField(value: &_storage._startLocations)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._mapSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._pathingGrid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._terrainHeight {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._placementGrid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._playableArea {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._startLocations.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._startLocations, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_StartRaw, rhs: SC2APIProtocol_StartRaw) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._mapSize != rhs_storage._mapSize {return false}
        if _storage._pathingGrid != rhs_storage._pathingGrid {return false}
        if _storage._terrainHeight != rhs_storage._terrainHeight {return false}
        if _storage._placementGrid != rhs_storage._placementGrid {return false}
        if _storage._playableArea != rhs_storage._playableArea {return false}
        if _storage._startLocations != rhs_storage._startLocations {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ObservationRaw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ObservationRaw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "player"),
    2: .same(proto: "units"),
    3: .standard(proto: "map_state"),
    4: .same(proto: "event"),
    5: .same(proto: "effects"),
    6: .same(proto: "radar"),
  ]

  fileprivate class _StorageClass {
    var _player: SC2APIProtocol_PlayerRaw? = nil
    var _units: [SC2APIProtocol_Unit] = []
    var _mapState: SC2APIProtocol_MapState? = nil
    var _event: SC2APIProtocol_Event? = nil
    var _effects: [SC2APIProtocol_Effect] = []
    var _radar: [SC2APIProtocol_RadarRing] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _player = source._player
      _units = source._units
      _mapState = source._mapState
      _event = source._event
      _effects = source._effects
      _radar = source._radar
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._player)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._units)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._mapState)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._event)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._effects)
        case 6: try decoder.decodeRepeatedMessageField(value: &_storage._radar)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._player {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._units.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._units, fieldNumber: 2)
      }
      if let v = _storage._mapState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._event {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._effects.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._effects, fieldNumber: 5)
      }
      if !_storage._radar.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._radar, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ObservationRaw, rhs: SC2APIProtocol_ObservationRaw) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._player != rhs_storage._player {return false}
        if _storage._units != rhs_storage._units {return false}
        if _storage._mapState != rhs_storage._mapState {return false}
        if _storage._event != rhs_storage._event {return false}
        if _storage._effects != rhs_storage._effects {return false}
        if _storage._radar != rhs_storage._radar {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_RadarRing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RadarRing"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "radius"),
  ]

  fileprivate class _StorageClass {
    var _pos: SC2APIProtocol_Point? = nil
    var _radius: Float? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _pos = source._pos
      _radius = source._radius
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._pos)
        case 2: try decoder.decodeSingularFloatField(value: &_storage._radius)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._pos {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._radius {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_RadarRing, rhs: SC2APIProtocol_RadarRing) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._pos != rhs_storage._pos {return false}
        if _storage._radius != rhs_storage._radius {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_PowerSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PowerSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .same(proto: "radius"),
    3: .same(proto: "tag"),
  ]

  fileprivate class _StorageClass {
    var _pos: SC2APIProtocol_Point? = nil
    var _radius: Float? = nil
    var _tag: UInt64? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _pos = source._pos
      _radius = source._radius
      _tag = source._tag
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._pos)
        case 2: try decoder.decodeSingularFloatField(value: &_storage._radius)
        case 3: try decoder.decodeSingularUInt64Field(value: &_storage._tag)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._pos {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._radius {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
      }
      if let v = _storage._tag {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_PowerSource, rhs: SC2APIProtocol_PowerSource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._pos != rhs_storage._pos {return false}
        if _storage._radius != rhs_storage._radius {return false}
        if _storage._tag != rhs_storage._tag {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_PlayerRaw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayerRaw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "power_sources"),
    2: .same(proto: "camera"),
    3: .standard(proto: "upgrade_ids"),
  ]

  fileprivate class _StorageClass {
    var _powerSources: [SC2APIProtocol_PowerSource] = []
    var _camera: SC2APIProtocol_Point? = nil
    var _upgradeIds: [UInt32] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _powerSources = source._powerSources
      _camera = source._camera
      _upgradeIds = source._upgradeIds
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._powerSources)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._camera)
        case 3: try decoder.decodeRepeatedUInt32Field(value: &_storage._upgradeIds)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._powerSources.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._powerSources, fieldNumber: 1)
      }
      if let v = _storage._camera {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._upgradeIds.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._upgradeIds, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_PlayerRaw, rhs: SC2APIProtocol_PlayerRaw) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._powerSources != rhs_storage._powerSources {return false}
        if _storage._camera != rhs_storage._camera {return false}
        if _storage._upgradeIds != rhs_storage._upgradeIds {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_UnitOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnitOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ability_id"),
    2: .standard(proto: "target_world_space_pos"),
    3: .standard(proto: "target_unit_tag"),
    4: .same(proto: "progress"),
  ]

  fileprivate class _StorageClass {
    var _abilityID: UInt32? = nil
    var _target: SC2APIProtocol_UnitOrder.OneOf_Target?
    var _progress: Float? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _abilityID = source._abilityID
      _target = source._target
      _progress = source._progress
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._abilityID)
        case 2:
          var v: SC2APIProtocol_Point?
          if let current = _storage._target {
            try decoder.handleConflictingOneOf()
            if case .targetWorldSpacePos(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._target = .targetWorldSpacePos(v)}
        case 3:
          if _storage._target != nil {try decoder.handleConflictingOneOf()}
          var v: UInt64?
          try decoder.decodeSingularUInt64Field(value: &v)
          if let v = v {_storage._target = .targetUnitTag(v)}
        case 4: try decoder.decodeSingularFloatField(value: &_storage._progress)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._abilityID {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
      }
      switch _storage._target {
      case .targetWorldSpacePos(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .targetUnitTag(let v)?:
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
      case nil: break
      }
      if let v = _storage._progress {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_UnitOrder, rhs: SC2APIProtocol_UnitOrder) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._abilityID != rhs_storage._abilityID {return false}
        if _storage._target != rhs_storage._target {return false}
        if _storage._progress != rhs_storage._progress {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_PassengerUnit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PassengerUnit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tag"),
    2: .same(proto: "health"),
    3: .standard(proto: "health_max"),
    4: .same(proto: "shield"),
    7: .standard(proto: "shield_max"),
    5: .same(proto: "energy"),
    8: .standard(proto: "energy_max"),
    6: .standard(proto: "unit_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self._tag)
      case 2: try decoder.decodeSingularFloatField(value: &self._health)
      case 3: try decoder.decodeSingularFloatField(value: &self._healthMax)
      case 4: try decoder.decodeSingularFloatField(value: &self._shield)
      case 5: try decoder.decodeSingularFloatField(value: &self._energy)
      case 6: try decoder.decodeSingularUInt32Field(value: &self._unitType)
      case 7: try decoder.decodeSingularFloatField(value: &self._shieldMax)
      case 8: try decoder.decodeSingularFloatField(value: &self._energyMax)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._tag {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }
    if let v = self._health {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    }
    if let v = self._healthMax {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    }
    if let v = self._shield {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    }
    if let v = self._energy {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    }
    if let v = self._unitType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    if let v = self._shieldMax {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 7)
    }
    if let v = self._energyMax {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_PassengerUnit, rhs: SC2APIProtocol_PassengerUnit) -> Bool {
    if lhs._tag != rhs._tag {return false}
    if lhs._health != rhs._health {return false}
    if lhs._healthMax != rhs._healthMax {return false}
    if lhs._shield != rhs._shield {return false}
    if lhs._shieldMax != rhs._shieldMax {return false}
    if lhs._energy != rhs._energy {return false}
    if lhs._energyMax != rhs._energyMax {return false}
    if lhs._unitType != rhs._unitType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_RallyTarget: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RallyTarget"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "point"),
    2: .same(proto: "tag"),
  ]

  fileprivate class _StorageClass {
    var _point: SC2APIProtocol_Point? = nil
    var _tag: UInt64? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _point = source._point
      _tag = source._tag
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._point)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._tag)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._point {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._tag {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_RallyTarget, rhs: SC2APIProtocol_RallyTarget) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._point != rhs_storage._point {return false}
        if _storage._tag != rhs_storage._tag {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_Unit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Unit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "display_type"),
    2: .same(proto: "alliance"),
    3: .same(proto: "tag"),
    4: .standard(proto: "unit_type"),
    5: .same(proto: "owner"),
    6: .same(proto: "pos"),
    7: .same(proto: "facing"),
    8: .same(proto: "radius"),
    9: .standard(proto: "build_progress"),
    10: .same(proto: "cloak"),
    27: .standard(proto: "buff_ids"),
    31: .standard(proto: "detect_range"),
    32: .standard(proto: "radar_range"),
    11: .standard(proto: "is_selected"),
    12: .standard(proto: "is_on_screen"),
    13: .standard(proto: "is_blip"),
    35: .standard(proto: "is_powered"),
    39: .standard(proto: "is_active"),
    40: .standard(proto: "attack_upgrade_level"),
    41: .standard(proto: "armor_upgrade_level"),
    42: .standard(proto: "shield_upgrade_level"),
    14: .same(proto: "health"),
    15: .standard(proto: "health_max"),
    16: .same(proto: "shield"),
    36: .standard(proto: "shield_max"),
    17: .same(proto: "energy"),
    37: .standard(proto: "energy_max"),
    18: .standard(proto: "mineral_contents"),
    19: .standard(proto: "vespene_contents"),
    20: .standard(proto: "is_flying"),
    21: .standard(proto: "is_burrowed"),
    38: .standard(proto: "is_hallucination"),
    22: .same(proto: "orders"),
    23: .standard(proto: "add_on_tag"),
    24: .same(proto: "passengers"),
    25: .standard(proto: "cargo_space_taken"),
    26: .standard(proto: "cargo_space_max"),
    28: .standard(proto: "assigned_harvesters"),
    29: .standard(proto: "ideal_harvesters"),
    30: .standard(proto: "weapon_cooldown"),
    34: .standard(proto: "engaged_target_tag"),
    43: .standard(proto: "buff_duration_remain"),
    44: .standard(proto: "buff_duration_max"),
    45: .standard(proto: "rally_targets"),
  ]

  fileprivate class _StorageClass {
    var _displayType: SC2APIProtocol_DisplayType? = nil
    var _alliance: SC2APIProtocol_Alliance? = nil
    var _tag: UInt64? = nil
    var _unitType: UInt32? = nil
    var _owner: Int32? = nil
    var _pos: SC2APIProtocol_Point? = nil
    var _facing: Float? = nil
    var _radius: Float? = nil
    var _buildProgress: Float? = nil
    var _cloak: SC2APIProtocol_CloakState? = nil
    var _buffIds: [UInt32] = []
    var _detectRange: Float? = nil
    var _radarRange: Float? = nil
    var _isSelected: Bool? = nil
    var _isOnScreen: Bool? = nil
    var _isBlip: Bool? = nil
    var _isPowered: Bool? = nil
    var _isActive: Bool? = nil
    var _attackUpgradeLevel: Int32? = nil
    var _armorUpgradeLevel: Int32? = nil
    var _shieldUpgradeLevel: Int32? = nil
    var _health: Float? = nil
    var _healthMax: Float? = nil
    var _shield: Float? = nil
    var _shieldMax: Float? = nil
    var _energy: Float? = nil
    var _energyMax: Float? = nil
    var _mineralContents: Int32? = nil
    var _vespeneContents: Int32? = nil
    var _isFlying: Bool? = nil
    var _isBurrowed: Bool? = nil
    var _isHallucination: Bool? = nil
    var _orders: [SC2APIProtocol_UnitOrder] = []
    var _addOnTag: UInt64? = nil
    var _passengers: [SC2APIProtocol_PassengerUnit] = []
    var _cargoSpaceTaken: Int32? = nil
    var _cargoSpaceMax: Int32? = nil
    var _assignedHarvesters: Int32? = nil
    var _idealHarvesters: Int32? = nil
    var _weaponCooldown: Float? = nil
    var _engagedTargetTag: UInt64? = nil
    var _buffDurationRemain: Int32? = nil
    var _buffDurationMax: Int32? = nil
    var _rallyTargets: [SC2APIProtocol_RallyTarget] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _displayType = source._displayType
      _alliance = source._alliance
      _tag = source._tag
      _unitType = source._unitType
      _owner = source._owner
      _pos = source._pos
      _facing = source._facing
      _radius = source._radius
      _buildProgress = source._buildProgress
      _cloak = source._cloak
      _buffIds = source._buffIds
      _detectRange = source._detectRange
      _radarRange = source._radarRange
      _isSelected = source._isSelected
      _isOnScreen = source._isOnScreen
      _isBlip = source._isBlip
      _isPowered = source._isPowered
      _isActive = source._isActive
      _attackUpgradeLevel = source._attackUpgradeLevel
      _armorUpgradeLevel = source._armorUpgradeLevel
      _shieldUpgradeLevel = source._shieldUpgradeLevel
      _health = source._health
      _healthMax = source._healthMax
      _shield = source._shield
      _shieldMax = source._shieldMax
      _energy = source._energy
      _energyMax = source._energyMax
      _mineralContents = source._mineralContents
      _vespeneContents = source._vespeneContents
      _isFlying = source._isFlying
      _isBurrowed = source._isBurrowed
      _isHallucination = source._isHallucination
      _orders = source._orders
      _addOnTag = source._addOnTag
      _passengers = source._passengers
      _cargoSpaceTaken = source._cargoSpaceTaken
      _cargoSpaceMax = source._cargoSpaceMax
      _assignedHarvesters = source._assignedHarvesters
      _idealHarvesters = source._idealHarvesters
      _weaponCooldown = source._weaponCooldown
      _engagedTargetTag = source._engagedTargetTag
      _buffDurationRemain = source._buffDurationRemain
      _buffDurationMax = source._buffDurationMax
      _rallyTargets = source._rallyTargets
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._displayType)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._alliance)
        case 3: try decoder.decodeSingularUInt64Field(value: &_storage._tag)
        case 4: try decoder.decodeSingularUInt32Field(value: &_storage._unitType)
        case 5: try decoder.decodeSingularInt32Field(value: &_storage._owner)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._pos)
        case 7: try decoder.decodeSingularFloatField(value: &_storage._facing)
        case 8: try decoder.decodeSingularFloatField(value: &_storage._radius)
        case 9: try decoder.decodeSingularFloatField(value: &_storage._buildProgress)
        case 10: try decoder.decodeSingularEnumField(value: &_storage._cloak)
        case 11: try decoder.decodeSingularBoolField(value: &_storage._isSelected)
        case 12: try decoder.decodeSingularBoolField(value: &_storage._isOnScreen)
        case 13: try decoder.decodeSingularBoolField(value: &_storage._isBlip)
        case 14: try decoder.decodeSingularFloatField(value: &_storage._health)
        case 15: try decoder.decodeSingularFloatField(value: &_storage._healthMax)
        case 16: try decoder.decodeSingularFloatField(value: &_storage._shield)
        case 17: try decoder.decodeSingularFloatField(value: &_storage._energy)
        case 18: try decoder.decodeSingularInt32Field(value: &_storage._mineralContents)
        case 19: try decoder.decodeSingularInt32Field(value: &_storage._vespeneContents)
        case 20: try decoder.decodeSingularBoolField(value: &_storage._isFlying)
        case 21: try decoder.decodeSingularBoolField(value: &_storage._isBurrowed)
        case 22: try decoder.decodeRepeatedMessageField(value: &_storage._orders)
        case 23: try decoder.decodeSingularUInt64Field(value: &_storage._addOnTag)
        case 24: try decoder.decodeRepeatedMessageField(value: &_storage._passengers)
        case 25: try decoder.decodeSingularInt32Field(value: &_storage._cargoSpaceTaken)
        case 26: try decoder.decodeSingularInt32Field(value: &_storage._cargoSpaceMax)
        case 27: try decoder.decodeRepeatedUInt32Field(value: &_storage._buffIds)
        case 28: try decoder.decodeSingularInt32Field(value: &_storage._assignedHarvesters)
        case 29: try decoder.decodeSingularInt32Field(value: &_storage._idealHarvesters)
        case 30: try decoder.decodeSingularFloatField(value: &_storage._weaponCooldown)
        case 31: try decoder.decodeSingularFloatField(value: &_storage._detectRange)
        case 32: try decoder.decodeSingularFloatField(value: &_storage._radarRange)
        case 34: try decoder.decodeSingularUInt64Field(value: &_storage._engagedTargetTag)
        case 35: try decoder.decodeSingularBoolField(value: &_storage._isPowered)
        case 36: try decoder.decodeSingularFloatField(value: &_storage._shieldMax)
        case 37: try decoder.decodeSingularFloatField(value: &_storage._energyMax)
        case 38: try decoder.decodeSingularBoolField(value: &_storage._isHallucination)
        case 39: try decoder.decodeSingularBoolField(value: &_storage._isActive)
        case 40: try decoder.decodeSingularInt32Field(value: &_storage._attackUpgradeLevel)
        case 41: try decoder.decodeSingularInt32Field(value: &_storage._armorUpgradeLevel)
        case 42: try decoder.decodeSingularInt32Field(value: &_storage._shieldUpgradeLevel)
        case 43: try decoder.decodeSingularInt32Field(value: &_storage._buffDurationRemain)
        case 44: try decoder.decodeSingularInt32Field(value: &_storage._buffDurationMax)
        case 45: try decoder.decodeRepeatedMessageField(value: &_storage._rallyTargets)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._displayType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      }
      if let v = _storage._alliance {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      }
      if let v = _storage._tag {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
      }
      if let v = _storage._unitType {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      }
      if let v = _storage._owner {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
      }
      if let v = _storage._pos {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._facing {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 7)
      }
      if let v = _storage._radius {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 8)
      }
      if let v = _storage._buildProgress {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 9)
      }
      if let v = _storage._cloak {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 10)
      }
      if let v = _storage._isSelected {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
      }
      if let v = _storage._isOnScreen {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
      }
      if let v = _storage._isBlip {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
      }
      if let v = _storage._health {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 14)
      }
      if let v = _storage._healthMax {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 15)
      }
      if let v = _storage._shield {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 16)
      }
      if let v = _storage._energy {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 17)
      }
      if let v = _storage._mineralContents {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 18)
      }
      if let v = _storage._vespeneContents {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 19)
      }
      if let v = _storage._isFlying {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 20)
      }
      if let v = _storage._isBurrowed {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 21)
      }
      if !_storage._orders.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._orders, fieldNumber: 22)
      }
      if let v = _storage._addOnTag {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 23)
      }
      if !_storage._passengers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._passengers, fieldNumber: 24)
      }
      if let v = _storage._cargoSpaceTaken {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 25)
      }
      if let v = _storage._cargoSpaceMax {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 26)
      }
      if !_storage._buffIds.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._buffIds, fieldNumber: 27)
      }
      if let v = _storage._assignedHarvesters {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 28)
      }
      if let v = _storage._idealHarvesters {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 29)
      }
      if let v = _storage._weaponCooldown {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 30)
      }
      if let v = _storage._detectRange {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 31)
      }
      if let v = _storage._radarRange {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 32)
      }
      if let v = _storage._engagedTargetTag {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 34)
      }
      if let v = _storage._isPowered {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 35)
      }
      if let v = _storage._shieldMax {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 36)
      }
      if let v = _storage._energyMax {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 37)
      }
      if let v = _storage._isHallucination {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 38)
      }
      if let v = _storage._isActive {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 39)
      }
      if let v = _storage._attackUpgradeLevel {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 40)
      }
      if let v = _storage._armorUpgradeLevel {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 41)
      }
      if let v = _storage._shieldUpgradeLevel {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 42)
      }
      if let v = _storage._buffDurationRemain {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 43)
      }
      if let v = _storage._buffDurationMax {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 44)
      }
      if !_storage._rallyTargets.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._rallyTargets, fieldNumber: 45)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_Unit, rhs: SC2APIProtocol_Unit) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._displayType != rhs_storage._displayType {return false}
        if _storage._alliance != rhs_storage._alliance {return false}
        if _storage._tag != rhs_storage._tag {return false}
        if _storage._unitType != rhs_storage._unitType {return false}
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._pos != rhs_storage._pos {return false}
        if _storage._facing != rhs_storage._facing {return false}
        if _storage._radius != rhs_storage._radius {return false}
        if _storage._buildProgress != rhs_storage._buildProgress {return false}
        if _storage._cloak != rhs_storage._cloak {return false}
        if _storage._buffIds != rhs_storage._buffIds {return false}
        if _storage._detectRange != rhs_storage._detectRange {return false}
        if _storage._radarRange != rhs_storage._radarRange {return false}
        if _storage._isSelected != rhs_storage._isSelected {return false}
        if _storage._isOnScreen != rhs_storage._isOnScreen {return false}
        if _storage._isBlip != rhs_storage._isBlip {return false}
        if _storage._isPowered != rhs_storage._isPowered {return false}
        if _storage._isActive != rhs_storage._isActive {return false}
        if _storage._attackUpgradeLevel != rhs_storage._attackUpgradeLevel {return false}
        if _storage._armorUpgradeLevel != rhs_storage._armorUpgradeLevel {return false}
        if _storage._shieldUpgradeLevel != rhs_storage._shieldUpgradeLevel {return false}
        if _storage._health != rhs_storage._health {return false}
        if _storage._healthMax != rhs_storage._healthMax {return false}
        if _storage._shield != rhs_storage._shield {return false}
        if _storage._shieldMax != rhs_storage._shieldMax {return false}
        if _storage._energy != rhs_storage._energy {return false}
        if _storage._energyMax != rhs_storage._energyMax {return false}
        if _storage._mineralContents != rhs_storage._mineralContents {return false}
        if _storage._vespeneContents != rhs_storage._vespeneContents {return false}
        if _storage._isFlying != rhs_storage._isFlying {return false}
        if _storage._isBurrowed != rhs_storage._isBurrowed {return false}
        if _storage._isHallucination != rhs_storage._isHallucination {return false}
        if _storage._orders != rhs_storage._orders {return false}
        if _storage._addOnTag != rhs_storage._addOnTag {return false}
        if _storage._passengers != rhs_storage._passengers {return false}
        if _storage._cargoSpaceTaken != rhs_storage._cargoSpaceTaken {return false}
        if _storage._cargoSpaceMax != rhs_storage._cargoSpaceMax {return false}
        if _storage._assignedHarvesters != rhs_storage._assignedHarvesters {return false}
        if _storage._idealHarvesters != rhs_storage._idealHarvesters {return false}
        if _storage._weaponCooldown != rhs_storage._weaponCooldown {return false}
        if _storage._engagedTargetTag != rhs_storage._engagedTargetTag {return false}
        if _storage._buffDurationRemain != rhs_storage._buffDurationRemain {return false}
        if _storage._buffDurationMax != rhs_storage._buffDurationMax {return false}
        if _storage._rallyTargets != rhs_storage._rallyTargets {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_MapState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MapState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visibility"),
    2: .same(proto: "creep"),
  ]

  fileprivate class _StorageClass {
    var _visibility: SC2APIProtocol_ImageData? = nil
    var _creep: SC2APIProtocol_ImageData? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _visibility = source._visibility
      _creep = source._creep
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._visibility)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._creep)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._visibility {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._creep {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_MapState, rhs: SC2APIProtocol_MapState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._visibility != rhs_storage._visibility {return false}
        if _storage._creep != rhs_storage._creep {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Event"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dead_units"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedUInt64Field(value: &self.deadUnits)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deadUnits.isEmpty {
      try visitor.visitRepeatedUInt64Field(value: self.deadUnits, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_Event, rhs: SC2APIProtocol_Event) -> Bool {
    if lhs.deadUnits != rhs.deadUnits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_Effect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Effect"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "effect_id"),
    2: .same(proto: "pos"),
    3: .same(proto: "alliance"),
    4: .same(proto: "owner"),
    5: .same(proto: "radius"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self._effectID)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.pos)
      case 3: try decoder.decodeSingularEnumField(value: &self._alliance)
      case 4: try decoder.decodeSingularInt32Field(value: &self._owner)
      case 5: try decoder.decodeSingularFloatField(value: &self._radius)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._effectID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if !self.pos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pos, fieldNumber: 2)
    }
    if let v = self._alliance {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }
    if let v = self._owner {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._radius {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_Effect, rhs: SC2APIProtocol_Effect) -> Bool {
    if lhs._effectID != rhs._effectID {return false}
    if lhs.pos != rhs.pos {return false}
    if lhs._alliance != rhs._alliance {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._radius != rhs._radius {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ActionRaw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionRaw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "unit_command"),
    2: .standard(proto: "camera_move"),
    3: .standard(proto: "toggle_autocast"),
  ]

  fileprivate class _StorageClass {
    var _action: SC2APIProtocol_ActionRaw.OneOf_Action?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _action = source._action
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: SC2APIProtocol_ActionRawUnitCommand?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .unitCommand(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .unitCommand(v)}
        case 2:
          var v: SC2APIProtocol_ActionRawCameraMove?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .cameraMove(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .cameraMove(v)}
        case 3:
          var v: SC2APIProtocol_ActionRawToggleAutocast?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .toggleAutocast(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .toggleAutocast(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._action {
      case .unitCommand(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .cameraMove(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .toggleAutocast(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ActionRaw, rhs: SC2APIProtocol_ActionRaw) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._action != rhs_storage._action {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ActionRawUnitCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionRawUnitCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ability_id"),
    2: .standard(proto: "target_world_space_pos"),
    3: .standard(proto: "target_unit_tag"),
    4: .standard(proto: "unit_tags"),
    5: .standard(proto: "queue_command"),
  ]

  fileprivate class _StorageClass {
    var _abilityID: Int32? = nil
    var _target: SC2APIProtocol_ActionRawUnitCommand.OneOf_Target?
    var _unitTags: [UInt64] = []
    var _queueCommand: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _abilityID = source._abilityID
      _target = source._target
      _unitTags = source._unitTags
      _queueCommand = source._queueCommand
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt32Field(value: &_storage._abilityID)
        case 2:
          var v: SC2APIProtocol_Point2D?
          if let current = _storage._target {
            try decoder.handleConflictingOneOf()
            if case .targetWorldSpacePos(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._target = .targetWorldSpacePos(v)}
        case 3:
          if _storage._target != nil {try decoder.handleConflictingOneOf()}
          var v: UInt64?
          try decoder.decodeSingularUInt64Field(value: &v)
          if let v = v {_storage._target = .targetUnitTag(v)}
        case 4: try decoder.decodeRepeatedUInt64Field(value: &_storage._unitTags)
        case 5: try decoder.decodeSingularBoolField(value: &_storage._queueCommand)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._abilityID {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
      }
      switch _storage._target {
      case .targetWorldSpacePos(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .targetUnitTag(let v)?:
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
      case nil: break
      }
      if !_storage._unitTags.isEmpty {
        try visitor.visitRepeatedUInt64Field(value: _storage._unitTags, fieldNumber: 4)
      }
      if let v = _storage._queueCommand {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ActionRawUnitCommand, rhs: SC2APIProtocol_ActionRawUnitCommand) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._abilityID != rhs_storage._abilityID {return false}
        if _storage._target != rhs_storage._target {return false}
        if _storage._unitTags != rhs_storage._unitTags {return false}
        if _storage._queueCommand != rhs_storage._queueCommand {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ActionRawCameraMove: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionRawCameraMove"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "center_world_space"),
  ]

  fileprivate class _StorageClass {
    var _centerWorldSpace: SC2APIProtocol_Point? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _centerWorldSpace = source._centerWorldSpace
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._centerWorldSpace)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._centerWorldSpace {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ActionRawCameraMove, rhs: SC2APIProtocol_ActionRawCameraMove) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._centerWorldSpace != rhs_storage._centerWorldSpace {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SC2APIProtocol_ActionRawToggleAutocast: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionRawToggleAutocast"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ability_id"),
    2: .standard(proto: "unit_tags"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self._abilityID)
      case 2: try decoder.decodeRepeatedUInt64Field(value: &self.unitTags)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._abilityID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if !self.unitTags.isEmpty {
      try visitor.visitRepeatedUInt64Field(value: self.unitTags, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SC2APIProtocol_ActionRawToggleAutocast, rhs: SC2APIProtocol_ActionRawToggleAutocast) -> Bool {
    if lhs._abilityID != rhs._abilityID {return false}
    if lhs.unitTags != rhs.unitTags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
